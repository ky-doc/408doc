import{_ as i,X as r,Y as n,a3 as t}from"./framework-cd5fce69.js";const o="/408noteImg/images/image-20211121202511286.png",a="/408noteImg/images/image-20211121202548700.png",g="/408noteImg/images/image-20211121192900425.png",s="/408noteImg/images/image-20211121202620710.png",e="/408noteImg/images/image-20211121212900285.png",l="/408noteImg/images/image-20211121212940417.png",p="/408noteImg/images/image-20211122213548458.png",h="/408noteImg/images/image-20211122213644612.png",d="/408noteImg/images/image-20211122213851387.png",c="/408noteImg/images/image-20211122214009700.png",u="/408noteImg/images/image-20211122214108952.png",f="/408noteImg/images/image-20211122214442221.png",m="/408noteImg/images/image-20211123194240617.png",O="/408noteImg/images/image-20211123194348027.png",I="/408noteImg/images/image-20211123194414242.png",C="/408noteImg/images/image-20211122214853891.png",x={},b=t('<h2 id="i-o-管理概述" tabindex="-1"><a class="header-anchor" href="#i-o-管理概述" aria-hidden="true">#</a> I/O 管理概述</h2><h3 id="i-o-设备" tabindex="-1"><a class="header-anchor" href="#i-o-设备" aria-hidden="true">#</a> I/O 设备</h3><p>I/O 设备管理是操作系统设计中最凌乱也最具挑战性的部分</p><p>在理解设备管理之前，应该先了解具体的 I/O 设备类型</p><h5 id="按使用类型分类" tabindex="-1"><a class="header-anchor" href="#按使用类型分类" aria-hidden="true">#</a> 按使用类型分类</h5><ol><li><p>人机交互类外部设备：用于<strong>与计算机用户之间交互的设备</strong>，如键盘等</p><p>这类设备的数据交换速度相对较慢，通常是<strong>以字节为单位进行数据交换</strong>的</p></li><li><p>存储设备：用于<strong>存储程序和数据的设备</strong>，如磁盘等</p><p>这类设备用于数据交换，速度较快，通常<strong>以块为单位进行数据交换</strong></p></li><li><p>网络通信设备：用于<strong>与远程设备通信的设备</strong>，如各种网络接口、调制解调器等</p><p>其<strong>速度介于前两类设备之间</strong>，网络通信设备在使用和管理上与前两类设备也有很大不同</p></li></ol><h5 id="按传输速率分类" tabindex="-1"><a class="header-anchor" href="#按传输速率分类" aria-hidden="true">#</a> 按传输速率分类</h5><ol><li>低速设备：传输速率为<strong>每秒几字节到数百字节</strong>，如键盘、鼠标等</li><li>中速设备：传输速率为<strong>每秒数千字节至数万字节</strong>，如行式打印机、激光打印机等</li><li>高速设备：传输速率为<strong>每秒数百千字节至千兆字节</strong>，如磁带机、磁盘机、光盘机等</li></ol><h5 id="按信息交换的单位分类" tabindex="-1"><a class="header-anchor" href="#按信息交换的单位分类" aria-hidden="true">#</a> 按信息交换的单位分类</h5><ol><li><p>块设备：由于信息的存取总是以数据块为单位的，如磁盘等</p><p>属于有结构设备，<strong>传输速率较高、可寻址</strong>，即对它可随机地读/写任一块</p></li><li><p>字符设备：其传输的基本单位是字符，如键盘等</p><p>属于无结构类型，<strong>传输速率低、不可寻址</strong>，并且在输入/输出时常采用<strong>中断驱动方式</strong></p></li></ol><h3 id="i-o-控制方式" tabindex="-1"><a class="header-anchor" href="#i-o-控制方式" aria-hidden="true">#</a> I/O 控制方式</h3><h4 id="程序直接控制方式" tabindex="-1"><a class="header-anchor" href="#程序直接控制方式" aria-hidden="true">#</a> 程序直接控制方式</h4><p>对 I/O 设备发出命令后就<strong>一直检查外设的状态</strong>，直到确定该字已经在 I/O 控制器的数据寄存器中（<strong>每次读一个字</strong>）</p><figure><img src="'+o+'" alt="image-20211121202511286" tabindex="0" loading="lazy"><figcaption>image-20211121202511286</figcaption></figure><p>由于 CPU 的高速性和 I/O 设备的低速性，使得 <strong>CPU 浪费时间在等待上</strong>，造成了 CPU 资源的极大浪费</p><p>优点：简单且易于实现；缺点：CPU 和 I/O 设备只能串行工作，CPU 利用率相当低</p><h4 id="中断驱动方式" tabindex="-1"><a class="header-anchor" href="#中断驱动方式" aria-hidden="true">#</a> 中断驱动方式</h4><p>对 I/O 设备发出命令后 CPU 就去做其他事情，当 <strong>I/O 设备完后使用中断通知 CPU</strong>，CPU 处理中断（每次读一个字）</p><figure><img src="'+a+'" alt="image-20211121202548700" tabindex="0" loading="lazy"><figcaption>image-20211121202548700</figcaption></figure><p>优点：比程序直接控制方式 CPU 占用率更低；缺点：<strong>传送数据仍需要 CPU</strong>，消耗较多的 CPU 时间</p><h4 id="dma-方式" tabindex="-1"><a class="header-anchor" href="#dma-方式" aria-hidden="true">#</a> DMA 方式</h4><p>DMA 方式<strong>在 I/O 设备和内存之间开辟直接的数据交换通路</strong>，彻底解放 CPU</p><p>DMA 方式的特点如下：</p><ol><li><strong>基本单位是数据块</strong></li><li>所传送的数据，是从设备直接送入内存的，或者相反</li><li>整块数据的传送是在 DMA 控制器的控制下完成的</li><li>仅在<strong>传送一个或多个数据块的开始和结束时，才需 CPU 干预</strong></li></ol><p>要在主机与控制器之间实现成块数据的直接交换，则需在 DMA 控制器中设置：</p><ol><li>命令/状态寄存器 CR：接受 CPU 发来的 <strong>I/O 命令或有关控制信息</strong>，或<strong>设备的状态</strong></li><li>内存地址寄存器 MAR：输入时把设备的数据读入内存；输出时把内存的数据写入设备</li><li>数据寄存器 DR：用于暂存从设备到内存或从内存到设备的数据</li><li>数据计数器 DC：存放本次要传送的字（节）数</li></ol><figure><img src="'+g+'" alt="image-20211121192900425" tabindex="0" loading="lazy"><figcaption>image-20211121192900425</figcaption></figure><p>需要传送数据时 DMA <strong>向 CPU 发送请求</strong>，响应后开始传送数据，整个数据块传送完成后，<strong>向 CPU 发送中断信号</strong></p><figure><img src="'+s+'" alt="image-20211121202620710" tabindex="0" loading="lazy"><figcaption>image-20211121202620710</figcaption></figure><p>DMA 控制方式与中断驱动方式的主要区别：</p><ol><li>中断驱动方式：每字传输都要中断 CPU；DMA 控制方式：传送完一批数据后才需要中断 CPU</li><li>中断驱动方式：中断处理时由 CPU 传输数据；DMA 控制方式：在 DMA 控制器的控制下传输数据</li></ol><h4 id="通道控制方式" tabindex="-1"><a class="header-anchor" href="#通道控制方式" aria-hidden="true">#</a> 通道控制方式</h4><p>I/O 通道是指<strong>专门负责输入/输出的处理机</strong>，是 DMA 方式的发展，它可以<strong>进一步减少 CPU 的干预</strong>，基本单位是<strong>一组数据块</strong></p><p>当 CPU 要完成一组相关的读/写操作及有关控制时，向 I/O 通道<strong>发送一条 I/O 指令</strong>（通道程序的首地址和 I/O 设备号），通道接到该指令后，<strong>执行通道程序传送数据</strong>，数据传送结束时<strong>向 CPU 发中断请求</strong></p><p>I/O 通道与一般处理机的区别是：通道<strong>指令的类型单一</strong>，没有自己的内存，通道所执行的<strong>通道程序是放在内存中</strong></p><p>I/O 通道与 DMA 方式的区别是：</p><ul><li>DMA 方式<strong>需要 CPU 来控制传输的数据块大小、传输的内存位置</strong>；通道方式中这些信息是<strong>由通道控制的</strong></li><li>每个 DMA 控制器<strong>对应一台设备</strong>与内存传递数据；一个通道可以<strong>控制多台设备</strong>与内存的数据交换</li></ul><p>思考：CPU 要进行 I/O 时可能在内存写好通道程序，然后发送命令给 I/O 通道运行这些程序，运行完后发送中断</p><h3 id="i-o-子系统的层次结构" tabindex="-1"><a class="header-anchor" href="#i-o-子系统的层次结构" aria-hidden="true">#</a> I/O 子系统的层次结构</h3><h4 id="i-o-软件层次结构" tabindex="-1"><a class="header-anchor" href="#i-o-软件层次结构" aria-hidden="true">#</a> I/O 软件层次结构</h4><p>I/O 软件涉及的面非常广，<strong>即与硬件有着密切的联系，又与用户直接交互</strong>，它与进程管理、存储器管理、文件管理等都有联系</p><p>在 I/O 软件中普遍采用了层次式结构，每层都利用其下层提供的服务，完成输入/输出功能中的某些子功能，向高层提供服务</p><p>只要层次间的接口不变，对某一层次中的软件的修改都不会引起其下层或高层代码的变更，<strong>仅最低层才涉及硬件的具体特性</strong></p><figure><img src="'+e+'" alt="image-20211121212900285" tabindex="0" loading="lazy"><figcaption>image-20211121212900285</figcaption></figure><p>整个 I/O 系统可以视为具有 4 个层次的系统结构，各层次及其功能如下：</p><h5 id="用户层-i-o-软件" tabindex="-1"><a class="header-anchor" href="#用户层-i-o-软件" aria-hidden="true">#</a> 用户层 I/O 软件</h5><p><strong>实现与用户交互的接口</strong>，用户可直接调用在用户层提供的、与 I/O 操作有关的库函数，对设备进行操作</p><p>大部分 I/O 软件在 OS 内部，小部分在用户层，包括与用户程序链接在一起的库函数，和完全运行于内核之外的一些程序</p><p>用户层软件<strong>必须通过一组系统调用来获取操作系统服务</strong></p><h5 id="设备独立性软件" tabindex="-1"><a class="header-anchor" href="#设备独立性软件" aria-hidden="true">#</a> 设备独立性软件</h5><p>为了<strong>实现设备独立性</strong>，必须再在驱动程序之上设置一层设备独立性软件</p><p>设备独立性也称设备无关性，使<strong>应用程序独立于具体使用的物理设备</strong>，通过引入了逻辑设备和物理设备来实现</p><ul><li>在应用程序中，使用逻辑设备名来请求使用<strong>某类设备</strong></li><li>在系统实际执行时，必须<strong>将逻辑设备名映射成物理设备名使用</strong></li></ul><p>使用逻辑设备名的好处是：</p><ol><li><strong>增加设备分配的灵活性</strong></li><li><strong>易于实现 I/O 重定向</strong>，即用于 I/O 操作的设备可以更换，而不必改变应用程序</li></ol><p>设备独立性软件的主要功能可分为以下两个方面：</p><ol><li><strong>执行所有设备的公有操作</strong>： <ul><li>对设备的分配与回收</li><li>将逻辑设备名映射为物理设备名</li><li>对设备进行保护，禁止用户直接访问设备</li><li>缓冲管理</li><li>差错控制</li><li>提供缓冲区，屏蔽设备之间信息交换单位大小和传输速率的差异</li></ul></li><li>向用户层（或文件层）<strong>提供统一接口</strong>：无论何种设备，它们向用户所提供的接口应是相同的</li></ol><h5 id="设备驱动程序" tabindex="-1"><a class="header-anchor" href="#设备驱动程序" aria-hidden="true">#</a> 设备驱动程序</h5><p><strong>与硬件直接相关</strong>，负责<strong>具体实现系统对设备发出的操作指令</strong>，驱动 I/O 设备工作的驱动程序</p><p><strong>每类设备配置一个设备驱动程序</strong>，它是 I/O 进程与设备控制器之间的通信程序，常以进程形式存在</p><p>设备驱动程序向上层用户程序<strong>提供一组标准接口</strong>，设备具体的<strong>差别被设备驱动程序所封装</strong>，从而隐藏设备控制器之间的差异</p><p>把上层的命令转换为具体要求后，发送给设备控制器，控制 I/O 设备工作；设备控制器发来的信号也传送给上层软件</p><h5 id="中断处理程序" tabindex="-1"><a class="header-anchor" href="#中断处理程序" aria-hidden="true">#</a> 中断处理程序</h5><p><u>保存被中断进程的 CPU 环境，转入相应的中断处理程序进行处理，处理完并恢复被中断进程的现场后，返回到被中断进程</u></p><p>中断处理层的主要任务有：进行进程上下文的切换，对处理中断信号源进行测试，读取设备状态和修改进程状态等</p><p>由于中断处理与硬件紧密相关，对用户而言，应尽量加以屏蔽，因此应放在操作系统的底层</p><h5 id="硬件设备" tabindex="-1"><a class="header-anchor" href="#硬件设备" aria-hidden="true">#</a> 硬件设备</h5><p>I/O 设备通常包括<strong>一个机械部件和一个电子部件</strong>：</p><ul><li>电子部件，设备控制器（适配器），通常是一块插入主板扩充槽的印刷电路板</li><li>机械部件：设备本身</li></ul><p>思考：用户想要读某设备时，调用用户层的 read 命令，由设备独立性软件分配设备，由设备驱动程序解析成硬件使用的指令，由中断处理程序中断当前进程，让硬件运行读命令</p><h4 id="i-o-控制器" tabindex="-1"><a class="header-anchor" href="#i-o-控制器" aria-hidden="true">#</a> *I/O 控制器</h4><p>设备控制器<strong>通过内部的寄存器与 CPU 通信</strong>：</p><ul><li>内存映像 I/O：这些寄存器占用内存地址的一部分</li><li>寄存器独立编址：采用 I/O 专用地址</li></ul><p>设备控制器的工作方式：</p><ol><li>OS 向控制器的寄存器<strong>写命令字</strong></li><li>控制器收到一条命令后，<strong>完成具体的 I/O 操作</strong></li><li>命令执行完毕后，控制器<strong>发出一个中断信号</strong></li><li>OS 检查执行结果，从状态寄存器中读取设备的状态</li></ol><p>设备控制器的主要功能如下：</p><ol><li>接收和识别 CPU 或通道发来的命令</li><li>实现数据交换，包括<strong>设备和控制器之间的数据传输</strong>以及<strong>控制器和主存之间的数据传输</strong></li><li><strong>发现和记录设备及自身的状态信息</strong>，供 CPU 处理使用</li><li><strong>设备地址识别</strong></li></ol><p>为实现上述功能，设备控制器包含以下组成部分：</p><ol><li><p>设备控制器与 CPU 的接口：该接口有<strong>数据线、地址线、控制线</strong></p><p>数据线：修改或读取数据寄存器和控制/状态寄存器的内容</p></li><li><p>设备控制器与设备的接口：</p><p>设备控制器连接设备需要相应数量的接口，<strong>一个接口连接一台设备</strong></p><p>每个接口中都存在<strong>数据、控制和状态</strong>三种类型的信号</p></li><li><p>I/O 控制逻辑：用于<strong>实现对设备的控制</strong></p><p>它通过一组控制线与 CPU 交互，对从 CPU 收到的 I/O 命令进行译码</p></li></ol><figure><img src="'+l+'" alt="image-20211121212940417" tabindex="0" loading="lazy"><figcaption>image-20211121212940417</figcaption></figure><p>思考：由于设备控制器链接多个设备，有多个设备同时使用的情况，所以数据寄存器和控制/状态寄存器应有多个</p><p>注意：以机组的为准</p><h2 id="i-o-核心子系统" tabindex="-1"><a class="header-anchor" href="#i-o-核心子系统" aria-hidden="true">#</a> I/O 核心子系统</h2><h3 id="i-o-子系统概述" tabindex="-1"><a class="header-anchor" href="#i-o-子系统概述" aria-hidden="true">#</a> I/O 子系统概述</h3><p>由于 I/O 设备种类繁多，功能和传输速率差异巨大，因此需要多种方法来进行设备控制</p><p>这些方法共同组成了操作系统内核的 I/O 子系统，它<strong>将内核的其他方面从繁重的 I/O 设备管理中解放出来</strong></p><p>I/O 核心子系统提供的服务主要有 I/O 调度、缓冲与高速缓存、设备分配与回收、假脱机、设备保护和差错处理等</p><h3 id="i-o-调度概念" tabindex="-1"><a class="header-anchor" href="#i-o-调度概念" aria-hidden="true">#</a> I/O 调度概念</h3><p>I/O 调度就是<strong>确定一个好的顺序来执行这些 I/O 请求</strong>，从而改善系统整体性能，使进程之间公平地共享设备访问</p><p>操作系统<strong>为每个设备维护一个请求队列</strong>，调度就是从中选择一个请求来运行，如磁盘调度算法</p><h3 id="高速缓存与缓冲区" tabindex="-1"><a class="header-anchor" href="#高速缓存与缓冲区" aria-hidden="true">#</a> 高速缓存与缓冲区</h3><h4 id="磁盘高速缓存-disk-cache" tabindex="-1"><a class="header-anchor" href="#磁盘高速缓存-disk-cache" aria-hidden="true">#</a> 磁盘高速缓存 Disk Cache</h4><p>磁盘高速缓存技术指<strong>利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息</strong>，对内存访问更快</p><p>磁盘高速缓存逻辑上属于磁盘，物理上则是驻留在内存中的盘块</p><p>高速缓存在内存中分为两种形式：</p><ol><li><strong>在内存中开辟一个单独的存储空间</strong>作为磁盘高速缓存，大小固定</li><li>把<strong>未利用的内存空间作为一个缓冲池</strong>，供请求分页系统和磁盘 I/O 时共享</li></ol><p>额外：预读是从磁盘读数据额外预读数据，滞后写是等多一点数据再写，都可以概述磁盘 I/O 性能</p><h4 id="缓冲区-buffer" tabindex="-1"><a class="header-anchor" href="#缓冲区-buffer" aria-hidden="true">#</a> 缓冲区 Buffer</h4><p>在设备管理子系统中，引入缓冲区的目的主要如下：</p><ol><li><strong>缓和 CPU 与 I/O 设备间速度不匹配的矛盾</strong></li><li><strong>减少对 CPU 的中断频率</strong>，放宽对 CPU 中断响应时间的限制</li><li><strong>解决基本数据单元大小不匹配的问题</strong></li><li><strong>提高 CPU 和 I/O 设备之间的并行性</strong></li></ol><p>其实现方法如下：</p><ol><li>采用<strong>硬件缓冲器</strong>，但由于成本太高，只用于关键部位</li><li>采用<strong>缓冲区</strong>，位于内存区域</li></ol><p><strong>缓冲区有以下特点：</strong></p><ul><li>当缓冲区的数据非空时，只能从缓冲区把数据传出</li><li>当缓冲区为空时，可以往缓冲区冲入数据</li><li>必须把缓冲区充满后，才能从缓冲区把数据传出</li></ul><p>选择题：单缓冲、双缓冲、循环缓冲属于<strong>专用缓冲</strong>；缓冲池是系统的共用资源，<strong>可共享</strong></p><p>选择题：缓冲区管理着重要考虑的问题是<strong>实现进程访问缓冲区的同步</strong></p><p>根据系统设置缓冲器的个数，缓冲技术可以分为如下几种：</p><h5 id="单缓冲" tabindex="-1"><a class="header-anchor" href="#单缓冲" aria-hidden="true">#</a> 单缓冲</h5><p>在设备和处理机之间<strong>设置一个缓冲区</strong>，被交换数据先写入缓冲区，然后被需要数据的设备或处理机取走</p><p>假设设备输入一块数据仅缓冲区的时间为 T，缓冲区中传送到用户区的时间为 M，数据处理的时间为 C</p><p>计算处理一块数据所需的时间：<strong>假设一种初始状态，计算下一次到达相同状态时所需的时间</strong></p><p>设初始状态为：工作区是满的，缓冲区是空的，一般认为缓冲区的大小和工作区的大小相等：</p><ul><li>假设 T &gt; C：在 T 时间后写入缓冲区和处理数据都完成，M 时间传送到用户区后，回到初始状态，用时 M + T</li><li>假设 T &lt; C：在 C 时间后写入缓冲区和处理数据都完成，M 时间传送到用户区后，回到初始状态，用时 M + C</li></ul><p>所以<strong>单缓冲区处理每块数据的用时为 max(C, T) + M</strong></p><p>注意：缓冲区中传送到用户区和数据处理都是 CPU 在做，所以不能并行，但都可以和设备输入数据并行</p><figure><img src="'+p+'" alt="image-20211122213548458" tabindex="0" loading="lazy"><figcaption>image-20211122213548458</figcaption></figure><h5 id="双缓冲" tabindex="-1"><a class="header-anchor" href="#双缓冲" aria-hidden="true">#</a> 双缓冲</h5><p>I/O 设备输入数据时先装填到缓冲区 1，在缓冲区 1 填满后才开始装填缓冲区 2，同时可以从缓冲区 1 中取出数据</p><p>双缓冲机制<strong>提高了处理机和输入设备的并行操作的程度</strong></p><p>设初始状态为：工作区是空的，一个缓冲区是满的，另一个缓冲区是空的；不妨假设 1 满 2 空</p><ul><li>假设 T &gt; C + M：当 T 时间后回到初始状态</li><li>假设 T &lt; C + M：当 C + M 时间后回到初始状态（每次进行一个数据块的处理必定需要 C + M 的时间）</li></ul><p><strong>双缓冲区处理一块数据的用时为 max(C + M, T)</strong></p><figure><img src="'+h+'" alt="image-20211122213644612" tabindex="0" loading="lazy"><figcaption>image-20211122213644612</figcaption></figure><p>若 M + C &lt; T，则可使块设备连续输入；若 C + M &gt; T，则可使 CPU 不必等待设备输入</p><h5 id="单双缓冲对比" tabindex="-1"><a class="header-anchor" href="#单双缓冲对比" aria-hidden="true">#</a> 单双缓冲对比</h5><p>对于字符设备，若采用行输入方式：</p><ul><li>双缓冲：用户在输入第一行后，<u>在 CPU 执行第一行中的命令的同时，用户可继续向第二缓冲区输入下一行数据</u></li><li>单缓冲：<u>必须等待一行数据被提取完毕才可输入下一行的数据</u></li></ul><p>两台机器之间通信：</p><ul><li>单缓冲：它们在任意时刻都只能实现单方向的数据传输，而绝<strong>不允许双方同时向对方发送数据</strong></li><li>双缓冲：一个用作发送缓冲区，另一个用作接收缓冲区，<strong>实现双向数据传输</strong></li></ul><figure><img src="'+d+'" alt="image-20211122213851387" tabindex="0" loading="lazy"><figcaption>image-20211122213851387</figcaption></figure><h5 id="循环缓冲" tabindex="-1"><a class="header-anchor" href="#循环缓冲" aria-hidden="true">#</a> 循环缓冲</h5><p>包含<strong>多个大小相等的缓冲区</strong>，这些缓冲区<strong>以循环链表的方式链接在一起</strong>，形成一个环形</p><p>循环缓冲用于输入/输出时，还需要有两个指针 in 和 out：</p><ul><li>输入：从 in 拿到第一个空缓冲区，从设备接收数据到缓冲区中，放满后 in 指向下一个</li><li>输出：从 out 取第一个满缓冲区，从此缓冲区中提取数据，取空后 out 指向下一个</li></ul><h5 id="缓冲池" tabindex="-1"><a class="header-anchor" href="#缓冲池" aria-hidden="true">#</a> 缓冲池</h5><p>由<strong>多个系统公用的缓冲区组成</strong>，缓冲区按其使用状况可以形成三个队列：</p><p><strong>空缓冲队列</strong>、装满输入数据的缓冲队列（<strong>输入队列</strong>）和装满输出数据的缓冲队列（<strong>输出队列</strong>）</p><p>还应具有 4 种缓冲区：</p><ol><li>用于收容输入数据的工作缓冲区</li><li>用于提取输入数据的工作缓冲区</li><li>用于收容输出数据的工作缓冲区</li><li>用于提取输出数据的工作缓冲区</li></ol><p><strong>进程与缓冲区的交互</strong>：</p><ul><li>输入进程输入数据：从空缓冲队列队首取一个空缓冲区，作为 1，输入数据后挂在输入队列队尾</li><li>计算进程接受数据：从输入队列队首取一个缓冲区，作为 2，提取数据使用完后挂在空缓冲队列</li><li>计算进程输出数据：从空缓冲队列队首取一个空缓冲区，作为 3，输入数据后挂在输出队列队尾</li><li>输出进程接受数据：从输出队列队首取一个缓冲区，作为 4，提取数据使用完后挂在空缓冲队列</li></ul><figure><img src="'+c+'" alt="image-20211122214009700" tabindex="0" loading="lazy"><figcaption>image-20211122214009700</figcaption></figure><h4 id="高速缓存与缓冲区的对比" tabindex="-1"><a class="header-anchor" href="#高速缓存与缓冲区的对比" aria-hidden="true">#</a> 高速缓存与缓冲区的对比</h4><figure><img src="'+u+'" alt="image-20211122214108952" tabindex="0" loading="lazy"><figcaption>image-20211122214108952</figcaption></figure><h3 id="设备分配与回收" tabindex="-1"><a class="header-anchor" href="#设备分配与回收" aria-hidden="true">#</a> 设备分配与回收</h3><h4 id="设备分配概述" tabindex="-1"><a class="header-anchor" href="#设备分配概述" aria-hidden="true">#</a> 设备分配概述</h4><p>设备分配是指<strong>根据用户的 I/O 请求分配所需的设备</strong></p><p>分配的总原则：①<strong>充分发挥设备的使用效率</strong>，尽可能地让设备忙碌；②<strong>避免造成进程死锁</strong></p><p>从设备的特性来看，有以下使用设备的方式：</p><ol><li>独占式使用设备：<strong>申请设备时，若设备空闲，则将其独占</strong>，直到该设备被释放才允许其他进程申请使用</li><li>分时式共享使用设备：当设备没有独占使用的要求时，可以<strong>通过分时共享使用提高利用率</strong></li><li>以 SPOOLing 方式使用外部设备：在批处理操作系统时代引入，<strong>用于对设备的操作</strong>，实质上就是对 I/O 操作进行批处理，是<strong>以空间换时间的技术</strong></li></ol><h4 id="设备分配的数据结构" tabindex="-1"><a class="header-anchor" href="#设备分配的数据结构" aria-hidden="true">#</a> 设备分配的数据结构</h4><p>设备分配依据的主要数据结构有<u>设备控制表 DCT、控制器控制表 COCT、通道控制表 CHCT、系统设备表 SDT</u></p><p>由于在多道程序系统中，进程数多于资源数，会引起资源的竞争，因此要有一套合理的分配原则</p><p>主要考虑的因素：I/O 设备的固有属性、I/O 设备的分配算法、I/O 设备分配的安全性、I/O 设备的独立性</p><p>思考：一个通道对应多个设备控制器，一个设备控制器对应多个设备</p><h5 id="设备控制表" tabindex="-1"><a class="header-anchor" href="#设备控制表" aria-hidden="true">#</a> 设备控制表</h5><p><strong>一个设备控制表就表征一个设备</strong>，而这个控制表中的表项就是设备的各个属性</p><figure><img src="'+f+'" alt="image-20211122214442221" tabindex="0" loading="lazy"><figcaption>image-20211122214442221</figcaption></figure><ul><li>设备标识符：<strong>物理设备名</strong>，系统中的每个设备的物理设备名唯一</li><li>指向控制器表的指针：每个设备由一个控制器控制，该指针可找到相应控制器的信息</li><li>重复执行次数或时间：当重复执行多次 I/O 操作后仍不成功，才认为此次 I/O 失败</li><li>设备队列的队首指针：<strong>指向正在等待该设备的进程队列</strong>，由进程 PCB 组成队列</li></ul><h5 id="控制器控制表" tabindex="-1"><a class="header-anchor" href="#控制器控制表" aria-hidden="true">#</a> 控制器控制表</h5><figure><img src="'+m+'" alt="image-20211123194240617" tabindex="0" loading="lazy"><figcaption>image-20211123194240617</figcaption></figure><ul><li>控制器标识符：各个控制器的唯一 ID</li><li>与控制器连接的通道表指针：每个控制器由一个通道控制，该指针可找到相应通道的信息</li><li>控制器队列的队首/尾指针：<strong>指向正在等待该控制器的进程队列</strong>，由进程 PCB 组成队列</li></ul><h5 id="通道控制表" tabindex="-1"><a class="header-anchor" href="#通道控制表" aria-hidden="true">#</a> 通道控制表</h5><p>通道方式显然要比其他几种方式更加优越，因此<strong>现代操作系统的 I/O 控制采用的都是通道控制</strong></p><figure><img src="'+O+'" alt="image-20211123194348027" tabindex="0" loading="lazy"><figcaption>image-20211123194348027</figcaption></figure><ul><li>通道标识符：各个通道的唯一 ID</li><li>与通道连接的控制器表首址：可通过该指针找到<strong>该通道管理的所有控制器</strong>相关信息</li><li>通道队列的队首/尾指针：<strong>指向正在等待该通道的进程队列</strong>，由进程 PCB 组成队列</li></ul><h5 id="系统设备表" tabindex="-1"><a class="header-anchor" href="#系统设备表" aria-hidden="true">#</a> 系统设备表</h5><p>系统设备表 SDT：<strong>整个系统只有一张 SDT</strong>，它记录已连接到系统中的所有物理设备的情况，<strong>每个物理设备占一个表目</strong></p><figure><img src="'+I+'" alt="image-20211123194414242" tabindex="0" loading="lazy"><figcaption>image-20211123194414242</figcaption></figure><ul><li>设备类：记录设备的类型，逻辑设备名就是这个</li><li>设备标识符：物理设备名</li></ul><h4 id="设备的分配步骤" tabindex="-1"><a class="header-anchor" href="#设备的分配步骤" aria-hidden="true">#</a> 设备的分配步骤</h4><ol><li><p>根据进程请求的逻辑设备名查找 SDT，<strong>用户编程时提供的逻辑设备名是设备类型</strong></p></li><li><p>查找 SDT，找到<strong>指定类型的、并且空闲的设备</strong>，将其分配给该进程，操作系统<strong>在逻辑设备表 LUT 中新增一个表项</strong></p><p>若没有空闲的设备，则将进程 PCB 挂到该类设备的等待队列上</p></li><li><p>根据 DCT 找到 COCT，若<strong>控制器忙碌则将进程 PCB 挂到控制器等待队列中</strong>，不忙碌则将控制器分配给进程</p></li><li><p>根据 COCT 找到 CHCT，若<strong>通道忙碌则将进程 PCB 挂到通道等待队列中</strong>，不忙碌则将通道分配给进程</p><p>若设备控制器连接了多个通道，则在通道忙时检查下一个通道的状态</p></li></ol><p>要成功分配一个设备必须要：设备可用、控制器可用、通道可用</p><h4 id="设备分配的策略" tabindex="-1"><a class="header-anchor" href="#设备分配的策略" aria-hidden="true">#</a> 设备分配的策略</h4><ol><li><p>设备分配原则：设备分配应<strong>根据设备特性、用户要求、系统配置情况</strong></p><p>分配的总原则是：充分发挥设备的使用效率；避免造成进程死锁；<strong>将用户程序和具体设备隔离开</strong></p></li><li><p>设备分配方式：</p><ul><li><p>静态分配：主要<strong>用于对独占设备的分配</strong></p><p>在用户作业开始执行前，由系统<strong>一次性分配该作业所要求的全部设备、控制器</strong>，直到该作业被撤销</p><p>静态分配方式不会出现死锁，但<strong>设备的使用效率低</strong>，不符合分配的总原则</p></li><li><p>动态分配：在<strong>进程执行过程中根据执行需要进行</strong></p><p>当进程需要设备时，由系统给进程分配所需要的设备、I/O控制器，<strong>一旦用完，便立即释放</strong></p><p>动态分配方式<strong>有利于提高设备的利用率</strong>，但若分配算法使用不当，则<strong>有可能造成进程死锁</strong></p></li></ul></li><li><p>设备分配算法：</p><p>常用的<strong>动态设备分配算法</strong>有<strong>先请求先分配、优先级高者优先</strong>等</p><p>独占设备：既可以采用动态分配方式，又可以采用静态分配方式，但往往<strong>采用静态分配方式</strong></p><p>共享设备：可被多个进程所共享，一般<strong>采用动态分配方式</strong></p></li></ol><h4 id="设备分配的安全性" tabindex="-1"><a class="header-anchor" href="#设备分配的安全性" aria-hidden="true">#</a> 设备分配的安全性</h4><p>设备分配的安全性是指<strong>设备分配中应防止发生进程死锁</strong></p><ol><li><p>安全分配方式：每当进程发出 I/O 请求后便进入阻塞态，直到 <strong>I/O 操作完成时才被唤醒</strong></p><p>因为被阻塞到 I/O 完成，所以它运行时不占资源，阻塞时占一个资源，不会死锁</p><p>优点：<strong>设备分配安全</strong>；缺点：CPU 和 I/O 设备<strong>是串行工作</strong>的</p></li><li><p>不安全分配方式：进程在发出 I/O 请求后<strong>继续运行</strong>，可以继续发 I/O 请求</p><p>仅当进程所请求的设备已<strong>被另一进程占用时，才进入阻塞态</strong></p><p>优点：可同时占多个设备，以<strong>迅速推进进程</strong>；缺点：这种设备分配有<strong>可能产生死锁</strong></p></li></ol><h4 id="逻辑设备名到物理设备名的映射" tabindex="-1"><a class="header-anchor" href="#逻辑设备名到物理设备名的映射" aria-hidden="true">#</a> 逻辑设备名到物理设备名的映射</h4><p>设备独立性：<strong>应用程序独立于具体使用的物理设备</strong>，用于提高设备分配的灵活性和设备的利用率，方便实现 I/O 重定向</p><p>逻辑设备表 LUT：用于<strong>将逻辑设备名映射为物理设备名</strong>，以实现设备独立性</p><p>LUT 表项包括<strong>逻辑设备名、物理设备名、设备驱动程序入口地址</strong>：</p><ul><li>当进程<strong>用逻辑设备名来请求分配设备</strong>时，系统为它<strong>分配相应的物理设备</strong>，并在 LUT 中建立一个表项</li><li>以后进程再利用逻辑设备名请求 I/O 操作时，系统通过<strong>查找 LUT 来寻找相应的物理设备和驱动程序</strong></li></ul><p>在系统中可采取两种方式建立逻辑设备表：</p><ol><li><strong>整个系统中只设置一张 LUT</strong>：这样不允许有相同的逻辑设备名，主要<strong>适用于单用户系统</strong></li><li><strong>每个用户设置一张 LUT</strong>：当用户登录时，OS 为用户建立一个进程和一张 LUT，并<strong>把该表放入进程的 PCB</strong></li></ol><h3 id="spooling-技术" tabindex="-1"><a class="header-anchor" href="#spooling-技术" aria-hidden="true">#</a> SPOOLing 技术</h3><p>脱机输入/输出技术：<strong>缓和 CPU 的高速性与 I/O 设备低速性之间的矛盾</strong></p><ul><li>处理器只与高速的磁盘交换数据，而不与低速 I/O 设备交换</li><li>利用专门的外围控制机，让低速 I/O 设备与高速磁盘进行输入输出</li></ul><p>SPOOLing 又称<strong>假脱机输入/输出</strong>操作，是操作系统中采用的一项<strong>将独占设备改造成共享设备</strong>的技术，下面是它的组成：</p><figure><img src="'+C+'" alt="image-20211122214853891" tabindex="0" loading="lazy"><figcaption>image-20211122214853891</figcaption></figure><p>选择题：SPOOLing 系统由<u>预输入程序、井管理程序、缓输出程序</u>组成</p><h4 id="输入井和输出井" tabindex="-1"><a class="header-anchor" href="#输入井和输出井" aria-hidden="true">#</a> 输入井和输出井</h4><p>输入井和输出井是指<strong>在磁盘上</strong>开辟出的两个存储区域：</p><ul><li>输入井模拟脱机输入时的磁盘，用于<strong>收容 I/O 设备输入的数据</strong></li><li>输出井模拟脱机输出时的磁盘，用于<strong>收容用户程序的输出数据</strong></li></ul><p>思考：输入井和输出井与用户程序直接连接，发送数据时写到输出井；接受数据时从输入井拿</p><h4 id="输入缓冲区和输出缓冲区" tabindex="-1"><a class="header-anchor" href="#输入缓冲区和输出缓冲区" aria-hidden="true">#</a> 输入缓冲区和输出缓冲区</h4><p>输入缓冲区和输出缓冲区是<strong>在内存中</strong>开辟的两个缓冲区：</p><ul><li>输入缓冲区：用于<strong>暂存由输入设备送来的数据</strong>，以后再传送到输入井</li><li>输出缓冲区：用于<strong>暂存从输出井送来的数据</strong>，以后再传送到输出设备</li></ul><p>思考：这部分对用户程序透明，由于 I/O 设备是与内存交互的，所以数据要经过内存</p><h4 id="输入进程和输出进程" tabindex="-1"><a class="header-anchor" href="#输入进程和输出进程" aria-hidden="true">#</a> 输入进程和输出进程</h4><p>输入进程和输出进程就是<strong>模拟脱机输入和脱机输出时的外围控制机</strong>：</p><ul><li><p>输入进程：将数据从 I/O 设备通过输入缓冲区再送到输入井，<strong>用户需要数据时直接从输入井拿</strong></p></li><li><p>输出进程：<strong>用户需要发送数据时放入输出井</strong>，对应的 I/O 设备空闲时，从输出井拿出数据经过输出缓冲区送到 I/O 设备</p></li></ul><p>共享打印机是使用 SPOOLing 技术的一个实例，这项技术已被<u>广泛地用于多用户系统和局域网络</u></p><p>当用户进程请求打印输出时，SPOOLing 系统同意为它打印输出并为它做两件事：</p><ol><li>输出进程在输出井中为之<strong>申请一个空闲磁盘块区</strong>，并<strong>将要打印的数据送入其中</strong></li><li>输出进程申请一张空白的用户请求打印表，写入用户打印要求，<strong>挂到请求打印队列上</strong></li></ol><p>SPOOLing 系统的主要特点有：<strong>提高了 I/O 的速度；将独占设备改造为共享设备；实现了虚拟设备功能</strong></p><p>思考：提高了 I/O 速度是对于用户程序而言的，它只需要对磁盘进行 I/O 相比于 I/O 设备来说快了很多</p><p>注意：用户对井的操作是通过 SPOOLing 软件来进行的，而不是直接访问井</p>',208),_=[b];function P(U,T){return r(),n("div",null,_)}const D=i(x,[["render",P],["__file","第五章 输入输出管理.html.vue"]]);export{D as default};
