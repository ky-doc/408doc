import{_ as t,X as l,Y as e,Z as s,a1 as n,a2 as a}from"./framework-0cdb5b8e.js";const p="/408doc/408noteImg/images/image-20210916160654157.png",i="/408doc/408noteImg/images/image-20210916202647863.png",c="/408doc/408noteImg/images/image-20210916202710346.png",o="/408doc/408noteImg/images/image-20210916221701804.png",r="/408doc/408noteImg/images/image-20210916225214560.png",m="/408doc/408noteImg/images/image-20210917202041035.png",u="/408doc/408noteImg/images/image-20210917230116841.png",h="/408doc/408noteImg/images/image-20210919141347791.png",g="/408doc/408noteImg/images/image-20210919142223692.png",d="/408doc/408noteImg/images/image-20210919144047050.png",k="/408doc/408noteImg/images/image-20210919152628452.png",v="/408doc/408noteImg/images/image-20210920122745558.png",y="/408doc/408noteImg/images/v2-db1cdb0da952a71f9b6d64b2608467eb_b.webp",b="/408doc/408noteImg/images/v2-05246384c1c16537ca6176983bdb2627_b.webp",w="/408doc/408noteImg/images/image-20210920141556685.png",x="/408doc/408noteImg/images/src=http___pic2.zhimg.com_v2-5591c52619c16ddd52a882981fa716cd_b.gif&refer=http___pic2.zhimg.gif",f="/408doc/408noteImg/images/image-20210920150005087.png",z={},_=s("h2",{id:"树的基本概念",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#树的基本概念","aria-hidden":"true"},"#"),n(" 树的基本概念")],-1),M=s("h3",{id:"树的定义",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#树的定义","aria-hidden":"true"},"#"),n(" 树的定义")],-1),T=s("p",null,[n("树是 n（"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n"),s("mo",null,"≥"),s("mn",null,"0")]),s("annotation",{encoding:"application/x-tex"},"n\\geq0")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≥"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"0")])])]),n("）个结点的有限集。当 n = 0 时，称为空树，在任意一棵非空树中应满足：")],-1),L=s("ol",null,[s("li",null,[n("有且仅有"),s("strong",null,"一个特定的称为根的结点")]),s("li",null,[n("当 n > 1 时，其余结点可分为 m（m > 0）个互不相交的有限集 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"T"),s("mn",null,"1")]),s("mo",{separator:"true"},","),s("mo",null,"⋯"),s("mtext",null," "),s("mo",{separator:"true"},","),s("msub",null,[s("mi",null,"T"),s("mi",null,"m")])]),s("annotation",{encoding:"application/x-tex"},"T_1,\\cdots,T_m")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8778em","vertical-align":"-0.1944em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"T"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.1389em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"minner"},"⋯"),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"T"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.1514em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.1389em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"m")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),n("，其中"),s("strong",null,"每个集合本身又是一棵树"),n("，并称为"),s("strong",null,"根的子树")])],-1),N=a('<p>树的定义是<strong>递归</strong>的，在<strong>树的定义中又用到了其自身</strong>，树作为一种<strong>逻辑结构</strong>，同时也是一种<strong>分层结构</strong>，有以下特定：</p><ol><li>树的<strong>根结点没有前驱</strong>，<strong>除根结点外</strong>的所有结点有且<strong>只有一个前驱</strong></li><li>树中所有结点可以有<strong>零个或多个后继</strong></li></ol><p><strong>树适合表示具有层次结构的数据</strong>，树中<strong>除根结点外</strong>的某个结点最多只和<strong>上一层</strong>的一个结点有<strong>直接关系</strong></p><p><strong>根结点没有直接上层结点</strong>，因此<u>在 n 个结点的树中有 n - 1 条边</u>，而树中每个结点与其<strong>下一层</strong>的零个或多个结点有<strong>直接关系</strong></p><h3 id="基本术语" tabindex="-1"><a class="header-anchor" href="#基本术语" aria-hidden="true">#</a> 基本术语</h3><figure><img src="'+p+'" alt="image-20210916160654157" tabindex="0" loading="lazy"><figcaption>image-20210916160654157</figcaption></figure>',6),S=s("ol",null,[s("li",null,[n("根 A 到结点 K 的唯一路径上的任意结点，称为结点 K 的"),s("strong",null,"祖先"),n("；相对 K 就是它们的"),s("strong",null,"子孙"),n("，如 B 是 K 的祖先，K 是 B 的子孙")]),s("li",null,[n("祖先中最接近 K 的结点 E 称为 K 的"),s("strong",null,"双亲"),n("，而 K 称为 K 的"),s("strong",null,"孩子"),n("，根结点是唯一没有双亲的结点")]),s("li",null,[n("有相同双亲的结点称为"),s("strong",null,"兄弟"),n("，如结点 K 和结点 L 有相同的双亲，即 K 和 L 为兄弟")]),s("li",null,[n("树中"),s("strong",null,"一个结点的孩子个数"),n("称为该"),s("strong",null,"结点的度"),n("，"),s("strong",null,"树中结点的最大度数"),n("称为"),s("strong",null,"树的度"),n("，如 B 的度 2，树的度 3")]),s("li",null,[n("度大于 0 的结点称为"),s("strong",null,"分支结点"),n("或"),s("strong",null,"非终端结点"),n("；度为 0 的结点称为"),s("strong",null,"叶子结点"),n("或"),s("strong",null,"终端结点"),n("，每个结点的分支数就是该结点的度")]),s("li",null,[n("结点的"),s("strong",null,"层次"),n("从树根开始定义，"),s("strong",null,"根结点为第 1 层"),n("，它的子结点为 2 层，它的子结点的子结点在 3 层，以此类推")]),s("li",null,[n("结点的"),s("strong",null,"深度"),n("是从"),s("strong",null,"根结点开始"),n("自顶向下逐层累加的；结点的"),s("strong",null,"高度"),n("是从"),s("strong",null,"叶结点开始"),n("自低向上逐层累加的")]),s("li",null,[n("双亲在"),s("strong",null,"同一层的结点"),n("，也就是在同一层的结点，"),s("strong",null,"互为堂兄弟"),n("，如 G 与 E、F、H、I、J 互为堂兄弟")]),s("li",null,[s("strong",null,"树的高度或深度"),n("是树中结点"),s("strong",null,"最大的层数"),n("，如图中树的高度或深度为 4")]),s("li",null,[s("strong",null,"有序树"),n("是指树中结点的各子树"),s("strong",null,"从左到右是有次序的"),n("，"),s("strong",null,"不能互换"),n("，若可互换就称为"),s("strong",null,"无序树")]),s("li",null,[n("树中两个结点之间的"),s("strong",null,"路径"),n("是由这两个结点之间所经过的"),s("strong",null,"结点序列"),n("构成的，而"),s("strong",null,"路径长度"),n("是路径上经过的"),s("strong",null,"边的个数")]),s("li",null,[s("strong",null,"树的路径长度"),n("是从树根到每个结点的路径长度的"),s("strong",null,"总和"),n("，相同结点个数下，"),s("strong",null,"完全二叉树"),n("就是这种"),s("strong",null,"路径长度最短的二叉树")]),s("li",null,[s("strong",null,"森林"),n("是 m（"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"m"),s("mo",null,"≥"),s("mn",null,"0")]),s("annotation",{encoding:"application/x-tex"},"m\\geq0")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),s("span",{class:"mord mathnormal"},"m"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≥"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"0")])])]),n("）棵"),s("strong",null,"互不相交"),n("的"),s("strong",null,"树的集合"),n("，把树的根结点删去就成了森林，给森林加个根结点就成了树")])],-1),B=s("p",null,[n("注意：树的分支是有向的，即从双亲指向孩子，所以"),s("strong",null,"树中路径是从上向下"),n("的，"),s("u",null,"同一双亲的两个孩子之间不存在路径")],-1),I=s("h3",{id:"树的性质",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#树的性质","aria-hidden":"true"},"#"),n(" 树的性质")],-1),E=s("ol",null,[s("li",null,[s("p",null,[s("strong",null,"树中的结点数等于所有结点的度数之和加 1"),n("，因为结点的度数和等于边数和，而结点数等于边数加 1")])]),s("li",null,[s("p",null,[n("度为 m 的树中第 i 层上至多有 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"m"),s("mrow",null,[s("mi",null,"i"),s("mo",null,"−"),s("mn",null,"1")])])]),s("annotation",{encoding:"application/x-tex"},"m^{i-1}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8247em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"m"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8247em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"i"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])])])])])])])])]),n(" 个结点（"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"i"),s("mo",null,"≥"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"i\\geq 1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7955em","vertical-align":"-0.136em"}}),s("span",{class:"mord mathnormal"},"i"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≥"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n("）")])]),s("li",null,[s("p",null,[n("高度为 h 的 m 叉树至多有 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"("),s("msup",null,[s("mi",null,"m"),s("mi",null,"h")]),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mi",{mathvariant:"normal"},"/"),s("mo",{stretchy:"false"},"("),s("mi",null,"m"),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"(m^h-1)/(m-1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0991em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"m"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"h")])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")"),s("span",{class:"mord"},"/"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"m"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n(" 个结点，根据 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1"),s("mo",null,"+"),s("mi",null,"m"),s("mo",null,"+"),s("msup",null,[s("mi",null,"m"),s("mn",null,"2")]),s("mo",null,"+"),s("mo",null,"⋯"),s("mo",null,"+"),s("msup",null,[s("mi",null,"m"),s("mrow",null,[s("mi",null,"h"),s("mo",null,"−"),s("mn",null,"1")])]),s("mo",null,"="),s("mo",{stretchy:"false"},"("),s("msup",null,[s("mi",null,"m"),s("mi",null,"h")]),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mi",{mathvariant:"normal"},"/"),s("mo",{stretchy:"false"},"("),s("mi",null,"m"),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"1+m+m^2+\\cdots+m^{h-1}=(m^h-1)/(m-1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"mord mathnormal"},"m"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8974em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"m"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"minner"},"⋯"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8491em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"m"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"h"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0991em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"m"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"h")])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")"),s("span",{class:"mord"},"/"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"m"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])])])]),s("li",null,[s("p",null,[n("具有 n 个结点的 m 叉树的最小高度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"⌈"),s("msub",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("mi",null,"m")]),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},"("),s("mi",null,"m"),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mo",null,"+"),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mo",{stretchy:"false"},"⌉")]),s("annotation",{encoding:"application/x-tex"},"\\lceil\\log_m(n(m-1)+1)\\rceil")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"⌈"),s("span",{class:"mop"},[s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.0573em"}},[s("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"m")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2441em"}},[s("span")])])])])]),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"m"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")⌉")])])])]),s("p",null,[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1"),s("mo",null,"+"),s("mi",null,"m"),s("mo",null,"+"),s("mo",null,"⋯"),s("mo",null,"+"),s("msup",null,[s("mi",null,"m"),s("mrow",null,[s("mi",null,"h"),s("mo",null,"−"),s("mn",null,"2")])]),s("mo",null,"<"),s("mi",null,"n"),s("mo",null,"≤"),s("mn",null,"1"),s("mo",null,"+"),s("mi",null,"m"),s("mo",null,"+"),s("mo",null,"⋯"),s("mo",null,"+"),s("msup",null,[s("mi",null,"m"),s("mrow",null,[s("mi",null,"h"),s("mo",null,"−"),s("mn",null,"1")])])]),s("annotation",{encoding:"application/x-tex"},"1+m+\\cdots+m^{h-2}<n\\leq1+m+\\cdots+m^{h-1}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"mord mathnormal"},"m"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"minner"},"⋯"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8882em","vertical-align":"-0.0391em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"m"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"h"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"2")])])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"<"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"mord mathnormal"},"m"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"minner"},"⋯"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8491em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"m"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"h"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])])])])])])])])])]),s("p",null,[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"("),s("msup",null,[s("mi",null,"m"),s("mrow",null,[s("mi",null,"h"),s("mo",null,"−"),s("mn",null,"1")])]),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mi",{mathvariant:"normal"},"/"),s("mo",{stretchy:"false"},"("),s("mi",null,"m"),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mo",null,"<"),s("mi",null,"n"),s("mo",null,"≤"),s("mo",{stretchy:"false"},"("),s("msup",null,[s("mi",null,"m"),s("mi",null,"h")]),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mi",{mathvariant:"normal"},"/"),s("mo",{stretchy:"false"},"("),s("mi",null,"m"),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"(m^{h-1}-1)/(m-1)<n\\leq (m^h-1)/(m-1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0991em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"m"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"h"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")"),s("span",{class:"mord"},"/"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"m"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"<"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0991em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"m"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"h")])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")"),s("span",{class:"mord"},"/"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"m"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])])]),s("p",null,[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"m"),s("mrow",null,[s("mi",null,"h"),s("mo",null,"−"),s("mn",null,"1")])]),s("mo",null,"<"),s("mi",null,"n"),s("mo",{stretchy:"false"},"("),s("mi",null,"m"),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mo",null,"+"),s("mn",null,"1"),s("mo",null,"≤"),s("msup",null,[s("mi",null,"m"),s("mi",null,"h")])]),s("annotation",{encoding:"application/x-tex"},"m^{h-1}<n(m-1)+1\\leq m^h")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8882em","vertical-align":"-0.0391em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"m"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"h"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"<"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"m"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7804em","vertical-align":"-0.136em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8491em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"m"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"h")])])])])])])])])])])]),s("p",null,[n("拆开分别求解就有："),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"h"),s("mo",null,"<"),s("msub",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("mi",null,"m")]),s("mo",{stretchy:"false"},"["),s("mi",null,"n"),s("mo",{stretchy:"false"},"("),s("mi",null,"m"),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mo",null,"+"),s("mn",null,"1"),s("mo",{stretchy:"false"},"]"),s("mo",null,"+"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"h<\\log_m[n(m-1)+1]+1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7335em","vertical-align":"-0.0391em"}}),s("span",{class:"mord mathnormal"},"h"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"<"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mop"},[s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.0573em"}},[s("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"m")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2441em"}},[s("span")])])])])]),s("span",{class:"mopen"},"["),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"m"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},"]"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n("，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"h"),s("mo",null,"≥"),s("msub",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("mi",null,"m")]),s("mo",{stretchy:"false"},"["),s("mi",null,"n"),s("mo",{stretchy:"false"},"("),s("mi",null,"m"),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mo",null,"+"),s("mn",null,"1"),s("mo",{stretchy:"false"},"]")]),s("annotation",{encoding:"application/x-tex"},"h\\geq \\log_m[n(m-1)+1]")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8304em","vertical-align":"-0.136em"}}),s("span",{class:"mord mathnormal"},"h"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≥"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mop"},[s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.0573em"}},[s("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"m")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2441em"}},[s("span")])])])])]),s("span",{class:"mopen"},"["),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"m"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},"]")])])])]),s("p",null,[n("由于 h 只能是正整数，故 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"h"),s("mo",null,"="),s("mo",{stretchy:"false"},"⌈"),s("msub",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("mi",null,"m")]),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},"("),s("mi",null,"m"),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mo",null,"+"),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mo",{stretchy:"false"},"⌉")]),s("annotation",{encoding:"application/x-tex"},"h=\\lceil\\log_m(n(m-1)+1)\\rceil")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord mathnormal"},"h"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"⌈"),s("span",{class:"mop"},[s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.0573em"}},[s("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"m")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2441em"}},[s("span")])])])])]),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"m"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")⌉")])])])])]),s("li",null,[s("p",null,"具有 n 个结点，度为 m 的树，它的高度至多是 n - m + 1")]),s("li",null,[s("p",null,"度为 n、高度为 h 的树，至少有 h + n - 1 个结点")])],-1),U=a('<h2 id="二叉树的概念" tabindex="-1"><a class="header-anchor" href="#二叉树的概念" aria-hidden="true">#</a> 二叉树的概念</h2><h3 id="二叉树的定义及其主要特征" tabindex="-1"><a class="header-anchor" href="#二叉树的定义及其主要特征" aria-hidden="true">#</a> 二叉树的定义及其主要特征</h3><h4 id="二叉树的定义" tabindex="-1"><a class="header-anchor" href="#二叉树的定义" aria-hidden="true">#</a> 二叉树的定义</h4><p>二叉树是另一种树形结构，其特点是<strong>每个结点至多只有两棵子树</strong>，并且二叉树的<strong>子树有左右之分</strong>，其次序不能任意颠倒</p>',4),P=s("p",null,[n("二叉树也"),s("strong",null,"以递归的形式定义"),n("，二叉树是 n（"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n"),s("mo",null,"≥"),s("mn",null,"0")]),s("annotation",{encoding:"application/x-tex"},"n\\geq 0")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≥"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"0")])])]),n("）点的有限集合：")],-1),O=a('<ol><li>当 n = 0 时，为<strong>空二叉树</strong></li><li>当 n &gt; 0 时，由一个<strong>根结点</strong>和两个互不相交的<strong>左子树和右子树</strong>组成，左子树和右子树分别是一棵二叉树</li></ol><p>二叉树有 <strong>5 种基本形态</strong>：空二叉树、只有根结点、只有左子树、左右子树都有、只有右子树</p><p>二叉树与度为 2 的有序树的区别：</p><ol><li>度为 2 的树至少有 3 个结点，而<strong>二叉树可以为空</strong></li><li>若度为 2 的树某个<strong>结点只有一个孩子</strong>，则这个<strong>孩子无需区分左右次序</strong>，而<strong>二叉树必须区分</strong></li></ol><h4 id="几个特殊的二叉树" tabindex="-1"><a class="header-anchor" href="#几个特殊的二叉树" aria-hidden="true">#</a> 几个特殊的二叉树</h4><h5 id="满二叉树" tabindex="-1"><a class="header-anchor" href="#满二叉树" aria-hidden="true">#</a> 满二叉树</h5>',6),q=s("p",null,[s("strong",null,[n("一棵高度为 h，且含有 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mi",null,"h")]),s("mo",null,"−"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"2^h-1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9324em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"h")])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n(" 个结点的二叉树称为满二叉树")])],-1),Q=s("p",null,[n("即树中"),s("u",null,"每层都含有最多的结点"),n("，且"),s("u",null,"叶子结点都集中在最下一层"),n("，并且"),s("u",null,"除叶子结点外每个结点的度均为 2")],-1),C=s("p",null,"对满二叉树按层序编号：从根结点 1 起，自上而下，自左向右，这样每个结点都对应一个编号",-1),R=s("p",null,[n("对于编号为 i 的结点，若有双亲则为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"⌊"),s("mi",null,"i"),s("mi",{mathvariant:"normal"},"/"),s("mn",null,"2"),s("mo",{stretchy:"false"},"⌋")]),s("annotation",{encoding:"application/x-tex"},"\\lfloor i/2\\rfloor")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"⌊"),s("span",{class:"mord mathnormal"},"i"),s("span",{class:"mord"},"/2"),s("span",{class:"mclose"},"⌋")])])]),n("；若有左孩子则为 "),s("code",null,"2i"),n("；若有有孩子则为 "),s("code",null,"2i + 1")],-1),A=a('<figure><img src="'+i+'" alt="image-20210916202647863" tabindex="0" loading="lazy"><figcaption>image-20210916202647863</figcaption></figure><h5 id="完全二叉树" tabindex="-1"><a class="header-anchor" href="#完全二叉树" aria-hidden="true">#</a> 完全二叉树</h5><p>高度为 h、有 n 个结点的二叉树，当且仅当<strong>其每个结点都与高度为 h 的满二叉树种编号为 1 ~ n 的结点一一对应</strong>时，称为<strong>完全二叉树</strong></p><figure><img src="'+c+'" alt="image-20210916202710346" tabindex="0" loading="lazy"><figcaption>image-20210916202710346</figcaption></figure><p>高度为 h、有 n 个结点的完全二叉树具有以下特点：</p>',5),F=s("ol",null,[s("li",null,[n("若 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"i"),s("mo",null,"≤"),s("mo",{stretchy:"false"},"⌊"),s("mi",null,"n"),s("mi",{mathvariant:"normal"},"/"),s("mn",null,"2"),s("mo",{stretchy:"false"},"⌋")]),s("annotation",{encoding:"application/x-tex"},"i\\leq\\lfloor n/2\\rfloor")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7955em","vertical-align":"-0.136em"}}),s("span",{class:"mord mathnormal"},"i"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"⌊"),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mord"},"/2"),s("span",{class:"mclose"},"⌋")])])]),n("，则结点 i 为"),s("strong",null,"分支结点"),n("，否则为"),s("strong",null,"叶子结点")]),s("li",null,[s("strong",null,"叶子结点"),n("只可能在"),s("strong",null,"层次最大的两层"),n("上出现，对于"),s("strong",null,"最大层次中的叶子结点"),n("，都一次排序在"),s("strong",null,"该层最左边位置"),n("上")]),s("li",null,[n("若有"),s("strong",null,"度为 1 的结点"),n("，则"),s("strong",null,"只可能有一个"),n("，且该结点"),s("strong",null,"只有左孩子"),n("而无右孩子")]),s("li",null,[n("按层序编号后，一旦出现某结点为"),s("strong",null,"叶子结点或只有左孩子"),n("，则"),s("strong",null,"编号大于它"),n("的结点"),s("strong",null,"均为叶子结点")]),s("li",null,[n("若 n 为奇数，则每个分支结点都有左孩子和右孩子；若 "),s("strong",null,"n 为偶数"),n("，"),s("strong",null,"最大的分支结点只有左孩子"),n("，其余的左右都有")])],-1),K=a('<h5 id="二叉排序树" tabindex="-1"><a class="header-anchor" href="#二叉排序树" aria-hidden="true">#</a> 二叉排序树</h5><ol><li><u>左子树上所有子结点的关键字均小于根结点的关键字</u></li><li><u>右子树上的所有结点的关键字均大于根结点的关键字</u></li><li><u>左子树和右子树右各是一棵二叉排序树</u></li></ol><h5 id="平衡二叉树" tabindex="-1"><a class="header-anchor" href="#平衡二叉树" aria-hidden="true">#</a> 平衡二叉树</h5><p>平衡二叉树是一棵二叉排序树</p><p>树上任意结点的<strong>左子树和右子树的深度插不超过 1</strong></p><h4 id="二叉树的性质" tabindex="-1"><a class="header-anchor" href="#二叉树的性质" aria-hidden="true">#</a> 二叉树的性质</h4>',6),D=s("ol",null,[s("li",null,[s("p",null,[s("strong",null,[n("非空二叉树上的叶子结点树等于度为 2 的结点数加 1，即 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"n"),s("mn",null,"0")]),s("mo",null,"="),s("msub",null,[s("mi",null,"n"),s("mn",null,"2")]),s("mo",null,"+"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"n_0=n_2+1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"0")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])])])]),s("p",null,[n("结点总数："),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n"),s("mo",null,"="),s("msub",null,[s("mi",null,"n"),s("mn",null,"0")]),s("mo",null,"+"),s("msub",null,[s("mi",null,"n"),s("mn",null,"1")]),s("mo",null,"+"),s("msub",null,[s("mi",null,"n"),s("mn",null,"2")])]),s("annotation",{encoding:"application/x-tex"},"n=n_0+n_1+n_2")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"0")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),n("，分支数："),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"B"),s("mo",null,"="),s("msub",null,[s("mi",null,"n"),s("mn",null,"1")]),s("mo",null,"+"),s("mn",null,"2"),s("msub",null,[s("mi",null,"n"),s("mn",null,"2")])]),s("annotation",{encoding:"application/x-tex"},"B=n_1+2n_2")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05017em"}},"B"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7944em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),n(" 又 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n"),s("mo",null,"="),s("mi",null,"B"),s("mo",null,"+"),s("mn",null,"1"),s("mo",null,"="),s("msub",null,[s("mi",null,"n"),s("mn",null,"1")]),s("mo",null,"+"),s("mn",null,"2"),s("msub",null,[s("mi",null,"n"),s("mn",null,"2")]),s("mo",null,"+"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"n=B+1=n_1+2n_2+1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7667em","vertical-align":"-0.0833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05017em"}},"B"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7944em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])])]),s("p",null,[n("合并就解出方程 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"n"),s("mn",null,"0")]),s("mo",null,"+"),s("msub",null,[s("mi",null,"n"),s("mn",null,"1")]),s("mo",null,"+"),s("msub",null,[s("mi",null,"n"),s("mn",null,"2")]),s("mo",null,"="),s("msub",null,[s("mi",null,"n"),s("mn",null,"1")]),s("mo",null,"+"),s("mn",null,"2"),s("msub",null,[s("mi",null,"n"),s("mn",null,"2")]),s("mo",null,"+"),s("mn",null,"1"),s("mo",null,"→"),s("msub",null,[s("mi",null,"n"),s("mn",null,"0")]),s("mo",null,"="),s("msub",null,[s("mi",null,"n"),s("mn",null,"2")]),s("mo",null,"+"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"n_0+n_1+n_2=n_1+2n_2+1\\to n_0=n_2+1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"0")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7944em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"→"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"0")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])])])]),s("li",null,[s("p",null,[n("非空二叉树上第 k 层上至多有 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mrow",null,[s("mi",null,"k"),s("mo",null,"−"),s("mn",null,"1")])])]),s("annotation",{encoding:"application/x-tex"},"2^{k-1}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8491em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])])])])])])])])]),n(" 个结点（"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"k"),s("mo",null,"≥"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"k\\geq1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8304em","vertical-align":"-0.136em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≥"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n("）")])]),s("li",null,[s("p",null,[n("高度为 h 的二叉树至多有 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mi",null,"h")]),s("mo",null,"−"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"2^h-1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9324em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"h")])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n(" 个结点（"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"h"),s("mo",null,"≥"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"h\\geq1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8304em","vertical-align":"-0.136em"}}),s("span",{class:"mord mathnormal"},"h"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≥"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n("）")])]),s("li",null,[s("p",null,"对完全二叉树按从上到下、从左到右的顺序依次编号 1,2,...,n 则有以下关系："),s("ol",null,[s("li",null,[n("当 i > 1 时，结点 i 的双亲编号为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"⌊"),s("mi",null,"i"),s("mi",{mathvariant:"normal"},"/"),s("mn",null,"2"),s("mo",{stretchy:"false"},"⌋")]),s("annotation",{encoding:"application/x-tex"},"\\lfloor i/2\\rfloor")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"⌊"),s("span",{class:"mord mathnormal"},"i"),s("span",{class:"mord"},"/2"),s("span",{class:"mclose"},"⌋")])])]),n("；当 i 为偶数时，是左孩子；为奇数时，是右孩子")]),s("li",null,[n("当 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"2"),s("mi",null,"i"),s("mo",null,"≤"),s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"2i\\leq n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7955em","vertical-align":"-0.136em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mord mathnormal"},"i"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n(" 时，结点 i 的左孩子编号为 "),s("code",null,"2i"),n("，否则无左孩子")]),s("li",null,[n("当 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"2"),s("mi",null,"i"),s("mo",null,"+"),s("mn",null,"1"),s("mo",null,"≤"),s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"2i+1\\leq n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7429em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mord mathnormal"},"i"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7804em","vertical-align":"-0.136em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),n(" 时，结点 i 的右孩子编号为 "),s("code",null,"2i + 1"),n("，否则无右孩子")]),s("li",null,[s("strong",null,[n("结点 i 所在层次或深度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"⌊"),s("msub",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("mn",null,"2")]),s("mi",null,"i"),s("mo",{stretchy:"false"},"⌋"),s("mo",null,"+"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"\\lfloor\\log_2i\\rfloor+1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"⌊"),s("span",{class:"mop"},[s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.207em"}},[s("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2441em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"i"),s("span",{class:"mclose"},"⌋"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])])])])])]),s("li",null,[s("p",null,[s("strong",null,[n("具有 n 个（n > 0）结点的完全二叉树的高度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"⌈"),s("msub",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("mn",null,"2")]),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",null,"+"),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mo",{stretchy:"false"},"⌉")]),s("annotation",{encoding:"application/x-tex"},"\\lceil\\log_2(n+1)\\rceil")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"⌈"),s("span",{class:"mop"},[s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.207em"}},[s("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2441em"}},[s("span")])])])])]),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")⌉")])])]),n(" 或 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"⌊"),s("msub",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("mn",null,"2")]),s("mi",null,"n"),s("mo",{stretchy:"false"},"⌋"),s("mo",null,"+"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"\\lfloor\\log_2n\\rfloor+1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"⌊"),s("span",{class:"mop"},[s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.207em"}},[s("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2441em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},"⌋"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])])])]),s("p",null,[n("根据 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1"),s("mo",null,"+"),s("mn",null,"2"),s("mo",null,"+"),s("mo",null,"⋯"),s("mo",null,"+"),s("msup",null,[s("mn",null,"2"),s("mrow",null,[s("mi",null,"h"),s("mo",null,"−"),s("mn",null,"2")])]),s("mo",null,"<"),s("mi",null,"n"),s("mo",null,"≤"),s("mn",null,"1"),s("mo",null,"+"),s("mn",null,"2"),s("mo",null,"+"),s("mo",null,"⋯"),s("mo",null,"+"),s("msup",null,[s("mn",null,"2"),s("mrow",null,[s("mi",null,"h"),s("mo",null,"−"),s("mn",null,"1")])])]),s("annotation",{encoding:"application/x-tex"},"1+2+\\cdots+2^{h-2}<n\\leq1+2+\\cdots+2^{h-1}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"minner"},"⋯"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8882em","vertical-align":"-0.0391em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"h"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"2")])])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"<"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"minner"},"⋯"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8491em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"h"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])])])])])])])])]),n(" 推出 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"h"),s("mo",null,"="),s("mo",{stretchy:"false"},"⌈"),s("msub",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("mn",null,"2")]),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",null,"+"),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mo",{stretchy:"false"},"⌉")]),s("annotation",{encoding:"application/x-tex"},"h=\\lceil\\log_2(n+1)\\rceil")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord mathnormal"},"h"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"⌈"),s("span",{class:"mop"},[s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.207em"}},[s("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2441em"}},[s("span")])])])])]),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")⌉")])])])]),s("p",null,[n("根据 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1"),s("mo",null,"+"),s("mn",null,"2"),s("mo",null,"+"),s("mo",null,"⋯"),s("mo",null,"+"),s("msup",null,[s("mn",null,"2"),s("mrow",null,[s("mi",null,"h"),s("mo",null,"−"),s("mn",null,"2")])]),s("mo",null,"+"),s("mn",null,"1"),s("mo",null,"≤"),s("mi",null,"n"),s("mo",null,"<"),s("mn",null,"1"),s("mo",null,"+"),s("mn",null,"2"),s("mo",null,"+"),s("mo",null,"⋯"),s("mo",null,"+"),s("msup",null,[s("mn",null,"2"),s("mrow",null,[s("mi",null,"h"),s("mo",null,"−"),s("mn",null,"1")])]),s("mo",null,"+"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"1+2+\\cdots+2^{h-2}+1\\leq n< 1+2+\\cdots+2^{h-1}+1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"minner"},"⋯"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9324em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"h"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"2")])])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7804em","vertical-align":"-0.136em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5782em","vertical-align":"-0.0391em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"<"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"minner"},"⋯"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9324em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"h"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n(" 推出 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"h"),s("mo",null,"="),s("mo",{stretchy:"false"},"⌊"),s("msub",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("mn",null,"2")]),s("mi",null,"n"),s("mo",{stretchy:"false"},"⌋"),s("mo",null,"+"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"h=\\lfloor\\log_2n\\rfloor+1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord mathnormal"},"h"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"⌊"),s("span",{class:"mop"},[s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.207em"}},[s("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2441em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},"⌋"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])])]),s("p",null,[n("具体的推导方法与 "),s("a",{href:"#%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"},"树的性质"),n(" 类似")])])],-1),j=a('<h3 id="二叉树的存储结构" tabindex="-1"><a class="header-anchor" href="#二叉树的存储结构" aria-hidden="true">#</a> 二叉树的存储结构</h3><h4 id="顺序存储结构" tabindex="-1"><a class="header-anchor" href="#顺序存储结构" aria-hidden="true">#</a> 顺序存储结构</h4><p>二叉树的顺序存储是指<strong>用一组的地址连续的存储单元</strong>依次自上而下、自左至右<strong>存储完全二叉树上的结点元素</strong></p><p>将完全二叉树上<strong>编号为 i 的结点</strong>元素存储在一维数组<strong>下标为 i - 1 的分量</strong>中</p><p>根据二叉树的性质，<strong>完全二叉树和满二叉树采用顺序存储比较合适</strong>，它们可以<strong>最大可能地节省存储空间</strong>，又方便从数组中<strong>查找结点</strong>，以及<strong>结点之间的关系</strong></p><p>对于<strong>一般的二叉树</strong>，为了让数组反应结点之间的关系，只能<strong>添加空结点</strong>，让它在数组中看似完全二叉树</p>',6),X=s("p",null,[n("但这样的话会出现浪费空间的情况，最坏情况下一个高度为 h 且只有 h 结点的单支树需要 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mi",null,"h")]),s("mo",null,"−"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"2^h-1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9324em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"h")])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n(" 个存储单元")],-1),Z=a('<figure><img src="'+o+`" alt="image-20210916221701804" tabindex="0" loading="lazy"><figcaption>image-20210916221701804</figcaption></figure><p>注意：<strong>数组是从 0 开始</strong>的，所以<strong>不能直接使用性质 4</strong>，需要一些变通</p><h4 id="链式存储结构" tabindex="-1"><a class="header-anchor" href="#链式存储结构" aria-hidden="true">#</a> 链式存储结构</h4><p>为了解决顺序存储的空间浪费问题，所以二叉树一般都采用<strong>链式存储结构</strong>，<strong>用链表结点来存储二叉树中的每个结点</strong></p><p>二叉链表<strong>至少</strong>包含 3 个域：<strong>数据域、左指针域、右指针域</strong></p><p>在实际的不同应用中，还可以增加某些指针域，如增加指向父结点的指针</p><p>二叉树的链式存储结构描述如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span> <span class="token punctuation">{</span>
    ElemType data<span class="token punctuation">;</span>  <span class="token comment">// 数据域</span>
    <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>  <span class="token comment">// 左右孩子指针</span>
<span class="token punctuation">}</span> BiTNode<span class="token punctuation">,</span> <span class="token operator">*</span>BiTree<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用不同存储结构时，实现二叉树操作的算法也会不同，依次要根据实际应用场合来选择合适的存储结构</p><p>在含有 <strong>n 个结点的二叉链表中</strong>，含有 <strong>n + 1 个空链域</strong></p><figure><img src="`+r+'" alt="image-20210916225214560" tabindex="0" loading="lazy"><figcaption>image-20210916225214560</figcaption></figure><h3 id="精选试题" tabindex="-1"><a class="header-anchor" href="#精选试题" aria-hidden="true">#</a> 精选试题</h3>',12),Y=s("ol",null,[s("li",null,[s("p",null,[n("设二叉树有 "),s("code",null,"2n"),n(" 个结点，且 0 < m < n，则不可能存在 "),s("code",null,"2m"),n(" 个度为 1 的结点")]),s("p",null,[n("因为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"2"),s("mi",null,"n"),s("mo",null,"="),s("msub",null,[s("mi",null,"n"),s("mn",null,"0")]),s("mo",null,"+"),s("msub",null,[s("mi",null,"n"),s("mn",null,"1")]),s("mo",null,"+"),s("msub",null,[s("mi",null,"n"),s("mn",null,"2")]),s("mo",null,"="),s("msub",null,[s("mi",null,"n"),s("mn",null,"1")]),s("mo",null,"+"),s("mn",null,"2"),s("msub",null,[s("mi",null,"n"),s("mn",null,"2")]),s("mo",null,"+"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"2n=n_0+n_1+n_2=n_1+2n_2+1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"0")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7944em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n(" 由于 "),s("code",null,"2n"),n(" 是偶数，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"2"),s("msub",null,[s("mi",null,"n"),s("mn",null,"2")])]),s("annotation",{encoding:"application/x-tex"},"2n_2")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7944em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),n(" 是偶数，所以 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"n"),s("mn",null,"1")])]),s("annotation",{encoding:"application/x-tex"},"n_1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),n(" 必定是奇数")])]),s("li",null,[s("p",null,[n("若一个完全二叉树的第 h 层有 k 个叶结点，则该完全二叉树的结点个数最多为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mi",null,"h")]),s("mo",null,"−"),s("mn",null,"1"),s("mo",null,"+"),s("mo",{stretchy:"false"},"("),s("msup",null,[s("mn",null,"2"),s("mrow",null,[s("mi",null,"h"),s("mo",null,"−"),s("mn",null,"1")])]),s("mo",null,"−"),s("mi",null,"k"),s("mo",{stretchy:"false"},")"),s("mo",null,"∗"),s("mn",null,"2")]),s("annotation",{encoding:"application/x-tex"},"2^{h}-1+(2^{h-1}-k)*2")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9324em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"h")])])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0991em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"h"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"∗"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"2")])])])]),s("p",null,"当 h 和 h + 1 层有叶结点时结点数最大，逻辑是计算 1 ~ h 层的结点加上 h + 1 层的结点"),s("p",null,[n("1 ~ h 层结点个数是 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mi",null,"h")]),s("mo",null,"−"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"2^h-1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9324em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"h")])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n(" 而 h + 1 层结点个数是 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"("),s("msup",null,[s("mn",null,"2"),s("mrow",null,[s("mi",null,"h"),s("mo",null,"−"),s("mn",null,"1")])]),s("mo",null,"−"),s("mi",null,"k"),s("mo",{stretchy:"false"},")"),s("mo",null,"∗"),s("mn",null,"2")]),s("annotation",{encoding:"application/x-tex"},"(2^{h-1}-k)*2")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0991em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"h"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"∗"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"2")])])])])]),s("li",null,[s("p",null,[n("若一棵深度为 h 的完全二叉树的第 h 层有 k 个叶子结点，则该二叉树共有 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"k"),s("mo",null,"+"),s("msup",null,[s("mn",null,"2"),s("mrow",null,[s("mi",null,"h"),s("mo",null,"−"),s("mn",null,"2")])]),s("mo",null,"−"),s("mo",{stretchy:"false"},"⌈"),s("mi",null,"k"),s("mi",{mathvariant:"normal"},"/"),s("mn",null,"2"),s("mo",{stretchy:"false"},"⌉")]),s("annotation",{encoding:"application/x-tex"},"k+2^{h-2}-\\lceil k/2\\rceil")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7778em","vertical-align":"-0.0833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9324em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"h"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"2")])])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"⌈"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mord"},"/2"),s("span",{class:"mclose"},"⌉")])])])]),s("p",null,"思路是第 h 层的叶子结点加上 h - 1 层的叶子结点")]),s("li",null,[s("p",null,[n("若一棵完全二叉树有 i 个结点，则该二叉树中叶子结点的个数是 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"i"),s("mo",null,"−"),s("mo",{stretchy:"false"},"⌊"),s("mi",null,"i"),s("mi",{mathvariant:"normal"},"/"),s("mn",null,"2"),s("mo",{stretchy:"false"},"⌋")]),s("annotation",{encoding:"application/x-tex"},"i - \\lfloor i / 2\\rfloor")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7429em","vertical-align":"-0.0833em"}}),s("span",{class:"mord mathnormal"},"i"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"⌊"),s("span",{class:"mord mathnormal"},"i"),s("span",{class:"mord"},"/2"),s("span",{class:"mclose"},"⌋")])])])]),s("p",null,[n("思路是利用完全二叉树的特性，最后一个分支的序号是 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"⌊"),s("mi",null,"i"),s("mi",{mathvariant:"normal"},"/"),s("mn",null,"2"),s("mo",{stretchy:"false"},"⌋")]),s("annotation",{encoding:"application/x-tex"},"\\lfloor i / 2\\rfloor")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"⌊"),s("span",{class:"mord mathnormal"},"i"),s("span",{class:"mord"},"/2"),s("span",{class:"mclose"},"⌋")])])])])]),s("li",null,[s("p",null,[n("一棵有 n 个叶子结点的完全二叉树，最多有 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"h"),s("mo",null,"="),s("mo",{stretchy:"false"},"⌈"),s("msub",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("mn",null,"2")]),s("mi",null,"n"),s("mo",{stretchy:"false"},"⌉"),s("mo",{separator:"true"},";"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",null,"−"),s("msup",null,[s("mn",null,"2"),s("mrow",null,[s("mi",null,"h"),s("mo",null,"−"),s("mn",null,"1")])]),s("mo",{stretchy:"false"},")"),s("mo",null,"∗"),s("mn",null,"2"),s("mo",null,"+"),s("msup",null,[s("mn",null,"2"),s("mi",null,"h")])]),s("annotation",{encoding:"application/x-tex"},"h=\\lceil \\log_2n\\rceil;(n-2^{h-1})*2+2^h")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord mathnormal"},"h"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"⌈"),s("span",{class:"mop"},[s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.207em"}},[s("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2441em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},"⌉"),s("span",{class:"mpunct"},";"),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0991em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"h"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])])])])])]),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"∗"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8491em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"h")])])])])])])])])])])]),s("p",null,"拿到二叉树的高，使用 1 ~ h - 1 的结点加上 h 层的叶子结点")])],-1),W=s("p",null,[s("strong",null,"做题思路：")],-1),G=s("ul",null,[s("li",null,[n("可以利用 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n"),s("mo",null,"="),s("msub",null,[s("mi",null,"n"),s("mn",null,"0")]),s("mo",null,"+"),s("msub",null,[s("mi",null,"n"),s("mn",null,"1")]),s("mo",null,"+"),s("msub",null,[s("mi",null,"n"),s("mn",null,"2")])]),s("annotation",{encoding:"application/x-tex"},"n=n_0+n_1+n_2")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"0")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),n("，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"n"),s("mn",null,"0")]),s("mo",null,"="),s("msub",null,[s("mi",null,"n"),s("mn",null,"2")]),s("mo",null,"+"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"n_0=n_2+1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"0")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n("，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n"),s("mo",null,"="),s("msub",null,[s("mi",null,"n"),s("mn",null,"1")]),s("mo",null,"+"),s("mn",null,"2"),s("msub",null,[s("mi",null,"n"),s("mn",null,"2")])]),s("annotation",{encoding:"application/x-tex"},"n=n_1+2n_2")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7333em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7944em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),n(" 这三条公式")]),s("li",null,[n("可以利用完全二叉树的性质，如高为 h，它的 h - 1 层的结点有 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mrow",null,[s("mi",null,"h"),s("mo",null,"−"),s("mn",null,"2")])])]),s("annotation",{encoding:"application/x-tex"},"2^{h-2}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8491em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"h"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"2")])])])])])])])])])])]),n("，1 ~ h - 1 的结点有 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mrow",null,[s("mi",null,"h"),s("mo",null,"−"),s("mn",null,"1")])]),s("mo",null,"−"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"2^{h-1}-1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9324em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"h"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])])]),s("li",null,"可以直接在脑袋里面画出二叉树，用空间思维硬刚")],-1),J=a(`<h2 id="二叉树的遍历和线索二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树的遍历和线索二叉树" aria-hidden="true">#</a> 二叉树的遍历和线索二叉树</h2><h3 id="二叉树的遍历" tabindex="-1"><a class="header-anchor" href="#二叉树的遍历" aria-hidden="true">#</a> 二叉树的遍历</h3><p>二叉树的遍历是指按某条搜索路径<strong>访问树中每个结点</strong>，，使得<strong>每个结点均被访问一次</strong>，而且<strong>仅被访问一次</strong></p><p>按照<strong>先遍历左子树再遍历右子树</strong>的原则，常见的遍历次序有：<strong>先序遍历、中序遍历、后续遍历</strong>，其中序是指根结点何时访问</p><h4 id="先序遍历" tabindex="-1"><a class="header-anchor" href="#先序遍历" aria-hidden="true">#</a> 先序遍历</h4><p>先序遍历（<code>PreOrder</code>）的操作过程如下：</p><p>若二叉树为空，则什么都不做；否则（<code>NLR</code>）：</p><ol><li>访问根结点</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ol><p>对于的递归算法代码如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>
    <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 访问根结点</span>
    <span class="token function">PreOrder</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 递归遍历左子树</span>
    <span class="token function">PreOrder</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 递归遍历右子树</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="中序遍历" tabindex="-1"><a class="header-anchor" href="#中序遍历" aria-hidden="true">#</a> 中序遍历</h4><p>中序遍历（<code>InOrder</code>）操作和先序遍历差不多，只是把访问根结点调整到第二步，先左再自己再右（<code>LNR</code>）</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>
    <span class="token function">InOrder</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">InOrder</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="后序遍历" tabindex="-1"><a class="header-anchor" href="#后序遍历" aria-hidden="true">#</a> 后序遍历</h4><p>后序遍历（<code>PostOrder</code>）操作和先序遍历差不多，只是把访问根结点调整到第三步，先左右再自己（<code>LRN</code>）</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>
    <span class="token function">PostOrder</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PostOrder</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个结点都访问一次且访问一次，故<strong>时间复杂度是 O(n)</strong></p><p>递归遍历中，最坏情况下有 n 个结点的二叉树是深度为 n 的单支树，<strong>空间复杂度为 O(n)</strong></p><p>当栈出一个结点 p 后，<strong>栈内的元素是 p 的全部祖先</strong>，从<strong>栈低到栈顶加上 p 是根结点到 p 的路径</strong></p><p>很多算法设计中都可以利用这一思路求解，如<strong>求根到某结点的路径</strong>、<strong>求两结点的最近公共祖先</strong>等</p><hr><p><strong>注意：考研很多题是基于这三个遍历模板延申出来的，要对它有很好的领会</strong></p><h4 id="递归算法和非递归算法的转换" tabindex="-1"><a class="header-anchor" href="#递归算法和非递归算法的转换" aria-hidden="true">#</a> 递归算法和非递归算法的转换</h4><h5 id="栈实现中序遍历" tabindex="-1"><a class="header-anchor" href="#栈实现中序遍历" aria-hidden="true">#</a> 栈实现中序遍历</h5><p><strong>使用栈实现中序遍历</strong>，考虑到<strong>中序遍历就是左中右遍历</strong>（对每个结点都进行左中右），就可以得到下面思路：</p><ol><li>拿到该结点最左子树，因为中序遍历第一步是做左操作，左又做左操作，所以就拿最左结点</li><li>因为是最左子树根据左中右原则，左没有了，自己就是中，先访问自己，然后把右子树做 1 操作</li><li>到了这里左右子树都没有了，考虑到父结点是做左操作到自己的，这时应该轮到父结点做中操作了，访问父结点，然后父结点做右操作，对父结点的右子树做 1 操作</li></ol><p>根据思路可以得到操作：</p><ol><li>如果当前结点不为空，把当前结点和一路左边结点压入栈；相当于第一步，使用栈是为了可以拿到父结点</li><li>弹栈访问，并对结点的右子树执行操作 1；这里就相当于把上面思路的 2，3 步合在一起</li></ol><p>原理讲完了下面是实现代码：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    LiStack S<span class="token punctuation">;</span>
    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    BiTree p <span class="token operator">=</span> T<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 第 1 步把左一路的压入栈</span>
            <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第 2 步访问自己，然后对右子树执行 1</span>
            p <span class="token operator">=</span> p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="栈实现前序遍历" tabindex="-1"><a class="header-anchor" href="#栈实现前序遍历" aria-hidden="true">#</a> 栈实现前序遍历</h5><p>使用栈实现前序遍历的思考和中序遍历差不多，区别在于<strong>前序遍历的逻辑是中左右</strong></p><p>前序遍历的结点使用顺序和前序一样，就是访问的位置不一样，只需要调整一下就可以了</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    LiStack S<span class="token punctuation">;</span>
    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    BiTree p <span class="token operator">=</span> T<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 把访问调整为前序遍历的先访问</span>
            <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="栈实现后序遍历" tabindex="-1"><a class="header-anchor" href="#栈实现后序遍历" aria-hidden="true">#</a> 栈实现后序遍历</h5><p>使用栈实现后序遍历思考也差不多，<strong>后序遍历的核心逻辑是左右中</strong>，但操作变得不一样了：</p><ol><li>首先和中序一样，先拿到最左的结点</li><li>然后直接对右子树做操作 1，因为左右中，现在进行右操作</li><li>到了这里左右操作都做完了，现在就可以做中操作，对结点进行访问了</li></ol><p>但在代码里面，<u>无法知道右操作是否有做，所以要做个判断</u>，判断不过就要乖乖做右操作：</p><ul><li>如果没有右子树，就相当于光速做了右操作，就可以中操作了</li><li>如果上一个做中的结点是右子树结点，那么就是以前做了右操作，可以做中操作</li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    LiStack S<span class="token punctuation">;</span>
    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    BiTree p <span class="token operator">=</span> T<span class="token punctuation">;</span>
    BiTNode <span class="token operator">*</span>r <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 做第一步操作，左边直入栈</span>
            <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token function">GetTop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// p 是 r 的父结点</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> rchild <span class="token operator">&amp;&amp;</span> p <span class="token operator">-&gt;</span> rchild <span class="token operator">!=</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 判断不过做第二步操作</span>
                p <span class="token operator">=</span> p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment">// 判断过了做第三步操作</span>
                <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
                r <span class="token operator">=</span> p<span class="token punctuation">;</span>
                p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">// 重置 p 指针省的第一步操作了</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="层次遍历" tabindex="-1"><a class="header-anchor" href="#层次遍历" aria-hidden="true">#</a> 层次遍历</h4><p>层次遍历是<strong>指按树的层从左到右访问结点</strong>，进行层次遍历要借助一个队列：</p><ol><li>初始化把根结点入队</li><li>队列不空，从队列取出一个元素，并访问它</li><li>有左子树把左子树入队</li><li>有右子树把右子树入队，回第二步</li></ol><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">LevelOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    LinkQueue Q<span class="token punctuation">;</span>
    <span class="token function">InitQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    BiTree p<span class="token punctuation">;</span>
    <span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第一步，根结点入队</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QueueEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">DeQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第二步，出列并访问</span>
        <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> lchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 第三步</span>
            <span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> rchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 第四步</span>
            <span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：这些代码作为一个模板需要达到<u>熟练手写的程度</u>，这样才能将层次遍历模板应用于各种题目之中</strong></p><h4 id="由遍历序列构造二叉树" tabindex="-1"><a class="header-anchor" href="#由遍历序列构造二叉树" aria-hidden="true">#</a> 由遍历序列构造二叉树</h4><p>由二叉树的<strong>先序序列</strong>和<strong>中序序列</strong>可以<strong>唯一地确定一棵二叉树</strong>：</p><ol><li><strong>先序序列的第一个是二叉树的根结点</strong>；拿它去中序序列可以把中序序列分成两半，变成左子树的中序和右子树的中序</li><li>然后在先序序列中找到对应的左子序列和右子序列</li><li>在先序序列中，左子序列的第一位就是左子树的根部；右子序列的第一位就是右子序列的根部</li><li>依次递归下去，就能找到唯一的二叉树了</li></ol><p>例子：求先序序列（<code>ABCDEFGHI</code>）和中序序列（<code>BCAEDGHFI</code>）所确定的二叉树</p><figure><img src="`+m+'" alt="image-20210917202041035" tabindex="0" loading="lazy"><figcaption>image-20210917202041035</figcaption></figure><p>同理，也可以求<strong>后序序列和中序序列</strong>的二叉树，<strong>后序序列的最后一个结点就是根结点</strong></p><p>同理，也可以求<strong>层序序列和中序序列</strong>的二叉树，第一个为根结点，若中序左右子树都有，第二个是左子树根结点，以此类推</p><p>注意：只知道二叉树的<strong>先序序列和后序序列</strong>，是<strong>无法确定唯一的二叉树</strong>的</p><h5 id="选择题得到的理论" tabindex="-1"><a class="header-anchor" href="#选择题得到的理论" aria-hidden="true">#</a> 选择题得到的理论</h5>',54),H=s("ul",null,[s("li",null,[s("p",null,[n("如果"),s("strong",null,"前序序列是后序序列的反转"),n("设长度为 n，那么一共"),s("strong",null,[n("可以构成 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mrow",null,[s("mi",null,"n"),s("mo",null,"−"),s("mn",null,"1")])])]),s("annotation",{encoding:"application/x-tex"},"2^{n-1}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8141em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"n"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])])])])])])])])]),n(" 棵二叉树")]),n("，因为它们"),s("strong",null,"只会有一个叶结点")])]),s("li",null,[s("p",null,[n("当两个结点的"),s("strong",null,[n("前序序列为 "),s("code",null,"XY")]),n("、"),s("strong",null,[n("后序序列为 "),s("code",null,"YX")]),n(" 时，则 "),s("strong",null,"X 为 Y 的祖先"),n("，"),s("code",null,"XZY"),n(" 这时不能确定 X 和 Y 的关系")])]),s("li",null,[s("p",null,[n("先序序列为 1...n 的"),s("strong",null,"不同二叉树的个数"),n("是其"),s("strong",null,"出栈元素不同排列的个数"),n(),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mstyle",{displaystyle:"true",scriptlevel:"0"},[s("mfrac",null,[s("mn",null,"1"),s("mrow",null,[s("mi",null,"n"),s("mo",null,"+"),s("mn",null,"1")])])]),s("msubsup",null,[s("mi",null,"C"),s("mrow",null,[s("mn",null,"2"),s("mi",null,"n")]),s("mi",null,"n")])]),s("annotation",{encoding:"application/x-tex"},"\\dfrac{1}{n+1}C^{n}_{2n}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"2.0908em","vertical-align":"-0.7693em"}}),s("span",{class:"mord"},[s("span",{class:"mopen nulldelimiter"}),s("span",{class:"mfrac"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.3214em"}},[s("span",{style:{top:"-2.314em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord"},"1")])]),s("span",{style:{top:"-3.23em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"frac-line",style:{"border-bottom-width":"0.04em"}})]),s("span",{style:{top:"-3.677em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.7693em"}},[s("span")])])])]),s("span",{class:"mclose nulldelimiter"})]),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"C"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6644em"}},[s("span",{style:{top:"-2.4519em","margin-left":"-0.0715em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"2"),s("span",{class:"mord mathnormal mtight"},"n")])])]),s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"n")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2481em"}},[s("span")])])])])])])])])]),s("p",null,"先序序列输出的是入栈的元素，而中序序列输出的是出栈的元素"),s("p",null,"而先序和中序能确定一棵树，也就是有多少种中序就有多少棵树，也就是栈的出栈序列的个数"),s("p",null,"如何保证先序序列和中序序列真的能构成一棵树？"),s("p",null,"根据前序和后序思想，要进左子树必须先进其父结点，要进右子树必须前出其父结点，就有对于一个结点："),s("ul",null,[s("li",null,"当它在栈中时，往后入栈的元素都是它的左子树"),s("li",null,"出栈之后，往后入栈的元素都是它的右子树")]),s("p",null,"所以出栈的前后只会影响左右性，不会对是否构成一棵树构成影响")])],-1),V=a(`<h5 id="先中序列形成二叉树代码" tabindex="-1"><a class="header-anchor" href="#先中序列形成二叉树代码" aria-hidden="true">#</a> 先中序列形成二叉树代码</h5><p>思路：</p><ol><li>根据先序序列第一位确定树的根结点</li><li>根据根结点在中序序列中划分出二叉树的左右子树包含那些结点</li><li>根据左右子树结点在先序序列中的次序确定子树的根结点，即递归回步骤 1</li></ol><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/**
 * A: 前序序列
 * B: 中序序列
 * l1: A 的第一个结点的下标
 * h1: A 的最后一个结点的下标
 * l2: B 的第一个结点的下标
 * h2: B 的最后一个结点的下标
 */</span>
BiTree <span class="token function">PreInCreat</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ElemType B<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l1<span class="token punctuation">,</span> <span class="token keyword">int</span> h1<span class="token punctuation">,</span> <span class="token keyword">int</span> l2<span class="token punctuation">,</span> <span class="token keyword">int</span> h2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> llen<span class="token punctuation">,</span> rlen<span class="token punctuation">;</span>
    root <span class="token operator">=</span> <span class="token punctuation">(</span>BiTNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 建立根结点</span>
    root <span class="token operator">-&gt;</span> data <span class="token operator">=</span> A<span class="token punctuation">[</span>l1<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> l2<span class="token punctuation">;</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> root <span class="token operator">-&gt;</span> data<span class="token punctuation">;</span>  i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 在中序找出该结点的位置</span>
    llen <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">12</span><span class="token punctuation">;</span>  <span class="token comment">// 左子树序列的长度</span>
    rlen <span class="token operator">=</span> h2 <span class="token operator">-</span> i<span class="token punctuation">;</span>  <span class="token comment">// 右子树序列的长度</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>llen<span class="token punctuation">)</span>  <span class="token comment">// 如果左子树序列不为空，递归建立；否则设左子树为空</span>
        root <span class="token operator">-&gt;</span> lchild <span class="token operator">=</span> <span class="token function">PreInCreat</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> l1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> l1 <span class="token operator">+</span> llen<span class="token punctuation">,</span> l2<span class="token punctuation">,</span> l2 <span class="token operator">+</span> llen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        root <span class="token operator">-&gt;</span> lchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rlen<span class="token punctuation">)</span>
        root <span class="token operator">-&gt;</span> rchild <span class="token operator">=</span> <span class="token function">PreInCreat</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> h1 <span class="token operator">-</span> rlen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> h1<span class="token punctuation">,</span> h2 <span class="token operator">-</span> rlen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> h2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        root <span class="token operator">-&gt;</span> rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>  <span class="token comment">// 返回局部二叉树的根结点</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="线索二叉树" tabindex="-1"><a class="header-anchor" href="#线索二叉树" aria-hidden="true">#</a> 线索二叉树</h3><h4 id="线索二叉树的基本概念" tabindex="-1"><a class="header-anchor" href="#线索二叉树的基本概念" aria-hidden="true">#</a> 线索二叉树的基本概念</h4><p>线索二叉树就是把二叉表的 n + 1 个<strong>空指针利用起来</strong>，分别<strong>指向前驱和后继</strong></p><p>规定：若<strong>无左子树</strong>，令 <strong><code>lchild</code> 指向其前序结点</strong>；若<strong>无右子树</strong>，令 <strong><code>rchild</code> 指向其后继结点</strong>；此外还增加两个<u>标志域来表示指针域指向的是孩子还是前序或后继</u></p><p>引用线索二叉树是为了<strong>加快查找结点前驱和后继的速度</strong>，线索二叉树是一种<strong>物理结构</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ThreadNode</span><span class="token punctuation">{</span>
    ElemType data<span class="token punctuation">;</span>  <span class="token comment">// 数据域</span>
    <span class="token keyword">struct</span> <span class="token class-name">ThreadNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>  <span class="token comment">// 左右孩子指针</span>
    <span class="token keyword">int</span> ltag<span class="token punctuation">,</span> rtag<span class="token punctuation">;</span>  <span class="token comment">// 左右线索标志</span>
<span class="token punctuation">}</span>ThreadNode<span class="token punctuation">,</span> <span class="token operator">*</span>ThreadTree<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ltag</code> 为 1 时指向<strong>前驱</strong>，为 0 时指向<strong>左孩子</strong>；<code>rtag</code> 为 1 时指向<strong>后继</strong>，为 0 时指向<strong>右孩子</strong></p><p>以这种结构构成的二叉链表来存储二叉树叫做<strong>线索链表</strong>，其中<strong>指向前驱和后继的指针叫做线索</strong>，<strong>加上线索的二叉树称为线索二叉树</strong></p><h4 id="中序线索二叉树的构造" tabindex="-1"><a class="header-anchor" href="#中序线索二叉树的构造" aria-hidden="true">#</a> 中序线索二叉树的构造</h4><p><strong>二叉树的线索化</strong>是将二叉链表中的<strong>空指针改为指向前驱或后继的线索</strong>，通过遍历一次二叉树来实现</p><p><strong>中序线索二叉树的前驱</strong>就是<strong>中序遍历时结点的前驱</strong>，前序、后序线索二叉树类似</p><p>附设 <code>pre</code> 指针指向前驱结点（刚刚访问的结点），指针 p 是正在访问的结点，在中序遍历中，调整它们的关系，代码如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 中序遍历线索化二叉树，</span>
<span class="token keyword">void</span> <span class="token function">InThread</span><span class="token punctuation">(</span>ThreadTree <span class="token operator">&amp;</span>p<span class="token punctuation">,</span> ThreadTree <span class="token operator">&amp;</span>pre<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">InThread</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">,</span> pre<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 线索化左边的二叉树</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> lchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 当前结点左子树为空，指向前驱</span>
            p <span class="token operator">-&gt;</span> lchild <span class="token operator">=</span> pre<span class="token punctuation">;</span>
            p <span class="token operator">-&gt;</span> ltag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> pre <span class="token operator">-&gt;</span> rchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 前驱的右子树为空，指向后继</span>
            pre <span class="token operator">-&gt;</span> rchild <span class="token operator">=</span> p<span class="token punctuation">;</span>
            pre <span class="token operator">-&gt;</span> rtag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>  <span class="token comment">// 更新前驱，注意这个是引用类型</span>
        <span class="token function">InThread</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">,</span> pre<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 线索化右边的二叉树</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// 建立中序线索化二叉树</span>
<span class="token keyword">void</span> <span class="token function">CreatInThread</span><span class="token punctuation">(</span>ThreadTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    ThreadTree pre <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">InThread</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> pre<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 线索化</span>
        pre <span class="token operator">-&gt;</span> rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">// 处理遍历的最后一个结点</span>
        pre <span class="token operator">-&gt;</span> rtag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>二叉树的线索链表上<strong>添加一个头结点</strong>，令其 <strong><code>lchild</code> 指向二叉树的根结点</strong>，<strong><code>rchild</code> 指向中序遍历的最后一个结点</strong></p><p>令<strong>中序遍历</strong>的<strong>第一个结点的 <code>lchild</code></strong> 和<strong>最后一个结点的 <code>rchild</code></strong> 均<strong>指向头结点</strong></p><p>这就好比为二叉树建立了一个双向线索链表，<strong>方便</strong>从前往后或从后往前<strong>对线索二叉树进行遍历</strong></p><figure><img src="`+u+`" alt="image-20210917230116841" tabindex="0" loading="lazy"><figcaption>image-20210917230116841</figcaption></figure><h4 id="中序线索二叉树的遍历" tabindex="-1"><a class="header-anchor" href="#中序线索二叉树的遍历" aria-hidden="true">#</a> 中序线索二叉树的遍历</h4><p>线索二叉树的结点中隐含了线索二叉树的前驱与后继的信息</p><p>遍历时只要<strong>找到序列中的第一个结点</strong>，然后<strong>依次找结点的后继</strong>，<strong>直至后继为空</strong></p><p>当右标志为 1 时，<strong>后继为右线索</strong>；当右标志为 0 时，<strong>后继为右子树的最左子树</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 找中序线索二叉树中中序序列下的第一个结点</span>
ThreadNode <span class="token operator">*</span><span class="token function">Firstnode</span><span class="token punctuation">(</span>ThreadNode <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> ltag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> p <span class="token operator">=</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span> <span class="token comment">// 最左下结点（不一定是叶结点）</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// 找中序线索二叉树中结点 p 在中序序列下的后继</span>
ThreadNode <span class="token operator">*</span><span class="token function">Nextnode</span><span class="token punctuation">(</span>ThreadNode <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> rtag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">Firstnode</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>  <span class="token comment">// rtag == 1直接返回后继线索</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// 遍历线索二叉树</span>
<span class="token keyword">void</span> <span class="token function">Inorder</span><span class="token punctuation">(</span>ThreadNode <span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>ThreadNode <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">Firstnode</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> p <span class="token operator">=</span> <span class="token function">Nextnode</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="先序和后序线索二叉树" tabindex="-1"><a class="header-anchor" href="#先序和后序线索二叉树" aria-hidden="true">#</a> 先序和后序线索二叉树</h4><p>先序线索二叉树和后序线索二叉树的代码类似，只需变动<strong>线索化的代码</strong>与<strong>线索化左右子树递归</strong>的<strong>位置</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 先序线索化</span>
<span class="token keyword">void</span> <span class="token function">PreThread</span><span class="token punctuation">(</span>ThreadTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>  <span class="token comment">// 线索化，与中序先序化一样</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> ltag <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">// 因为上面进行了线索化，所以需要判断一下</span>
            <span class="token function">PreThread</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> rtag <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">// 避免回溯回来造成死循环，当父结点的后继是自己时，只有一个左结点时</span>
            <span class="token function">PreThread</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 后序线索化，与中序先序化一样</span>
<span class="token keyword">void</span> <span class="token function">PostThread</span><span class="token punctuation">(</span>ThreadTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">PostThread</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PostThread</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>  <span class="token comment">// 线索化</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先序线索二叉树中找后继结点：</p><ul><li>如果有左孩子，则其就是后继</li><li>如果只有右孩子，则其就是后继</li><li>如果为叶结点，右索引指向的就是后继</li></ul><p>后序线索二叉树中找后继结点：</p><ul><li>如果是二叉树的根，则没有后继</li><li>如果是双亲的左孩子，且双亲有右孩子，后继为双亲的右孩子按后序遍历列出的第一个结点</li><li>如果是双亲的右孩子，或是左孩子且没有右孩子，后继为双亲</li></ul><p>后序线索二叉树在找后继的时候<strong>需要知道双亲</strong>，所以在<strong>遍历的时候仍需要栈支持</strong>，或者<strong>采用带标志域的三叉链</strong>作为存储结构，<u>先序线索二叉树找其前驱时也不能直接找到</u></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 先序线索二叉树的后继</span>
ThreadNode <span class="token operator">*</span><span class="token function">Nextnode</span><span class="token punctuation">(</span>ThreadNode<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> rtag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> lchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>  <span class="token comment">// 有左孩子</span>
        <span class="token keyword">return</span> p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>  <span class="token comment">// 只有右孩子</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>  <span class="token comment">// 叶结点返回线索</span>
<span class="token punctuation">}</span>


<span class="token comment">// 遍历先序线索二叉树</span>
<span class="token keyword">void</span> <span class="token function">Preorder</span><span class="token punctuation">(</span>ThreadTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>ThreadNode <span class="token operator">*</span>p <span class="token operator">=</span> T<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> p <span class="token operator">=</span> <span class="token function">Nextnode</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 后序线索二叉树的前序</span>
ThreadNode <span class="token operator">*</span><span class="token function">Prenode</span><span class="token punctuation">(</span>ThreadNode<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 后序线索二叉树的前驱刚好就是先序线索二叉树的后继的反转</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> ltag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> rchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>
        <span class="token keyword">return</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 逆向遍历线索二叉树</span>
<span class="token keyword">void</span> <span class="token function">RevPostorder</span><span class="token punctuation">(</span>ThreadTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 如果想要正向遍历可以使用栈来辅助</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>ThreadNode <span class="token operator">*</span>p <span class="token operator">=</span> T<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> p <span class="token operator">=</span> <span class="token function">Prenode</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="综合应用题" tabindex="-1"><a class="header-anchor" href="#综合应用题" aria-hidden="true">#</a> 综合应用题</h3><h4 id="非递归求二叉树高度" tabindex="-1"><a class="header-anchor" href="#非递归求二叉树高度" aria-hidden="true">#</a> 非递归求二叉树高度</h4><p>问题：假设二叉树采用二叉链表存储，设计一个非递归算法求二叉树的高度</p><p>思路：</p><p>使用层次遍历，记录当前层的最后一个元素，当出列的是当前层的最后一个元素时，记录下一层的最后元素，层数加一</p><p>因为出列到当前层的最后一个元素时，下一层的所有元素已经入队了，所有这时记录队尾就是下一层最后一个元素</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">Btdepth</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> front <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> rear <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> last <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> level <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    BiTree Q<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
    Q<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> T<span class="token punctuation">;</span>  <span class="token comment">// 根入列</span>
    BiTree p<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>front <span class="token operator">&lt;</span> rear<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> Q<span class="token punctuation">[</span><span class="token operator">++</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 出队</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span>  <span class="token comment">// 左孩子入队</span>
            Q<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-&gt;</span>lchild<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span>  <span class="token comment">// 右孩子入队</span>
            Q<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>front <span class="token operator">==</span> last<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 当出队的是当前层最后一个时</span>
            level<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">// 层数加一</span>
            last <span class="token operator">=</span> rear<span class="token punctuation">;</span>  <span class="token comment">// 指向下一层的最后一个</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> level<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="访问-x-的所有祖先" tabindex="-1"><a class="header-anchor" href="#访问-x-的所有祖先" aria-hidden="true">#</a> 访问 x 的所有祖先</h4><p>问题：在二叉树中查找值为 x 的结点，试编写算法打印值为 x 的结点的所有祖先，假设值为 x 的结点不多于一个</p><p>思路：使用带栈的后序遍历，当访问到值为 x 的结点时，栈中所有元素均为该结点的祖先</p><p>后序遍历是指，访问可以任何时候访问，但入栈要先左后右，出栈要在左右入栈之后</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    BiTree t<span class="token punctuation">;</span>
    <span class="token keyword">int</span> tag<span class="token punctuation">;</span>  <span class="token comment">// 0 表示左孩子被访问；1 表示右孩子被访问</span>
<span class="token punctuation">}</span> stack<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Search</span><span class="token punctuation">(</span>BiTree bt<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    stack s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 假设栈足够大</span>
    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>bt <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> top <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 访问该结点，访问在左之前，而出栈在右之后，中操作其实就是出栈操作</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>bt <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> bt <span class="token operator">-&gt;</span> data <span class="token operator">!=</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            s<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>t <span class="token operator">=</span> bt<span class="token punctuation">;</span>
            s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            bt <span class="token operator">=</span> bt <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>bt <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> bt <span class="token operator">-&gt;</span> data <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 找到 x</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;所查结点的所有祖先结点的值为：\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> top<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>t <span class="token operator">-&gt;</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 退栈，右结点都被访问了的结点已经遍历完了，退到右结点没被访问的结点</span>
        <span class="token comment">// 感觉可以把判断操作放在出栈之后，而不是在入栈的时候直接判断，可能是为了节省性能才先访问吧</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>top <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
            top<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token comment">// 来到这里 bt 已经是 NULL，且栈顶只有右结点未被访问</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 设置为访问它的右结点</span>
            bt <span class="token operator">=</span> s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>t <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>  <span class="token comment">// 开始访问右结点</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>感觉这种递归没有<a href="#%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">栈实现后序遍历</a>的代码好用，思维也没它清晰</p><h4 id="访问-p、q-的最近共同祖先" tabindex="-1"><a class="header-anchor" href="#访问-p、q-的最近共同祖先" aria-hidden="true">#</a> 访问 p、q 的最近共同祖先</h4><p>问题：设一棵二叉树的结点结构为 <code>(LLINK, INFO, RLINK)</code>，ROOT为指向该二叉树根结点的指针，p 和 q 分别指向该二叉树中任意两个结点的指针，试编写算法 <code>ANCESTOR(ROOT, p, q, r)</code>，找到 p 和 q 的最近公共祖先结点 r</p><p>思路：使用后序遍历加辅助栈，把第一个找到的结点的所有祖先放入辅助栈中，找到第二个时把辅助栈与当前栈比较</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    BiTree t<span class="token punctuation">;</span>
    <span class="token keyword">int</span> tag<span class="token punctuation">;</span>  <span class="token comment">// 0 表示左孩子被访问；1 表示右孩子被访问</span>
<span class="token punctuation">}</span> stack<span class="token punctuation">;</span>

BiTree <span class="token function">Ancestor</span><span class="token punctuation">(</span>BiTree ROOT<span class="token punctuation">,</span> BiTNode <span class="token operator">*</span>p<span class="token punctuation">,</span> BiTNode <span class="token operator">*</span>q<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    stack s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 假设栈足够大</span>
    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> top1<span class="token punctuation">;</span>
    BiTree bt <span class="token operator">=</span> ROOT<span class="token punctuation">;</span>
    bool find <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>bt <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> top <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 访问该结点，访问在左之前，而出栈在右之后，中操作其实就是出栈操作</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>bt <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            s<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>t <span class="token operator">=</span> bt<span class="token punctuation">;</span>
            s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            bt <span class="token operator">=</span> bt <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 右结点都被访问了的结点已经遍历完了，出栈执行操作了</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>top <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>t <span class="token operator">==</span> p <span class="token operator">||</span> s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>t <span class="token operator">==</span> q<span class="token punctuation">)</span>  <span class="token comment">// 是要找的两结点之一</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>find<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 找到第一个</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> top<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">// 把栈拷贝到辅助中保存</span>
                        s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    top1 <span class="token operator">=</span> top<span class="token punctuation">;</span>
                    find <span class="token operator">=</span> true<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment">// 找到第二个</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> top<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">// 第一个不相等的结点的父结点就是最近的共同祖先</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>t <span class="token operator">!=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>t<span class="token punctuation">)</span>
                            <span class="token keyword">return</span> s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>t<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            top<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 来到这里 bt 已经是 NULL，且栈顶只有右结点未被访问</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 设置为访问它的右结点</span>
            bt <span class="token operator">=</span> s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>t <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>  <span class="token comment">// 开始访问右结点</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我看见答案的时候很失望，居然是这种简单普遍的解法，代码也有点问题，修改了一下不一定能执行</p><h4 id="树的最大宽度" tabindex="-1"><a class="header-anchor" href="#树的最大宽度" aria-hidden="true">#</a> 树的最大宽度</h4><p>题目：假设二叉树采用二叉链表存储结构，设计一个算法，求非空二叉树 b 的宽度（结点最多的那层的结点个数）</p><p>思路：使用队列层序遍历，队列中不仅带结点，还带结点所在的层数</p><p>根部层数为 1，入队时左子树的层数是自己层数加一，右子树也是一样</p><p>最后扫描队列求出各层的结点的总数，最大的层结点总数就是树的宽度了</p><h4 id="满二叉树的先序转后序" tabindex="-1"><a class="header-anchor" href="#满二叉树的先序转后序" aria-hidden="true">#</a> 满二叉树的先序转后序</h4><p>题目：设有一棵<strong>满二叉树</strong>，所有结点值均不同，已知其先序序列为 <code>pre</code>，设计一个算法求其后序序列 <code>post</code></p><p>思考：对于先序和后序有一条规则，<strong>先序的第一位等于后序的最后一位</strong>，那么我们根据这条规则就可以想出：</p><ol><li>取出先序序列的第一个放入后序序列的最后一个</li><li>除掉第一位的先序序列从中间拆开，左半是左子树，右半是右子树；左 1 就时左根，右 1 就是右根</li><li>后序序列是左右中，现在反过来就是中右左了，第二步时中放完了，现在放右，对右子树根结点递归到 1</li><li>根据中右左，右子树的信息放完了就该放左子树，从左子树开始，对左子树根结点递归到 1</li></ol><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/**
 * pre: 前序序列
 * l1: pre 的第一个结点的下标
 * h1: pre 的最后一个结点的下标
 * post: 后序序列
 * l2: post 的第一个结点的下标
 * h2: post 的最后一个结点的下标
 */</span>
<span class="token keyword">void</span> <span class="token function">PreToPost</span><span class="token punctuation">(</span><span class="token keyword">char</span> pre<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l1<span class="token punctuation">,</span> <span class="token keyword">int</span> r1<span class="token punctuation">,</span> <span class="token keyword">char</span> post<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l2<span class="token punctuation">,</span> <span class="token keyword">int</span> r2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> mid<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>r1 <span class="token operator">&gt;=</span> l1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        post<span class="token punctuation">[</span>r2<span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">[</span>l1<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 中</span>
        mid <span class="token operator">=</span> <span class="token punctuation">(</span>r1 <span class="token operator">-</span> l1<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token function">PreToPost</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> l1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> l1 <span class="token operator">+</span> mid<span class="token punctuation">,</span> post<span class="token punctuation">,</span> l2<span class="token punctuation">,</span> l2 <span class="token operator">+</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 左，前半段放左</span>
        <span class="token function">PreToPost</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> l1 <span class="token operator">+</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> post<span class="token punctuation">,</span> l2 <span class="token operator">+</span> mid<span class="token punctuation">,</span> r2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 右，后半段放右</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="中序结点找后序前驱" tabindex="-1"><a class="header-anchor" href="#中序结点找后序前驱" aria-hidden="true">#</a> 中序结点找后序前驱</h4><p>题目：写出在中序线索二叉树里查找指定结点在后序的前驱结点的算法</p><p>思路：结合中序和后序线索二叉树，思考各种情况，得到以下规律：</p><ol><li>若结点 p 有右孩子，则右孩子是其前驱</li><li>若无右孩子但有左孩子，则左孩子是其前驱</li><li>拿其中序左线索，为空就没有前驱</li><li>中序左线索指向的祖先 f，它有左子树，则前驱就是 f 的左子树</li><li>若 f 的左子树为空，就取其中序左线索，循环直到它左子树不为空，前驱就是左子树</li><li>若循环时 f 的左子树为空了（没有线索了）就没有前驱</li></ol><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>BiThrTree <span class="token function">InPostPre</span><span class="token punctuation">(</span>BiThrTree t<span class="token punctuation">,</span> BiThrTree p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    BiThrTree q<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> rtag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">// 第一步，有右返回右</span>
        q <span class="token operator">=</span> p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">-</span> <span class="token operator">&gt;</span> ltag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">// 第二部，无右有左返回左</span>
        q <span class="token operator">=</span>  p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> lchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token comment">// 第三步，无线索无前驱</span>
        q <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> ltag <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> p <span class="token operator">-&gt;</span> lchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token comment">// 循环直到有左子树</span>
            p <span class="token operator">=</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> ltag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">// 有左子树，前驱是左子树</span>
            q <span class="token operator">=</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
        <span class="token keyword">else</span>  <span class="token comment">// 没有无前驱</span>
            q <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> q<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="树、森林" tabindex="-1"><a class="header-anchor" href="#树、森林" aria-hidden="true">#</a> 树、森林</h2><h3 id="树的存储结构" tabindex="-1"><a class="header-anchor" href="#树的存储结构" aria-hidden="true">#</a> 树的存储结构</h3><h4 id="双亲表示法" tabindex="-1"><a class="header-anchor" href="#双亲表示法" aria-hidden="true">#</a> 双亲表示法</h4><p>采用一组<strong>连续的空间</strong>存储每个结点，并在每个结点中<strong>记录其父结点的索引</strong>，它的存储结构描述：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_TREE_SIZE</span> <span class="token expression"><span class="token number">100</span></span></span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    ElemType data<span class="token punctuation">;</span>  <span class="token comment">// 数据元素</span>
    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>  <span class="token comment">// 双亲的索引</span>
<span class="token punctuation">}</span> PTNode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    PTNode nodes<span class="token punctuation">[</span>MAX_TREE_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 结点信息</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>  <span class="token comment">// 结点数</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+h+'" alt="image-20210919141347791" tabindex="0" loading="lazy"><figcaption>image-20210919141347791</figcaption></figure><p>该存储结构利用了每个结点<strong>只有一个双亲</strong>的性质，可以很快得到结点的双亲，但<strong>获取结点的孩子</strong>需要<strong>遍历整个结构</strong></p><p>注意：注意树和二叉树的最大的区别是，它的<strong>儿子数量不是固定的</strong>，所以才需要记录双亲的索引</p><h4 id="孩子表示法" tabindex="-1"><a class="header-anchor" href="#孩子表示法" aria-hidden="true">#</a> 孩子表示法</h4><p>将<strong>每个结点的孩子都用单链表连接起来</strong>形成一个线性结构，此时 n 个结点就有 n 个孩子链表</p><p>该存储结构寻找子女操作很简单，但是<strong>寻找双亲</strong>就要<strong>迭代全部整个孩子链表</strong>了</p><figure><img src="'+g+`" alt="image-20210919142223692" tabindex="0" loading="lazy"><figcaption>image-20210919142223692</figcaption></figure><h4 id="孩子兄弟表示法" tabindex="-1"><a class="header-anchor" href="#孩子兄弟表示法" aria-hidden="true">#</a> 孩子兄弟表示法</h4><p>孩子兄弟表示法又称<strong>二叉树表示法</strong>，以二叉链表作为树的存储结构</p><p>其中<strong>左指针</strong>指向结点的<strong>第一个孩子结点</strong>，<strong>右指针</strong>指向该结点的<strong>下一个兄弟结点</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CSNode</span> <span class="token punctuation">{</span>
    ElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">CSNode</span> <span class="token operator">*</span>firstchild<span class="token punctuation">,</span> <span class="token operator">*</span>nextsibling<span class="token punctuation">;</span>
<span class="token punctuation">}</span> CSNode<span class="token punctuation">,</span> <span class="token operator">*</span>CSTree<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该存储结构可以方便地实现<strong>树转换为二叉树的操作</strong>，易于<strong>找结点的孩子</strong>，但<strong>找其双亲比较麻烦</strong></p><p>若为每个结点<strong>增设一个 parent 域</strong>指向其父结点，则查<strong>找结点的父结点也很方便</strong></p><figure><img src="`+d+'" alt="image-20210919144047050" tabindex="0" loading="lazy"><figcaption>image-20210919144047050</figcaption></figure><h3 id="树、森林与二叉树的转换" tabindex="-1"><a class="header-anchor" href="#树、森林与二叉树的转换" aria-hidden="true">#</a> 树、森林与二叉树的转换</h3><p>给定一森林，可以找到<strong>唯一的二叉树</strong>与之对应；同样的给定一棵二叉树，可以找到<strong>唯一的森林</strong>与它对应</p><p>二叉树与森林从物理结构上看它们的二叉链表是相同的，但<strong>解释不一样</strong></p><p>以下都是逻辑上的转换（考试画图，或选择题逻辑），因为在计算机内二叉树本就是森林的存储结构，不用转换</p><p>选择题：将森林 F 转换为对应的二叉树 T，F 中<strong>叶结点的个数</strong>等于 T 中<strong>左孩子指针为空的结点个数</strong>；F 中的<strong>非终端结点个数</strong>等于 T 中<strong>右孩子指针为空的结点个数减一</strong></p><ol><li><p>根据左孩子右兄弟，T 中左指针为空意味着森林的某个结点没有孩子，所以左指针空的个数是 F 中叶结点的个数</p></li><li><p>根据左孩子右兄弟，T 中右指针为空意味着森林中某个结点没有右兄弟</p><p>首先非终端结点肯定有孩子，那么它的孩子中肯定就会有一个没有右兄弟</p><p>就有 T 中右指针为空的个数至少为 F 中非终端的个数</p><p>其次对于根结点来说，除了它的孩子会没有右兄弟外它自己也没有右兄弟</p><p>把根结点算上，就有 T 的右指针为空的个数就是 F 的非终端的个数加一</p></li></ol><h4 id="树转换成二叉树" tabindex="-1"><a class="header-anchor" href="#树转换成二叉树" aria-hidden="true">#</a> 树转换成二叉树</h4><p>每个结点的<strong>左指针指向它的第一个孩子</strong>，<strong>右指针指向它在树中的相邻右兄弟</strong>，这是<strong>左孩子右兄弟</strong></p><p>树转换成二叉树的画法：</p><ol><li>在兄弟结点之间加一连线</li><li>仅保留指向第一个孩子的指针</li><li>以树根为中心顺时针旋转 45°</li></ol><h4 id="森林转换成二叉树" tabindex="-1"><a class="header-anchor" href="#森林转换成二叉树" aria-hidden="true">#</a> 森林转换成二叉树</h4><p>森林转换成二叉树与树类似，只要把<strong>第二棵树看成第一棵树的右兄弟</strong>，依次类推就好了</p><p>森林转换成二叉树的画法：</p><ol><li>将森林的没课树转换成相应的二叉树</li><li>每棵树的根视为兄弟关系，在每棵树的根间加一条连线</li><li>以第一棵树的根为中心顺时针旋转 45°</li></ol><h4 id="二叉树转换成树、森林" tabindex="-1"><a class="header-anchor" href="#二叉树转换成树、森林" aria-hidden="true">#</a> 二叉树转换成树、森林</h4><ul><li>若二叉树非空，二叉树的根及其左子树为第一棵树的二叉树形式</li><li>将根的右链断开，它的右子树视为一个森林来处理，如此反复，直到没有右子树</li><li>最后将每课二叉树依次转换成树，就得到原森林</li></ul><h3 id="树和森林的遍历" tabindex="-1"><a class="header-anchor" href="#树和森林的遍历" aria-hidden="true">#</a> 树和森林的遍历</h3><h4 id="树的遍历" tabindex="-1"><a class="header-anchor" href="#树的遍历" aria-hidden="true">#</a> 树的遍历</h4><ul><li><p>先根遍历：若树非空，先访问根结点，再依次遍历根结点的每个子树，遍历时仍采用先根遍历</p><p>其遍历序列与这棵树<strong>相应二叉树的先序遍历相同</strong></p></li><li><p>后根遍历：若树非空，先依次遍历根结点的每个子树，再访问根结点，遍历时仍采用后根遍历</p><p>其遍历序列与这棵树<strong>相应的二叉树的中序遍历相同</strong></p></li><li><p>层次遍历：与二叉树的层次遍历一样，使用队列，先入根结点，出列一个结点时把其子树全部入列</p></li></ul><h4 id="森林的遍历" tabindex="-1"><a class="header-anchor" href="#森林的遍历" aria-hidden="true">#</a> 森林的遍历</h4><ol><li>先序遍历森林，若森林非空，就执行遍历： <ul><li>访问森林中第一棵树的根结点</li><li>先序遍历第一棵树种根结点的子树森林（这两步相当于前根遍历，先自己，再遍历子结点）</li><li>先序遍历除去第一棵树之后剩余的树构成的森林（对第二棵树，第三棵等递归使用前根遍历）</li></ul></li><li>中序遍历森林（也可以叫后序遍历），若森林非空，就执行遍历： <ul><li>中序遍历森林中第一棵树的根结点的子树森林</li><li>访问第一棵树的根结点（这两步相当于后根遍历，先遍历子结点，再自己）</li><li>中序遍历除去第一棵树之后剩余的树构成的森林（对第二棵树，第三棵等递归使用后根遍历）</li></ul></li></ol><p><strong>先序遍历</strong>森林就相当于<strong>先序遍历其相应的二叉树</strong>；<strong>中序遍历</strong>森林就相当于<strong>中序遍历其相应的二叉树</strong></p><img src="'+k+`" alt="image-20210919152628452" style="zoom:200%;"><p>注意：<strong>中序遍历</strong>森林，<strong>也可以叫中根遍历</strong>因为对于其二叉树是中根遍历，<strong>也可以叫后根遍历</strong>因为对于树是后根遍历的</p><h3 id="树的应用——并查集" tabindex="-1"><a class="header-anchor" href="#树的应用——并查集" aria-hidden="true">#</a> *树的应用——并查集</h3><p>并查集是一种<strong>简单的集合表示</strong>，它支持以下三种操作：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">Union</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> Root1<span class="token punctuation">,</span> Root2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 把集合 S 的子集合 Root2 并入子集合 Root1，要求它们不能相交</span>
<span class="token function">Find</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 查找集合 S 中单元素 x 所在的子集合，返回子集合名字</span>
<span class="token function">Initial</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将集合 S 中的每个元素都初始化为只有一个单元的集合</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通常用<strong>森林的双亲表示</strong>作为并查集的存储结构，<strong>每个子集以一棵树表示</strong></p><p>通常以<strong>数组的下标表示元素名</strong>，用<strong>根结点的下标代表子集合名</strong>，<strong>根结点的双亲结点为负数</strong></p><p>合并两个子集，只需将其中<strong>一个子集合根结点的双亲指针指向另一个集合的根结点</strong></p><p>使用双亲指针数组作为并查集存储表示时，<strong>集合元素编号从 0 到 size - 1</strong>，其中 size 是最大元素的个数</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">defind</span> <span class="token expression">SIZE <span class="token number">100</span></span></span>
<span class="token keyword">int</span> UFSets<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 集合元素（双亲数组）</span>

<span class="token comment">// 初始化并查集，所有初始化为 -1，即各自都是一棵树</span>
<span class="token keyword">void</span> <span class="token function">Initial</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 查找 S 中包含 x 的树的根结点</span>
<span class="token keyword">int</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>S<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        x <span class="token operator">=</span> S<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 合并两个不相交的子集，即求并集</span>
<span class="token keyword">void</span> <span class="token function">Union</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> Root1<span class="token punctuation">,</span> <span class="token keyword">int</span> Root2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    S<span class="token punctuation">[</span>Root2<span class="token punctuation">]</span> <span class="token operator">=</span> Root1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="层次序列及度构成孩子兄弟链表" tabindex="-1"><a class="header-anchor" href="#层次序列及度构成孩子兄弟链表" aria-hidden="true">#</a> 层次序列及度构成孩子兄弟链表</h3><p>问题：已知一棵树的层次序列及每个结点的度，编写算法构成此树的孩子兄弟链表</p><p>思路：由于有结点的度，我们可以拿到结点的子结点并链到结点上，只需要使用遍历记录子结点的位置合父结点的位置</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">maxNodes</span> <span class="token expression"><span class="token number">15</span></span></span>

<span class="token keyword">void</span> <span class="token function">createCSTreeDegree</span><span class="token punctuation">(</span>CSTree <span class="token operator">&amp;</span>T<span class="token punctuation">,</span> DataType e<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> degree<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    CSTree <span class="token operator">*</span>pointer <span class="token operator">=</span> new CSTree<span class="token punctuation">[</span>maxNodes<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> d<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 初始化数组</span>
        pointer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> new CSNode<span class="token punctuation">;</span>
        pointer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-&gt;</span> data <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        pointer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-&gt;</span> lchild <span class="token operator">=</span> pointer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-&gt;</span> rsibling <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 调整树的关系</span>
        d <span class="token operator">=</span> degree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 当前结点的度数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            k<span class="token operator">++</span><span class="token punctuation">;</span>
            pointer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-&gt;</span> lchild <span class="token operator">=</span> pointer<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 把该结点的子结点链入</span>
                k<span class="token operator">++</span><span class="token punctuation">;</span>
                pointer<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> rsibling <span class="token operator">=</span> pointer<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    T <span class="token operator">=</span> pointer<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    delete <span class="token punctuation">[</span><span class="token punctuation">]</span> pointer<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>书上采用的是辅助数组直接初始化，然后分别链上去，而我更想用队列，下面是我使用队列写的</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 创建新的结点</span>
CSNode <span class="token operator">*</span><span class="token function">createCSNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	CSNode <span class="token operator">*</span>r <span class="token operator">=</span> new CSNode<span class="token punctuation">;</span>
	r<span class="token operator">-&gt;</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
	r<span class="token operator">-&gt;</span>rchild <span class="token operator">=</span> r<span class="token operator">-&gt;</span>lchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">createCSTreeDegree</span><span class="token punctuation">(</span>CSTree <span class="token operator">&amp;</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> degree<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	LinkQueue Q<span class="token punctuation">;</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> d<span class="token punctuation">;</span>
	CSNode <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>
	<span class="token function">InitQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>
	T <span class="token operator">=</span> <span class="token function">createCSNode</span><span class="token punctuation">(</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 创建根部结点</span>
	<span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">DeQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
		i<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">=</span> degree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 如果有度就是有儿子，把儿子链入然后入队列</span>
			k<span class="token operator">++</span><span class="token punctuation">;</span>
			q <span class="token operator">=</span> p<span class="token operator">-&gt;</span>lchild <span class="token operator">=</span> <span class="token function">createCSNode</span><span class="token punctuation">(</span>e<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				k<span class="token operator">++</span><span class="token punctuation">;</span>
				q<span class="token operator">-&gt;</span>rchild <span class="token operator">=</span> <span class="token function">createCSNode</span><span class="token punctuation">(</span>e<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				q <span class="token operator">=</span> q<span class="token operator">-&gt;</span>rchild<span class="token punctuation">;</span>
				<span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="树与二叉树的应用" tabindex="-1"><a class="header-anchor" href="#树与二叉树的应用" aria-hidden="true">#</a> 树与二叉树的应用</h2><h3 id="二叉排序树-1" tabindex="-1"><a class="header-anchor" href="#二叉排序树-1" aria-hidden="true">#</a> 二叉排序树</h3><h4 id="二叉排序树的定义" tabindex="-1"><a class="header-anchor" href="#二叉排序树的定义" aria-hidden="true">#</a> 二叉排序树的定义</h4><p><strong>二叉排序树</strong>也称<strong>二叉查找树</strong>，是<strong>一棵空树</strong>，或者是<strong>具有以下特性的二叉树</strong>：</p><ol><li>若左子树非空，则左子树上所有结点的值均小于根结点的值</li><li>若右子树非空，则右子树上所有结点的值均大于根结点的值</li><li>左、右子树也分配时一棵二叉排序树</li></ol><p>根据二叉树的定义有<strong>左子树的值 &lt; 根结点值 &lt; 右子树的值</strong>，所以对二叉排序树进行<strong>中序遍历</strong>就会得到一个<strong>递增序列</strong></p><h4 id="二叉排序树的查找" tabindex="-1"><a class="header-anchor" href="#二叉排序树的查找" aria-hidden="true">#</a> 二叉排序树的查找</h4><p>二叉排序树<strong>从根结点开始查找</strong>，先<strong>和根结点的值进行比较</strong>，<u>相等则查找成功；小于就递归左子树；大于就递归右子树</u></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>BSTNode <span class="token operator">*</span><span class="token function">BST_Search</span><span class="token punctuation">(</span>BSTree T<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> key <span class="token operator">!=</span> T <span class="token operator">-&gt;</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">&gt;</span> T <span class="token operator">-&gt;</span> key<span class="token punctuation">)</span> T <span class="token operator">=</span> T <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>
        <span class="token keyword">else</span> T <span class="token operator">=</span> T <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> T<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="二叉排序树的插入" tabindex="-1"><a class="header-anchor" href="#二叉排序树的插入" aria-hidden="true">#</a> 二叉排序树的插入</h4><p>二叉排序树作为一种<strong>动态树表</strong>，特点是树的结构不是一次生成的，而是<strong>在查找过程中发现值不存在后的插入</strong></p><p>插入过程如下：</p><ul><li>若原二叉树为空则直接插入结点</li><li>若关键字 k 小于根结点值，则插入左子树；否则插入到右子树</li></ul><p>插入的点一定是一个<strong>新添加的叶结点</strong>，而且是查找失败时的<strong>查找路径上最后访问结点的子结点</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">BST_Insert</span><span class="token punctuation">(</span>BSTree <span class="token operator">&amp;</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        T <span class="token operator">=</span> <span class="token punctuation">(</span>BSTNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BSTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        T <span class="token operator">-&gt;</span> key <span class="token operator">=</span> k<span class="token punctuation">;</span>
        T <span class="token operator">-&gt;</span> lchild <span class="token operator">=</span> T <span class="token operator">-&gt;</span> rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 插入成功</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> key <span class="token operator">==</span> k<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 插入失败</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">&gt;</span> T <span class="token operator">-&gt;</span> key<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">BST_Insert</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> rchild<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// key 比根结点的大插到右边</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token function">BST_Insert</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> lchild<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// key 比根结点的小插到左边</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="二叉排序树的构造" tabindex="-1"><a class="header-anchor" href="#二叉排序树的构造" aria-hidden="true">#</a> 二叉排序树的构造</h4><p>二叉排序树的构造就是从一棵空树出发，一次输入元素，将它们插入二叉排序树中的合适位置</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">Creat_BST</span><span class="token punctuation">(</span>BSTree <span class="token operator">&amp;</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    T <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">BST_Insert</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="二叉排序树的删除" tabindex="-1"><a class="header-anchor" href="#二叉排序树的删除" aria-hidden="true">#</a> 二叉排序树的删除</h4><p>二叉排序树的删除不是把以该结点为根的子树都删除，而是<strong>仅删除该结点</strong>，然后<strong>调整二叉排序树</strong>，使他仍是二叉排序树</p><p>删除操作的实现过程按 3 种情况来处理：</p><ol><li>若被删除结点 z 是叶结点，则直接删除，因为不会破开二叉排序树的性质</li><li>若结点 z 只有一棵子树，则让 z 的子树称为 z 的父结点的子树，代替 z 的位置</li><li>若结点 z 有左右两棵子树，则令它的直接后继（或直接前驱）与 z 交换位置，这时再删除 z 情况就是第一步或第二步了</li></ol><p>思考：二叉排序树种删除后再插入某结点，的到的二叉树取决于删除的位置，若删除的是<strong>叶结点那么相同</strong>，<strong>否则不相同</strong></p><h4 id="二叉排序树的查找效率" tabindex="-1"><a class="header-anchor" href="#二叉排序树的查找效率" aria-hidden="true">#</a> 二叉排序树的查找效率</h4>`,149),$=s("p",null,[n("二叉排序树的"),s("strong",null,"查找效率"),n("，"),s("strong",null,"主要取决于树的高度"),n("。二叉树的结点分布比较均匀像"),s("strong",null,"平衡二叉树"),n("那样，平均查找长度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("msub",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("mn",null,"2")]),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(\\log_2n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mop"},[s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.207em"}},[s("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2441em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("；但如果是一个"),s("strong",null,"单支树"),n("，则平均查找长度为 O(n)")],-1),ss=s("p",null,[n("在最坏情况下，即构造二叉排序树的"),s("strong",null,"输入序列是有序的"),n("，则会"),s("strong",null,"形成一个倾斜的单支树")],-1),ns=s("p",null,[n("在等概率情况下，"),s("strong",null,"查找成功的平均查找长度"),n("为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"("),s("mstyle",{scriptlevel:"0",displaystyle:"true"},[s("munderover",null,[s("mo",null,"∑"),s("mrow",null,[s("mi",null,"i"),s("mo",null,"="),s("mn",null,"1")]),s("mrow",null,[s("mi",null,"d"),s("mi",null,"e"),s("mi",null,"e"),s("mi",null,"p")])]),s("mi",null,"i"),s("mo",null,"×"),s("mi",null,"n"),s("mi",null,"u"),s("msub",null,[s("mi",null,"m"),s("mi",null,"i")]),s("mo",{stretchy:"false"},")"),s("mi",{mathvariant:"normal"},"/"),s("mi",null,"n")])]),s("annotation",{encoding:"application/x-tex"},"(\\displaystyle\\sum_{i=1}^{deep}i\\times num_i)/n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"3.1609em","vertical-align":"-1.2777em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mop op-limits"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.8832em"}},[s("span",{style:{top:"-1.8723em","margin-left":"0em"}},[s("span",{class:"pstrut",style:{height:"3.05em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"i"),s("span",{class:"mrel mtight"},"="),s("span",{class:"mord mtight"},"1")])])]),s("span",{style:{top:"-3.05em"}},[s("span",{class:"pstrut",style:{height:"3.05em"}}),s("span",null,[s("span",{class:"mop op-symbol large-op"},"∑")])]),s("span",{style:{top:"-4.3471em","margin-left":"0em"}},[s("span",{class:"pstrut",style:{height:"3.05em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"d"),s("span",{class:"mord mathnormal mtight"},"ee"),s("span",{class:"mord mathnormal mtight"},"p")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.2777em"}},[s("span")])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"i"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"×"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mord mathnormal"},"u"),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"m"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mclose"},")"),s("span",{class:"mord"},"/"),s("span",{class:"mord mathnormal"},"n")])])]),n(" 其中 deep 是总深度，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n"),s("mi",null,"u"),s("msub",null,[s("mi",null,"m"),s("mi",null,"i")])]),s("annotation",{encoding:"application/x-tex"},"num_i")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mord mathnormal"},"u"),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"m"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),n(" 是第 i 层的结点数，n 是结点总数")],-1),as=s("p",null,[n("在等概率情况下，"),s("strong",null,"查找失败的平均查找长度"),n("为 “("),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mstyle",{scriptlevel:"0",displaystyle:"true"},[s("mo",null,"∑")])]),s("annotation",{encoding:"application/x-tex"},"\\displaystyle\\sum")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.6em","vertical-align":"-0.55em"}}),s("span",{class:"mop op-symbol large-op",style:{position:"relative",top:"0em"}},"∑")])])]),n(" NULL 的父亲的层数) / NULL 的个数”")],-1),ts=s("p",null,[n("从查找过程看，二叉排序树与二分查找相似，其平均时间性能差不多，但"),s("strong",null,"二分查找的判定树唯一"),n("，而"),s("strong",null,"二叉排序树的查找不唯一"),n("，相同的关键字其"),s("strong",null,"插入顺序不同可能生成不同的二叉排序树")],-1),ls=s("p",null,[n("维护表的有序性而言，"),s("strong",null,"插入和删除"),n("元素时，"),s("strong",null,"二叉排序树平均执行时间"),n("为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("msub",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("mn",null,"2")]),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(\\log_2n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mop"},[s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.207em"}},[s("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2441em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("，而"),s("strong",null,"有序顺序表"),n("则需要 O(n)")],-1),es=a('<p>所以，当有序表是<strong>静态查找表</strong>时，宜用<strong>顺序表作为存储结构</strong>；若有序表是<strong>动态查找表</strong>，则选择<strong>二叉排序树作为逻辑结构</strong></p><h3 id="平衡二叉树-1" tabindex="-1"><a class="header-anchor" href="#平衡二叉树-1" aria-hidden="true">#</a> 平衡二叉树</h3><h4 id="平衡二叉树的定义" tabindex="-1"><a class="header-anchor" href="#平衡二叉树的定义" aria-hidden="true">#</a> 平衡二叉树的定义</h4><p>避免树的高度增长过快，降低二叉排序树的性能，定义<strong>平衡二叉树</strong>，简称<strong>平衡树</strong>，它的<strong>左右子树高度差的绝对值不超过 1</strong></p><p>结点<strong>左子树与右子树的高度差</strong>称为该结点的<strong>平衡因子</strong>，则平衡二叉树的平衡因子只可能是 -1、0、1</p><p>平衡二叉树可以定义为<strong>一棵空树</strong>，或具有以下性质的树：它的<strong>左子树和右子树都是平衡二叉树</strong>，且<strong>左子树和右子树的高度差的绝对值不超过 1</strong></p><figure><img src="'+v+'" alt="image-20210920122745558" tabindex="0" loading="lazy"><figcaption>image-20210920122745558</figcaption></figure><h4 id="平衡二叉树的旋转" tabindex="-1"><a class="header-anchor" href="#平衡二叉树的旋转" aria-hidden="true">#</a> 平衡二叉树的旋转</h4><h5 id="左旋转" tabindex="-1"><a class="header-anchor" href="#左旋转" aria-hidden="true">#</a> 左旋转</h5><p>左旋是在保持二叉排序树的规则下，令左边层数加一，右边层数减一，步骤为：</p><ol><li>设 r 是根，p 为根的右子树</li><li>r 的右子树变成 p 的左子树</li><li>p 的左子树变成 r</li><li>根结点变成 p</li></ol><figure><img src="'+y+'" alt="v2-db1cdb0da952a71f9b6d64b2608467eb_b" tabindex="0" loading="lazy"><figcaption>v2-db1cdb0da952a71f9b6d64b2608467eb_b</figcaption></figure><h5 id="右旋转" tabindex="-1"><a class="header-anchor" href="#右旋转" aria-hidden="true">#</a> 右旋转</h5><p>右旋是在保持二叉排序树的规则下，令右边层数加一，左边层数减一，步骤为：</p><ol><li>设 r 是根，p 是根的左子树</li><li>r 的左子树变成 p 的右子树</li><li>p 的右子树变成 r</li><li>根结点变成 p</li></ol><figure><img src="'+b+`" alt="v2-05246384c1c16537ca6176983bdb2627_b" tabindex="0" loading="lazy"><figcaption>v2-05246384c1c16537ca6176983bdb2627_b</figcaption></figure><h4 id="平衡二叉树的插入" tabindex="-1"><a class="header-anchor" href="#平衡二叉树的插入" aria-hidden="true">#</a> 平衡二叉树的插入</h4><p>在<strong>插入或删除后</strong>，检查是否导<strong>致了平衡二叉树失衡</strong>，若失衡就找到距离插入点最近的失衡树，<strong>对它进行调整，使之平衡</strong></p><p>调整是递归的，从最小失衡树，即距离插入点最近的不平衡树，一直向上调整，<strong>直到整棵树没有失衡点为止</strong></p><p>平衡二叉树的<strong>插入部分和二叉查找树相同</strong>，若插入后<strong>不平衡需要调整</strong>，则有<strong>以下 4 条规律</strong>：</p><ol><li>LL 平衡旋转，当插入的点在失衡点的左子树的左子树内，以失衡点为轴进行右旋</li><li>RR 平衡旋转，当插入的点在失衡点的右子树的右子树内，以失衡点为轴进行左旋</li><li>LR 平衡旋转，当插入的点在失衡点的左子树的右子树内，以失衡点的左子树为轴进行左旋，旋转后变成情况 1</li><li>RL 平衡旋转，当插入的点在失衡点的右子树的左子树内，以失衡点的右子树为轴进行右旋，旋转后变成情况 2</li></ol><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/**
 * 插入后进行调整
 * root : 根结点
 * p : 要调整的结点
 * d : 插入的数据
 */</span>
<span class="token keyword">void</span> <span class="token function">fixAfterInsert</span><span class="token punctuation">(</span>btlink <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> btlink p<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">&lt;</span> p <span class="token operator">-&gt;</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 情况 3，在左边的右边</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">&gt;</span> p <span class="token operator">-&gt;</span> left <span class="token operator">-&gt;</span> element<span class="token punctuation">)</span> <span class="token function">rotateLeft</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> p <span class="token operator">-&gt;</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 情况 1，在左边的左边</span>
        <span class="token function">rotateRight</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 情况 4，在右边的左边</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">&lt;</span> p <span class="token operator">-&gt;</span> right <span class="token operator">-&gt;</span> element<span class="token punctuation">)</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> p <span class="token operator">-&gt;</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 情况 2，在右边的右边</span>
        <span class="token function">rotateLeft</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>插入点在哪里就意味着哪里的层数多加了一层导致失衡，所以要使用旋转把插入点的层数分一层给它兄弟，以达到平衡</p><p>LR 时左旋把左边的右边多出的一层给到左边的左边，这样就是左边的左边多层数，就是 LL 了；RL 同理</p><p>旋转只会让这个被旋转的最小失衡树平衡起来，但这个树的祖先仍然有可能会失衡，所以要递归上去检查和调整</p><h4 id="平衡二叉树的查找" tabindex="-1"><a class="header-anchor" href="#平衡二叉树的查找" aria-hidden="true">#</a> 平衡二叉树的查找</h4><p>平衡二叉树的查找过程与二叉排序树的相同，因此关键字比较的次数不超过树的深度</p>`,27),ps=s("p",null,[n("假设以 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"n"),s("mi",null,"h")])]),s("annotation",{encoding:"application/x-tex"},"n_h")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3361em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"h")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),n(" 表示深度为 h 的"),s("strong",null,"平衡树中含有的最少结点数"),n("，有 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"n"),s("mn",null,"0")]),s("mo",null,"="),s("mn",null,"0"),s("mo",{separator:"true"},","),s("msub",null,[s("mi",null,"n"),s("mn",null,"1")]),s("mo",null,"="),s("mn",null,"1"),s("mo",{separator:"true"},","),s("msub",null,[s("mi",null,"n"),s("mn",null,"2")]),s("mo",null,"="),s("mn",null,"2")]),s("annotation",{encoding:"application/x-tex"},"n_0=0,n_1=1,n_2=2")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"0")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8389em","vertical-align":"-0.1944em"}}),s("span",{class:"mord"},"0"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8389em","vertical-align":"-0.1944em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"2")])])]),n(" 并且有 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"n"),s("mi",null,"h")]),s("mo",null,"="),s("msub",null,[s("mi",null,"n"),s("mrow",null,[s("mi",null,"k"),s("mo",null,"−"),s("mn",null,"1")])]),s("mo",null,"+"),s("msub",null,[s("mi",null,"n"),s("mrow",null,[s("mi",null,"k"),s("mo",null,"−"),s("mn",null,"2")])]),s("mo",null,"+"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"n_h=n_{k-1}+n_{k-2}+1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3361em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"h")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7917em","vertical-align":"-0.2083em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3361em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2083em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7917em","vertical-align":"-0.2083em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3361em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"2")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2083em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])])],-1),is=s("p",null,[n("那么就有"),s("strong",null,"平衡二叉树的最大深度"),n("为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("msub",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("mn",null,"2")]),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(\\log_2n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mop"},[s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.207em"}},[s("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2441em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("，因此"),s("strong",null,"平衡二叉树的平均查找长度"),n("为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("msub",null,[s("mrow",null,[s("mi",null,"log"),s("mo",null,"⁡")]),s("mn",null,"2")]),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(\\log_2n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mop"},[s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.207em"}},[s("span",{style:{top:"-2.4559em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2441em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("，注意这里是有 O 的")],-1),cs=s("h5",{id:"平衡二叉树的最少结点数",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#平衡二叉树的最少结点数","aria-hidden":"true"},"#"),n(" 平衡二叉树的最少结点数")],-1),os=s("p",null,"根据平衡二叉树的定义，它的左右子树都是平衡二叉树",-1),rs=s("p",null,"自己是含有最少结点数，当且仅当左右子树也是含有最小结点的情况下",-1),ms=s("p",null,"那么自己的结点数是左子树的结点 + 右子树的结点 + 1（根结点）",-1),us=s("p",null,"含有最小结点数，那么左右子树的高度差必然为一",-1),hs=s("p",null,"综上就得出：",-1),gs=s("ol",null,[s("li",null,[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"n"),s("mi",null,"h")]),s("mo",null,"="),s("msub",null,[s("mi",null,"n"),s("mrow",null,[s("mi",null,"k"),s("mo",null,"−"),s("mn",null,"1")])]),s("mo",null,"+"),s("msub",null,[s("mi",null,"n"),s("mrow",null,[s("mi",null,"k"),s("mo",null,"−"),s("mn",null,"2")])]),s("mo",null,"+"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"n_h=n_{k-1}+n_{k-2}+1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3361em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"h")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7917em","vertical-align":"-0.2083em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3361em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"1")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2083em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7917em","vertical-align":"-0.2083em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3361em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mtight"},"2")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2083em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n("，一个子树结点 + 另一个子树结点 + 1（根结点）")]),s("li",null,[s("strong",null,"非叶子结点的平衡叶子的绝对值都为一"),n("，那么这棵树是"),s("strong",null,"含结点最少的平衡二叉树")])],-1),ds=s("h3",{id:"哈夫曼树和哈夫曼编码",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#哈夫曼树和哈夫曼编码","aria-hidden":"true"},"#"),n(" 哈夫曼树和哈夫曼编码")],-1),ks=s("h4",{id:"哈夫曼树的定义",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#哈夫曼树的定义","aria-hidden":"true"},"#"),n(" 哈夫曼树的定义")],-1),vs=s("p",null,"在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的权",-1),ys=s("p",null,[n("该"),s("strong",null,"结点的带权路径长度"),n("，是从"),s("strong",null,"树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积")],-1),bs=s("p",null,[s("strong",null,"树的带权路径长度"),n("，记为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"W"),s("mi",null,"P"),s("mi",null,"L"),s("mo",null,"="),s("mstyle",{scriptlevel:"0",displaystyle:"true"},[s("munderover",null,[s("mo",null,"∑"),s("mrow",null,[s("mi",null,"i"),s("mo",null,"="),s("mn",null,"1")]),s("mi",null,"n")]),s("msub",null,[s("mi",null,"w"),s("mi",null,"i")]),s("msub",null,[s("mi",null,"l"),s("mi",null,"i")])])]),s("annotation",{encoding:"application/x-tex"},"WPL=\\displaystyle\\sum^n_{i=1}w_il_i")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"W"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"P"),s("span",{class:"mord mathnormal"},"L"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"2.9291em","vertical-align":"-1.2777em"}}),s("span",{class:"mop op-limits"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.6514em"}},[s("span",{style:{top:"-1.8723em","margin-left":"0em"}},[s("span",{class:"pstrut",style:{height:"3.05em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"i"),s("span",{class:"mrel mtight"},"="),s("span",{class:"mord mtight"},"1")])])]),s("span",{style:{top:"-3.05em"}},[s("span",{class:"pstrut",style:{height:"3.05em"}}),s("span",null,[s("span",{class:"mop op-symbol large-op"},"∑")])]),s("span",{style:{top:"-4.3em","margin-left":"0em"}},[s("span",{class:"pstrut",style:{height:"3.05em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"n")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.2777em"}},[s("span")])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.02691em"}},"w"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.0269em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.0197em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),n(" 其中 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"w"),s("mi",null,"i")])]),s("annotation",{encoding:"application/x-tex"},"w_i")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.02691em"}},"w"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.0269em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),n(" 是第 i 个叶结点所带的权值，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"l"),s("mi",null,"i")])]),s("annotation",{encoding:"application/x-tex"},"l_i")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8444em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.0197em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),n(" 是该也结点到根结点的路径长度，即"),s("strong",null,"所有叶结点的带权路径长度的和")],-1),ws=s("figure",null,[s("img",{src:w,alt:"image-20210920141556685",tabindex:"0",loading:"lazy"}),s("figcaption",null,"image-20210920141556685")],-1),xs=s("p",null,[n("哈夫曼树是相同的权叶结点，但 "),s("code",null,"WPL"),n(" 最小的树，如上面 c 是一棵哈夫曼树")],-1),fs=s("h4",{id:"哈夫曼树的构造",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#哈夫曼树的构造","aria-hidden":"true"},"#"),n(" 哈夫曼树的构造")],-1),zs=s("p",null,[n("给定 n 个权值分别为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"w"),s("mn",null,"1")]),s("mo",{separator:"true"},","),s("mo",null,"⋯"),s("mtext",null," "),s("mo",{separator:"true"},","),s("msub",null,[s("mi",null,"w"),s("mi",null,"n")])]),s("annotation",{encoding:"application/x-tex"},"w_1,\\cdots,w_n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.02691em"}},"w"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.0269em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"minner"},"⋯"),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.02691em"}},"w"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.1514em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.0269em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"n")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),n(" 的结点，"),s("strong",null,"构造哈夫曼树的算法描述"),n("如下：")],-1),_s=a('<ol><li>将这 n 个结点分别作为 n 棵仅含一个结点的二叉树，构成森林 F</li><li>构造一个新结点，从 F 中取<strong>两棵根结点权重最小的树</strong>，<strong>合并在一起</strong>，<strong>根结点的权重是这两个权重的和</strong></li><li>从 F 中<strong>删除刚刚选出的两棵树</strong>，并<strong>加入它们的合并树</strong></li><li>重复 2、3 步骤，直至 F 中只剩下一棵树为止</li></ol><p>从上述构造过程中可以看出哈夫曼树具有以下特点：</p><ol><li><strong>每个初始结点最终都成为叶结点</strong>，且<strong>权值越小的结点到根结点的路径长度越大</strong></li><li>构造过程中共新建了 n - 1 个结点，因此<strong>哈夫曼树的结点总数为 <code>2n - 1</code></strong>，n 是叶结点的数量</li><li>每次构造都选择 2 棵树作为新结点的孩子，因此<strong>哈夫曼树中不存在度为 1 的结点</strong></li></ol><img src="'+x+'" alt="src=http___pic2.zhimg.com_v2-5591c52619c16ddd52a882981fa716cd_b.gif&amp;refer=http___pic2.zhimg"><h4 id="哈夫曼编码" tabindex="-1"><a class="header-anchor" href="#哈夫曼编码" aria-hidden="true">#</a> 哈夫曼编码</h4><p>在数据通信中，对每个字符用<strong>相等长度的二进制位表示</strong>，则称为<strong>固定长度编码</strong>；若对不同字符用<strong>不等长的二进制位表示</strong>，则称为<strong>可变长度编码</strong></p><p>可变长度编码的特点是，对<strong>频率高的字符赋以短编码</strong>，对<strong>频率低的字符赋以较长一点的编码</strong>，从而<strong>缩短字符的平均编码长度</strong>，起到压缩数据的作用</p><p>若<strong>没有一个编码是另一个编码的前缀</strong>，那么称这样的编码为<strong>前缀编码</strong>，如 {0, 00} 不是前缀码，{0, 10} 是前缀码</p><p>前缀编码的解码：因为没有一个编码是其他编码的前缀，解码时只<strong>需识别每一个编码，将它翻译成原码</strong></p><p>哈夫曼编码的构造：</p><ol><li>将每个出现的字符作为哈夫曼树的结点，其权值为字符出现的频率</li><li>拿这些字符结点构成一棵哈夫曼树</li><li>将哈夫曼树的左边标记 0，右边标记 1</li><li>每个字符的编码就是哈夫曼树的根到它所经过边的标记的集合</li></ol><figure><img src="'+f+`" alt="image-20210920150005087" tabindex="0" loading="lazy"><figcaption>image-20210920150005087</figcaption></figure><p>注意：<strong>0 和 1 是左边还是右边没有明确规定</strong>，且<strong>左右结点的顺序是任意的</strong>，所有<strong>构造出的哈夫曼树不唯一</strong>，但<strong>每个哈夫曼树的 <code>WPL</code> 相同且为最优</strong></p><h3 id="综合应用题-1" tabindex="-1"><a class="header-anchor" href="#综合应用题-1" aria-hidden="true">#</a> 综合应用题</h3><h4 id="检验是否为二叉排序树" tabindex="-1"><a class="header-anchor" href="#检验是否为二叉排序树" aria-hidden="true">#</a> 检验是否为二叉排序树</h4><p>题目：试编写一个算法，判断给定的二叉树是否为二叉排序树</p><p>思路：利用二叉排序树的中序会大于它的前驱，只要存储前驱的变量就好了</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> pre <span class="token operator">=</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">JudgeBST</span><span class="token punctuation">(</span>BiTree bt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bt <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">JudgeBST</span><span class="token punctuation">(</span>bt <span class="token operator">-&gt;</span> lchild<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> pre <span class="token operator">&gt;=</span> bt <span class="token operator">-&gt;</span> data<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    pre <span class="token operator">=</span> bt <span class="token operator">-&gt;</span> data<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">JudgeBST</span><span class="token punctuation">(</span>bt <span class="token operator">-&gt;</span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="最小代价合并多个有序表" tabindex="-1"><a class="header-anchor" href="#最小代价合并多个有序表" aria-hidden="true">#</a> 最小代价合并多个有序表</h4><p>问题：设有 6 个有序表 A，B，C，D，E，F，分别含有 10，35，40，50，60，200 个数据元素，各表中的元素按升序排序。要求通过 5 次两两合并，将 6 个表最终合并为 1 个升序表，并使最坏情况下比较的总次数达到最小</p><p>思路：先合并的表中元素在后序的每次合并中都会再次参与比较，因此求最小合并次数类似于求最小带权路径长度，所以就考虑使用哈夫曼树进行运算</p><p>求最坏情况下的比较次数，利用两个有序表合并的最坏情况需要比较 m + n - 1 次来求</p><h2 id="注意" tabindex="-1"><a class="header-anchor" href="#注意" aria-hidden="true">#</a> 注意</h2><p>二叉树是极其重要的考点，关于二叉树的有关操作，出现了树的算法设计题</p><p>遍历时各种操作的基础，统考时会考查遍历过程对结点的各种操作</p><p><strong>需要重点掌握各种遍历方法的手写，如递归算法和利用栈或队列的非递归算法</strong></p>`,26),Ms=[_,M,T,L,N,S,B,I,E,U,P,O,q,Q,C,R,A,F,K,D,j,X,Z,Y,W,G,J,H,V,$,ss,ns,as,ts,ls,es,ps,is,cs,os,rs,ms,us,hs,gs,ds,ks,vs,ys,bs,ws,xs,fs,zs,_s];function Ts(Ls,Ns){return l(),e("div",null,Ms)}const Bs=t(z,[["render",Ts],["__file","第五章 树与二叉树.html.vue"]]);export{Bs as default};
