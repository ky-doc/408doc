import{_ as r,X as o,Y as g,a3 as n,a0 as s,a2 as t}from"./framework-cd5fce69.js";const i="/408doc/408noteImg/images/image-20211111224908120.png",a="/408doc/408noteImg/images/image-20211112132205564.png",l="/408doc/408noteImg/images/image-20211112133706111.png",e="/408doc/408noteImg/images/image-20211111225125773.png",p="/408doc/408noteImg/images/image-20211111232041170.png",c="/408doc/408noteImg/images/image-20211111232108565.png",h="/408doc/408noteImg/images/image-20211111232144689.png",d="/408doc/408noteImg/images/image-20211111232240726.png",m="/408doc/408noteImg/images/image-20211111232418494.png",u="/408doc/408noteImg/images/image-20211111232457932.png",f="/408doc/408noteImg/images/image-20211111232545922.png",x="/408doc/408noteImg/images/image-20211111232643969.png",_="/408doc/408noteImg/images/image-20211111232816798.png",b="/408doc/408noteImg/images/image-20211111232851361.png",y="/408doc/408noteImg/images/image-20211111232955044.png",z="/408doc/408noteImg/images/image-20211111233027685.png",w="/408doc/408noteImg/images/image-20211111233103169.png",I="/408doc/408noteImg/images/image-20211111233139262.png",M="/408doc/408noteImg/images/image-20211111233312557.png",k="/408doc/408noteImg/images/image-20211111233335202.png",C="/408doc/408noteImg/images/image-20211111233427333.png",v="/408doc/408noteImg/images/image-20211113205422298.png",L="/408doc/408noteImg/images/image-20211113205529519.png",B="/408doc/408noteImg/images/image-20211113224027924.png",O="/408doc/408noteImg/images/image-20211113224308406.png",P="/408doc/408noteImg/images/image-20211113224342794.png",U="/408doc/408noteImg/images/image-20211113224416563.png",F="/408doc/408noteImg/images/image-20211114165819204.png",K="/408doc/408noteImg/images/image-20211113224837075.png",S={},W=n('<h2 id="内存管理概念" tabindex="-1"><a class="header-anchor" href="#内存管理概念" aria-hidden="true">#</a> 内存管理概念</h2><h3 id="内存管理的基本原理和要求" tabindex="-1"><a class="header-anchor" href="#内存管理的基本原理和要求" aria-hidden="true">#</a> 内存管理的基本原理和要求</h3><p>不可能将全部程序与数据放入主存，因此<strong>操作系统必须对内存进行划分和动态分配</strong>，这就是内存管理的概念</p><p>有效的内存管理可以<u>方便用户使用存储器、提高内存利用率、通过虚拟技术从逻辑上扩充存储器</u></p><p>内存管理的功能有：</p><ul><li>内存空间的分配与回收：由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率</li><li>地址转换：程序中的逻辑地址与内存中的物理地址不一致，需要存储管理<strong>把逻辑地址转换成相应的物理地址</strong></li><li>内存空间的扩充：利用<strong>虚拟存储技术或自动覆盖技术，从逻辑上扩充内存</strong></li><li>存储保护：保证<strong>各道作业在各自的存储空间内运行</strong>，互不干扰</li></ul><h4 id="程序装入和链接" tabindex="-1"><a class="header-anchor" href="#程序装入和链接" aria-hidden="true">#</a> 程序装入和链接</h4><p>将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：</p><ul><li>编译：由编译程序<strong>将用户源代码编译成若干目标模块</strong></li><li>链接：由链接程序将编译后形成的<strong>一组目标模块及所需的库函数链接成一个完整的装入模块</strong>（如 <code>.exe</code> 文件）</li><li>装入：由装入程序<strong>将装入模块装入内存运行</strong></li></ul><figure><img src="'+i+'" alt="image-20211111224908120" tabindex="0" loading="lazy"><figcaption>image-20211111224908120</figcaption></figure><p>程序的链接有以下三种方式：</p><ul><li>静态链接：<strong>将各目标模块及它们所需的库函数链接成一个完整的可执行程序</strong></li><li>装入时动态链接：<strong>装入内存时，采用边装入边链接的方式</strong></li><li>运行时动态链接：在程序执行中<strong>需要目标模块时才进行链接</strong>；其优点是<strong>便于修改和更新和实现对目标模块的共享</strong></li></ul><p>内存的装入模块在装入内存时，同样有以下三种方式：</p><ol><li><p>绝对装入：</p><p>编译程序将<strong>产生绝对地址的目标代码</strong>，绝对装入程序<strong>按照装入模块中的地址装入内存</strong>，仅适用于<strong>单道程序环境</strong></p><p>通常程序员给出符号地址，让<strong>编译或汇编程序转换成绝对地址</strong>，也可由<strong>程序员直接给出绝对地址</strong></p></li><li><p>可重定位装入，静态重定向：<strong>只在装入时进行重定向</strong></p><p>在多道程序环境下，多个目标模块的<strong>起始地址通常都从 0 开始</strong>，程序中的<strong>其他地址相对于始址</strong></p><p><strong>根据内存的当前情况，装入内存的适当位置</strong>，装入时对指令和数据的修改过程（逻辑地址→物理地址）称为<strong>重定位</strong></p><figure><img src="'+a+'" alt="image-20211112132205564" tabindex="0" loading="lazy"><figcaption>image-20211112132205564</figcaption></figure><p>特点：</p><ul><li>作业装入内存时，必须给它分配要求的全部内存空间，若<strong>没有足够的内存，则不能装入该作业</strong></li><li>作业一旦进入内存，整个运行期间<strong>不能在内存中移动和再申请内存空间</strong></li></ul></li><li><p>动态运行时装入，动态重定位：<strong>在执行时才进行重定向</strong>，现代操作系统使用</p><p><u>程序在内存中若发生移动，则需要采用动态的装入方式</u>，这种方法<strong>需要一个重定位寄存器的支持</strong></p><figure><img src="'+l+'" alt="image-20211112133706111" tabindex="0" loading="lazy"><figcaption>image-20211112133706111</figcaption></figure><p>特点，这是需要在<strong>运行时进行地址转换</strong>才能做到的：</p><ul><li>可以<strong>将程序分配到不连续的存储区中</strong></li><li>在程序运行之前可以<strong>只装入它的部分代码</strong>即可投入运行，然后<strong>在程序运行期间，根据需要动态申请分配内存</strong></li><li><strong>便于程序段的共享</strong>，可以向用户<strong>提供一个比存储空间大得多的地址空间</strong></li></ul></li></ol><h4 id="逻辑地址空间与物理地址空间" tabindex="-1"><a class="header-anchor" href="#逻辑地址空间与物理地址空间" aria-hidden="true">#</a> 逻辑地址空间与物理地址空间</h4><p>编译后每个目标模块都<strong>从 0 号单元开始编址</strong>，这称为该目标模块的<strong>相对地址</strong>或<strong>逻辑地址</strong></p><p>链接程序将各个模块<strong>链接成一个完整的可执行程序后</strong>，就<strong>构成统一的从 0 号单元开始编址的逻辑地址空间</strong></p><p>用户程序和程序员<strong>只需知道逻辑地址</strong>；不同<strong>进程可以有相同的逻辑地址</strong>，因为会<strong>映射到主存的不同位置</strong></p><p><strong>物理地址是主存储器的地址</strong>，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取</p><h4 id="内存保护" tabindex="-1"><a class="header-anchor" href="#内存保护" aria-hidden="true">#</a> 内存保护</h4><p>内存保护是指：</p><ul><li><strong>保护操作系统不受用户进程的影响</strong></li><li><strong>保护用户进程不受其他用户进程的影响</strong></li></ul><p>内存保护可采取两种方法：</p><ol><li><p>在 CPU 中设置一对上、下限寄存器，<strong>每当 CPU 要访问一个地址时，分别和两个寄存器的值相比，判断有无越界</strong></p></li><li><p>采用重定位寄存器（或基址寄存器）和界地址寄存器（又称限长寄存器）来实现这种保护：</p><p>重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址的最大值，<strong>每个逻辑地址值必须小于界地址寄存器</strong></p><p>内存管理机构<strong>将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址</strong></p><figure><img src="'+e+'" alt="image-20211111225125773" tabindex="0" loading="lazy"><figcaption>image-20211111225125773</figcaption></figure></li></ol><h3 id="覆盖与交换" tabindex="-1"><a class="header-anchor" href="#覆盖与交换" aria-hidden="true">#</a> *覆盖与交换</h3><h4 id="覆盖" tabindex="-1"><a class="header-anchor" href="#覆盖" aria-hidden="true">#</a> 覆盖</h4><p>早期的计算机系统中，存储空间放不下一道用户进程的现象也经常发生，可以用覆盖技术来解决</p><p>覆盖的基本思想如下：</p><ul><li>把用户空间分成一个<u>固定区和若干覆盖区</u></li><li>将<u>经常活跃的部分放在固定区</u>，其余部分按调用关系分段</li><li>将<u>即将要访问的段放入对应的覆盖区替换其原有的内容，其他段放在外存中</u></li></ul><p>特点：</p><ul><li><u>不需要将一个进程的全部信息装入主存后才能运行</u>，但<u>同时运行程序的代码量大于主存时仍不能运行</u></li><li>内存中能够更新的地方只有覆盖区的段，<u>不在覆盖区中的段会常驻内存</u></li><li><u>需要程序员指明固定区和覆盖区</u>，增加了用户编程负担</li></ul><h4 id="交换" tabindex="-1"><a class="header-anchor" href="#交换" aria-hidden="true">#</a> 交换</h4><p>交换（对换）的基本思想是（中级调度采用的就是交换技术）：</p><ul><li>换出：把处于<u>等待状态的程序从内存移到辅存</u>，把内存空间腾出来</li><li>换入：把<u>准备好竞争 CPU 运行的程序从辅存移到内存</u></li></ul><p>有关交换，需要注意以下几个问题：</p><ul><li><p>交换需要备份存储，通常是快速磁盘</p></li><li><p>为了有效使用 CPU，需要使每个进程的执行时间比交换时间长</p></li><li><p>若换出进程，则必须确保该进程<u>完全处于空闲状态</u></p></li><li><p>交换空间通常作为磁盘的一整块，且独立于文件系统</p><p>磁盘有对换区和文件区，<u>文件区采用离散方式，对换区采用连续方式效率高</u></p></li><li><p><u>交换通常在有许多进程运行且内存空间吃紧时开始启动，而在系统负荷降低时就暂停</u></p></li><li><p>普通的交换使用不多，但交换策略的某些变体在许多系统中仍发挥作用，如 UNIX 系统</p></li></ul><p>选择题：若一个进程正在 I/O 操作，则不能交换出主存，但 OS 开辟 I/O 缓冲区后进程交换不受限制</p><p>选择题：可重入程序通过共享或动态链接来使用同一块存储空间，以减少对程序段的调出/调入，减少了对换数量</p><hr><p><u>交换技术主要在不同进程之间进行，而覆盖则用于同一个程序或进程中</u></p><p>对于主存无法存放用户程序的矛盾，<strong>现代操作系统是通过虚拟内存技术来解决</strong>的</p><p>覆盖技术则已成为历史，而交换技术在现代操作系统中仍具有较强的生命力</p><h3 id="连续分配管理方式" tabindex="-1"><a class="header-anchor" href="#连续分配管理方式" aria-hidden="true">#</a> 连续分配管理方式</h3><p>连续分配方式是指<strong>为一个用户程序分配一个连续的内存空间</strong></p><p>连续分配方式主要包括单一连续分配、固定分区分配、动态分区分配：</p><h4 id="单一连续分配" tabindex="-1"><a class="header-anchor" href="#单一连续分配" aria-hidden="true">#</a> 单一连续分配</h4><p>内存分为<strong>系统区和用户区，系统区在低地址部分</strong>，这种方式<strong>无须进行内存保护</strong>（单任务不需要保护）</p><p>优点：简单、<strong>无外部碎片</strong>，可以采用覆盖技术，<strong>不需要额外的技术支持</strong></p><p>缺点：只能用于<strong>单用户、单任务</strong>的操作系统中，<strong>有内部碎片，存储器的利用率极低</strong></p><h4 id="固定分区分配" tabindex="-1"><a class="header-anchor" href="#固定分区分配" aria-hidden="true">#</a> 固定分区分配</h4><p>最简单的一种多道程序存储管理方式，<strong>将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业</strong></p><p>使用：每当有空闲分区时，便可再从外存的后备作业队列中选择适当大小的作业装入该分区</p><p>固定分区分配在划分分区时有两种不同的方法：</p><ul><li>分区大小相等：<strong>用于利用一台计算机去控制<u>多个相同对象的场合</u></strong>，缺乏灵活性</li><li>分区大小不等：划分为<u>多个较小的分区、适量的中等分区和少量大分区</u></li></ul><figure><img src="'+p+'" alt="image-20211111232041170" tabindex="0" loading="lazy"><figcaption>image-20211111232041170</figcaption></figure><p>为便于内存分配，通常将分区<strong>按大小排队</strong>，并为之建立一张分区说明表，其中各表项包括<strong>每个分区的始址、大小及状态</strong></p><p>有程序要装入时，检索该表<strong>找到合适的分区给予分配并将其状态置为已分配，未找到合适分区时，则拒绝分配</strong></p><figure><img src="'+c+'" alt="image-20211111232108565" tabindex="0" loading="lazy"><figcaption>image-20211111232108565</figcaption></figure><p>这种分区方式存在几个问题：</p><ol><li><strong>程序可能太大而放不进任何一个分区中</strong>，这时用户不得不使用覆盖技术来使用内存空间</li><li>主存利用率低，<strong>程序小于固定分区时也占整个固定分区</strong>，这种现象称为<strong>内部碎片</strong></li><li><strong>不能实现多进程共享一个主存区</strong>，存储空间利用率低</li></ol><h4 id="动态分区分配" tabindex="-1"><a class="header-anchor" href="#动态分区分配" aria-hidden="true">#</a> 动态分区分配</h4><p>又称<strong>可变分区分配</strong>，<strong>在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要</strong></p><p>如下图，首先装入三个进程，在某个时刻 CPU 出现空闲，换出进程 2 换入进程 4，中间产生了内存块；CPU 又空闲...</p><figure><img src="'+h+'" alt="image-20211111232144689" tabindex="0" loading="lazy"><figcaption>image-20211111232144689</figcaption></figure><p>动态分区会<strong>导致内存中出现许多小的内存块</strong>，随着时间的推移，内存中会产生越来越多的碎片，<strong>内存的利用率随之下降</strong></p><p>这些小的内存块称为<strong>外部碎片</strong>，可以通过紧凑 Compaction 技术来解决，即<strong>把动态分区移动到一起</strong>，但这<strong>需要动态重定位寄存器的支持</strong>，且相对费时</p><p>分配策略：内存中<strong>有多个足够大的空闲块</strong>，操作系统必须<strong>确定分配哪个内存块给进程使用</strong>，有以下几种算法：</p><ol><li><p>首次适应 First Fit 算法：空闲分区<strong>以地址递增的次序链接</strong>，分配内存时顺序查找，分配<strong>大小能满足要求的第一个空闲分区</strong></p><p>会使内存的<strong>低地址部分出现很多小的空闲分区</strong>，查找时都要经过这些分区，因此<strong>增加了查找的开销</strong></p><p>首次适应算法不仅是最简单的，而且通常也是<strong>最好和最快</strong>的</p></li><li><p>最佳适应 Best Fit 算法：空闲分区<strong>按容量递增的方式形成分区链</strong>，分配<strong>第一个能满足要求的空闲分区</strong></p><p>每次最佳的分配会留下很小的难以利用的内存块，会<strong>产生最多的外部碎片，性能很差</strong></p></li><li><p>最坏适应 Worst Fit，最大适应 Largest Fit 算法：空闲分区<strong>以容量递减的次序链接</strong>，分配<strong>第一个能满足要求的空闲分区</strong></p><p>总把最大的连续内存划分开，会<strong>很快导致没有可用的大内存块，性能非常差</strong></p></li><li><p>邻近适应 Next Fit，循环首次适应算法：与首次适应算法相比，分配内存时<strong>从上次查找结束的位置开始继续查找</strong></p><p>虽然查找链表的次数快了，但<strong>不能形成较大的空闲分区</strong>，当有程序需要较大的内存时不能满足，通常<strong>比首次适应法差</strong></p></li></ol><p>注意：<strong>空闲分区可以使用数组或链表来管理</strong>；实验表明<strong>首次适应 &gt; 最佳适应法 &gt; 最大适应法</strong></p><p>注意：在回收操作中，当<strong>回收的块与原来的空闲块相邻时，需要将这些块合并</strong>；算法开销也是需要考虑的一个因素</p><figure><img src="'+d+'" alt="image-20211111232240726" tabindex="0" loading="lazy"><figcaption>image-20211111232240726</figcaption></figure><h3 id="非连续分配管理方式" tabindex="-1"><a class="header-anchor" href="#非连续分配管理方式" aria-hidden="true">#</a> 非连续分配管理方式</h3><p>非连续分配<strong>允许一个程序分散地装入不相邻的内存分区</strong>，但这也<strong>需要额外的空间去存储分散区域的索引</strong>，使得<strong>非连续分配方式的存储密度低于连续存储方式的存储密度</strong></p><p>非连续分配管理方式<strong>根据分区的大小是否固定</strong>，分为<u>分页存储管理方式和分段存储管理方式</u>；在分页存储管理方式中，又<strong>根据运行作业时是否要把作业的所有页面都装入内存才能运行</strong>，分为<u>基本分页存储管理方式和请求分页存储管理方式</u></p><h4 id="基本分页存储管理方式" tabindex="-1"><a class="header-anchor" href="#基本分页存储管理方式" aria-hidden="true">#</a> 基本分页存储管理方式</h4><p>为了内存的使用能尽量避免碎片的产生，引入了分页的思想：</p><ul><li>把<strong>主存空间划分为大小相等且固定的块</strong>，块相对较小，作为<strong>主存的基本单位</strong></li><li>每个<strong>进程也以块为单位进行划分</strong>，进程在执行时，<strong>以块为单位逐个申请主存中的块空间</strong></li></ul><p>进程只会在为最后一个不完整的块申请一个主存块空间时，才产生主存碎片，所以尽管会产生内部碎片，但这种碎片相对于进程来说也是很小的，<strong>每个进程平均只产生半个块大小的内部碎片（也称页内碎片）</strong></p><h5 id="分页存储的几个基本概念" tabindex="-1"><a class="header-anchor" href="#分页存储的几个基本概念" aria-hidden="true">#</a> 分页存储的几个基本概念</h5><ol><li><p>页面和页面大小：</p><p><strong>进程中的块称为页</strong> Page 或页面，<strong>内存中的块称为页框</strong> Page Frame 或页帧，<strong>外存直接称为块</strong> Block</p><p>进程在执行时要<strong>为每个页面分配主存中的可用页框</strong>，这就产生了页和页框的一一对应</p><p><strong>页面大小应是 2 的整数幂</strong>，同时页面大小应该适中：</p><ul><li><p>页面太小会使进程的页面数过多，这样<strong>页表就会过长</strong>，占用大量内存</p><p>也会增加硬件地址转换的开销，降低页面换入/换出的效率（<strong>即频繁换页</strong>）</p></li><li><p>页面过大又会使<strong>页内碎片增多</strong>，降低内存的利用率</p></li></ul><p>选择题：操作系统的内存分页大小一旦确定，所有的页面就是等长的，无论在哪台电脑装（应该）</p></li><li><p>地址结构：</p><figure><img src="'+m+'" alt="image-20211111232418494" tabindex="0" loading="lazy"><figcaption>image-20211111232418494</figcaption></figure><p>地址结构包含两部分：前一部分为<strong>页号 P</strong>，后一部分为<strong>页内偏移量 W</strong></p><p>注意：<strong>地址结构决定了虚拟内存的寻址空间有多大</strong></p></li><li><p>页表：</p><p>系统<strong>为每个进程建立一张页表</strong>来实现<strong>从页号到物理块号的地址映射</strong>，<strong>页表总是存放在内存中</strong></p><p><strong>页表是由页表项组成</strong>的，页表项由<strong>页号和物理内存中的块号</strong>组成；<strong>物理内存块号和页内偏移量共同组成物理地址</strong></p></li></ol><figure><img src="'+u+'" alt="image-20211111232457932" tabindex="0" loading="lazy"><figcaption>image-20211111232457932</figcaption></figure><h5 id="基本地址变换机构" tabindex="-1"><a class="header-anchor" href="#基本地址变换机构" aria-hidden="true">#</a> 基本地址变换机构</h5><p>地址变换机构的任务是<strong>将逻辑地址转换为内存中的物理地址</strong>，地址变换是借助于页表实现的</p><figure><img src="'+f+'" alt="image-20211111232545922" tabindex="0" loading="lazy"><figcaption>image-20211111232545922</figcaption></figure><p>通常设置一个<strong>页表寄存器 PTR</strong>，存放<strong>页表在内存的起始地址</strong> F 和<strong>页表长度</strong> M</p><p>进程<strong>未执行时</strong>，页表的始址和长度存<strong>放在进程控制块 PCB 中</strong>；进程<strong>执行时</strong>，才<strong>将页表始址和长度存入页表寄存器</strong></p><p>设页面大小为 L，逻辑地址 A 到物理地址 E 的变换过程如下：</p><ol><li><p>计算<strong>页号 P=A / L</strong> 和<strong>页内偏移量 W = A % L</strong></p></li><li><p>比较页号 Р 和页表长度 M，<strong>若 P ≥ M，则产生越界中断，否则继续执行</strong></p></li><li><p><strong>页表项地址 = 页表始址 F＋页号 P × 页表项长度</strong>，根据表项地址<strong>取出物理块号 b</strong></p><p>注意：页表长度的值是指<strong>一共有多少页</strong>，页表项长度是指<strong>页地址占多大的存储空间</strong></p></li><li><p>计算<strong>物理地址 E = b × L + W</strong>，用得到的物理地址去访问内存</p></li></ol><p>以上<strong>整个地址变换过程均是由硬件自动完成</strong></p><p>页式管理<strong>只需给出一个整数就能确定对应的物理地址</strong>（页面大小固定），因此<strong>页式管理中地址空间是一维的</strong></p><p>以 32 位逻辑地址空间、字节编址单位、一页 <code>4KB</code> 为例，确定页表项的大小：</p>',91),A=s("ol",null,[s("li",null,[s("code",null,"4KB"),t(" 共需要 12 位表示，剩下的 20 位用于表示页号的范围")]),s("li",null,[t("因为以字节作为编址单位，页表项的大小 ≥ "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"⌈"),s("mn",null,"20"),s("mi",{mathvariant:"normal"},"/"),s("mn",null,"8"),s("mo",{stretchy:"false"},"⌉"),s("mo",null,"="),s("mn",null,"3"),s("mi",null,"B")]),s("annotation",{encoding:"application/x-tex"},"\\lceil20/8\\rceil =3B")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"⌈"),s("span",{class:"mord"},"20/8"),s("span",{class:"mclose"},"⌉"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord"},"3"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05017em"}},"B")])])]),t("，页表项"),s("strong",null,"至少"),t("是 "),s("code",null,"3B")]),s("li",null,[t("为了"),s("strong",null,"存储方便和放额外信息"),t("，可以页表项可以"),s("strong",null,"取大点"),t("如 "),s("code",null,"4B"),t("，这样一页正好装下 "),s("code",null,"1K"),t(" 个页表项")])],-1),N=n('<p>下面讨论分页管理方式存在的两个主要问题：</p><ol><li>每次访存操作都需要进行地址转换，<strong>地址转换过程必须足够快，否则访存速度会降低</strong></li><li>每个进程引入页表，用于存储映射机制，<strong>页表不能太大，否则内存利用率会降低</strong></li></ol><h5 id="具有快表的地址变换机构" tabindex="-1"><a class="header-anchor" href="#具有快表的地址变换机构" aria-hidden="true">#</a> 具有快表的地址变换机构</h5><p>若页表全部放在内存中，则存取一个数据或一条指令<strong>至少要访问两次内存</strong>，这种方法比通常执行指令的速度慢了一半</p><p>在地址变换机构中<strong>增设快表 TLB</strong>，存放若干页表项以<strong>加速地址变换的过程</strong>，而<strong>主存中的页表常称为慢表</strong></p><figure><img src="'+x+'" alt="image-20211111232643969" tabindex="0" loading="lazy"><figcaption>image-20211111232643969</figcaption></figure><p>在具有快表的分页机制中，地址的变换过程如下：</p><ol><li>CPU 给出逻辑地址后，由硬件进行地址转换，<strong>将此页号与快表中的所有页号同时进行比较</strong></li><li>若找到匹配的页号，则直接<strong>从快表中取出该页对应的页框号，形成物理地址</strong>（一次访存）</li><li>若未找到匹配的页号，则在内存中<strong>读出页表项，将其存入快表</strong>，若快表已满按照某算法进行替换</li></ol><p>注意：有些处理机设计为<u>快表和慢表同时查找</u>，若<u>在快表中查找成功则终止慢表的查找</u>，<strong>题目没写一般不是这种</strong></p><p>注意：快表访问成功<u>仍需访问一次内存</u>；快慢表非同时查找时，不管快表访问成不成功<u>访问快表的时间都要消耗</u></p><p>由于基于局部性原理，快表的命中率可达 90% 以上，这样分页带来的速度损失就可降低至 10% 以下</p><h5 id="两级页表" tabindex="-1"><a class="header-anchor" href="#两级页表" aria-hidden="true">#</a> 两级页表</h5><p>引入分页管理后，进程在<strong>执行时不需将所有页调入内存页框</strong>，<strong>只需将保存有映射关系的页表调入内存</strong>，但仍需考虑页表大小</p><p>一个 <code>40MB</code> 的进程它需要 10 页框来保存页表，但是它实际执行时可能只需要几十个页框就可运行：</p><ul><li>若要求 10 个页面大小的页表必须全部进入内存，相对于几十个页框来说，<strong>降低了内存利用率</strong></li><li>在大多数情况下，<strong>映射所需要的页表项都在页表的同一个页面中</strong>，没必要 10 个页表都在内存</li><li>需要<strong>连续</strong>的 10 个页框空间来存放页表，系统内可能找不到这么大的连续空间</li></ul><p>注意：<strong>一般进程需要全部地址映射</strong>，单页表就需要 <code>4MB</code>，因为一般程序会用到高位和低位地址，如栈在高位，代码在低位</p><p>为了减少页表占用空间，进一步延申页表映射思想，得到了二级页表，<strong>对页表也进行地址映射，建立上一级页表，来存储页表的映射关系</strong>，以下是二级页表的逻辑地址空间的格式（为查询方便，<strong>顶级页表只能有 1 个页面</strong>）</p><figure><img src="'+_+'" alt="image-20211111232816798" tabindex="0" loading="lazy"><figcaption>image-20211111232816798</figcaption></figure><p>例如：页面大小为 <code>4KB</code>，页内偏移地址为 12位，页号部分为 20 位，顶级页表可以放 <code>4KB / 4B = 1024</code> 个表项，占 10 位，因此逻辑地址空间就剩下了 10 位，二级页表的大小正好在一页之内，这样就得到了 10 10 12 的格式</p><figure><img src="'+b+'" alt="image-20211111232851361" tabindex="0" loading="lazy"><figcaption>image-20211111232851361</figcaption></figure><p>建立多级页表的目的在于建立索引，以便<strong>不用浪费主存空间去存储无用的页表项</strong>，也<strong>不用盲目地顺序式查找页表项</strong></p><p>思考：若采用二级页表，当程序挂起时，最高一级页表必须在内存；运行时仅需要用到的二级页表在内存</p><h4 id="基本分段存储管理方式" tabindex="-1"><a class="header-anchor" href="#基本分段存储管理方式" aria-hidden="true">#</a> 基本分段存储管理方式</h4><p>分段管理方式<strong>为考虑了用户和程序员而提出</strong>，以满足<strong>方便编程、信息保护和共享、动态增长、动态链接</strong>等多方面的需要</p><p>额外：分段后汇编语句：Load [D] | &lt;A&gt; 把 D 段的 A 加载，这样编程更方便，可读性更高</p><p>额外：分页用户不可见，而分段用户可见；段内必须连续导致段太长时找不到连续空间</p><h5 id="分段" tabindex="-1"><a class="header-anchor" href="#分段" aria-hidden="true">#</a> 分段</h5>',27),R=s("p",null,[t("段式管理方式"),s("strong",null,"按照用户进程中的自然段划分逻辑空间"),t("，每段"),s("strong",null,"从 0 开始编址"),t("，并分配一段"),s("strong",null,"连续的地址空间"),t("，其逻辑地址由"),s("strong",null,"段号"),t(" S 与"),s("strong",null,"段内偏移量"),t(" W 两部分组成，"),s("strong",null,[t("最多拥有 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mi",null,"S")])]),s("annotation",{encoding:"application/x-tex"},"2^S")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8413em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8413em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.05764em"}},"S")])])])])])])])])])]),t(" 个段号，每段最长 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mi",null,"W")])]),s("annotation",{encoding:"application/x-tex"},"2^W")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8413em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8413em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.13889em"}},"W")])])])])])])])])])])])],-1),D=n('<figure><img src="'+y+'" alt="image-20211111232955044" tabindex="0" loading="lazy"><figcaption>image-20211111232955044</figcaption></figure><p>在段式系统中，<strong>段号和段内偏移量必须由用户显式提供</strong>，在<u>高级程序设计语言中，这个工作由编译程序完成</u></p><h5 id="段表" tabindex="-1"><a class="header-anchor" href="#段表" aria-hidden="true">#</a> 段表</h5><p>每个进程都有一张段表，<strong>用于实现从逻辑段到物理内存区的映射</strong>，其中<strong>每个段表项对应进程的一段</strong></p><p>段表项由<strong>段号、段基址、段长</strong>组成，每个段表项<strong>长度相同</strong>，<strong>段长位数和逻辑地址中的段长一样，基址位数和内存大小一样</strong></p><figure><img src="'+z+'" alt="image-20211111233027685" tabindex="0" loading="lazy"><figcaption>image-20211111233027685</figcaption></figure><p>这是进程的段与物理内存的映射关系：</p><figure><img src="'+w+'" alt="image-20211111233103169" tabindex="0" loading="lazy"><figcaption>image-20211111233103169</figcaption></figure><h5 id="地址变换机构" tabindex="-1"><a class="header-anchor" href="#地址变换机构" aria-hidden="true">#</a> 地址变换机构</h5><figure><img src="'+I+'" alt="image-20211111233139262" tabindex="0" loading="lazy"><figcaption>image-20211111233139262</figcaption></figure><p>为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了<strong>段表寄存器</strong>，用于存放<strong>段表始址</strong> F 和<strong>段表长度</strong> M</p><p>从逻辑地址 A 到物理地址 E 之间的地址变换过程如下：</p><ol><li>从逻辑地址 A 中取出前几位为段号 S，后几位为段内偏移量 W</li><li>比较段号 S 和段表长度 M，<strong>若 S ≥ M，则产生越界中断，否则继续执行</strong></li><li><strong>段表项地址 = 段表始址 F＋段号 S × 段表项长度</strong></li><li>从段表项取出段长 C，<strong>若段内偏移量 ≥ C，则产生越界中断，否则继续执行</strong></li><li>从段表项取出该段的始址 b，计算<strong>物理地址 E = b + W</strong>，用得到的物理地址去访问内存</li></ol><h5 id="段的共享与保护" tabindex="-1"><a class="header-anchor" href="#段的共享与保护" aria-hidden="true">#</a> 段的共享与保护</h5><p>段的共享是通过<strong>两个作业的段表中相应表项指向被共享的段的同一个物理副本</strong>来实现的</p><p>当一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据，因此：</p><p><strong>不能修改的代码</strong>称为纯代码或可重入代码，这样的代码和<strong>不能修改的数据可以共享</strong>，而<strong>可修改的代码和数据不能共享</strong></p><p>分段管理的保护方法主要有两种：</p><ol><li><strong>存取控制保护</strong>：访问内存时查看段表项的保护码检查是否有该操作的权限</li><li><strong>地址越界保护</strong>：校验段号和段内地址偏移，保证不会访问过界</li></ol><p><strong>访问内存时要给出段号和段内偏移，因此分段管理的地址空间是二维的</strong></p><h4 id="段页式管理方式" tabindex="-1"><a class="header-anchor" href="#段页式管理方式" aria-hidden="true">#</a> 段页式管理方式</h4><p>段页式存储管理方式是<strong>页式存储和分段存储的结</strong>合，即<strong>有效地提高内存利用率</strong>，又<strong>反映程序的逻辑结构并有利于段的共享</strong></p><p>在段页式系统中，作业的地址空间首<strong>先被分成若干逻辑段</strong>，每段都有自己的段号，<strong>再将每段分成若干大小固定的页</strong></p><p>对<strong>内存空间的管理仍然和分页存储管理一样</strong>，将其分成若干和页面大小相同的存储块，对内存的分配以存储块为单位</p><figure><img src="'+M+'" alt="image-20211111233312557" tabindex="0" loading="lazy"><figcaption>image-20211111233312557</figcaption></figure><p>在段页式系统中，作业的逻辑地址分为三部分：<strong>段号、页号、页内偏移量</strong></p><figure><img src="'+k+'" alt="image-20211111233335202" tabindex="0" loading="lazy"><figcaption>image-20211111233335202</figcaption></figure><p>系统为<strong>每个进程建立一张段表，每个分段有一张页表</strong>：段表表项中至少包括<strong>段号、页表长度和页表始址</strong>；页表表项中至少包括<strong>页号和块号</strong>。系统中有一个<strong>段表寄存器</strong>，指出作业的<strong>段表始址和段表长度</strong></p><p>进行地址变换步骤：</p><ol><li>通过段表查到页表始址</li><li>通过页表找到页帧号</li><li>形成物理地址</li></ol><p>进行<strong>一次访问实际需要三次访问主存</strong>，可以使用快表来加快查找速度，其<strong>关键字由段号、页号组成</strong>，<strong>值是页帧号和保护码</strong></p><figure><img src="'+C+'" alt="image-20211111233427333" tabindex="0" loading="lazy"><figcaption>image-20211111233427333</figcaption></figure><p><strong>访问内存时要给出段号和页号，因此段页式管理的地址空间是二维的</strong></p><h2 id="虚拟内存管理" tabindex="-1"><a class="header-anchor" href="#虚拟内存管理" aria-hidden="true">#</a> 虚拟内存管理</h2><h3 id="虚拟内存的基本概念" tabindex="-1"><a class="header-anchor" href="#虚拟内存的基本概念" aria-hidden="true">#</a> 虚拟内存的基本概念</h3><h4 id="传统存储管理方式的特征" tabindex="-1"><a class="header-anchor" href="#传统存储管理方式的特征" aria-hidden="true">#</a> 传统存储管理方式的特征</h4><p>指上一节的存储管理方式，它们具有以下两个共同的特征：</p><ol><li>一次性：<strong>作业必须一次性全部装入内存后，才能开始运行</strong>这导致： <ul><li>当<u>作业很大而不能全部被装入内存</u>时，将使该作业无法运行</li><li>当<u>大量作业要求运行时，内存不足以容纳所有作业</u>，只能使少数作业先运行，导致多道程序度的下降</li></ul></li><li>驻留性：作业被装入内存后，<strong>不会换出任何内存，直至作业运行结束</strong>，即使进程会因等待 I/O 而被阻塞</li></ol><p>程序运行中<strong>暂时不用的程序或数据占据大量的内存空间</strong>，而一些需要运行的作业又无法装入运行，浪费了内存资源</p><h4 id="局部性原理" tabindex="-1"><a class="header-anchor" href="#局部性原理" aria-hidden="true">#</a> 局部性原理</h4><p><u>快表、页高速缓存、虚拟内存技术</u>从广义上讲，都属于高速缓存技术，其<u>所依赖的原理是局部性原理</u></p><p>局部性原理适用于程序结构和数据结构，它表现在以下两个方面：</p><ol><li><p>时间局部性：</p><ul><li>某条指令一旦执行，不久后<strong>该指令可能再次执行</strong></li><li>某数据被访问过，不久后该<strong>数据可能再次被访问</strong></li></ul><p>将近来使用的指令和数据保存到高速缓冲存储器中，并使用高速缓存的层次结构实现</p></li><li><p>空间局部性：一旦程序访问了某个存储单元，在不久后，其<strong>附近的存储单元也将被访问</strong></p><p>使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现</p></li></ol><p>虚拟内存技术就是<strong>使用内存对外存进行高速缓存</strong>，使得有外存的容量和内存的速度，<strong>利用局部性原理实现</strong></p><h4 id="虚拟存储器的定义和特征" tabindex="-1"><a class="header-anchor" href="#虚拟存储器的定义和特征" aria-hidden="true">#</a> 虚拟存储器的定义和特征</h4><p>根据局部性原理得：</p><ol><li>程序的<strong>一部分装入内存，就可启动程序执行</strong></li><li>程序执行过程中，所访问的信息<strong>不在内存时，将其调入内存继续执行</strong></li><li>OS 将<strong>暂时不使用的内容换出到外存上，腾出空间放要调入内存的信息</strong></li></ol><p>这样，系统似乎给用户提供了一个比实际内存大得多的存储器，称为<strong>虚拟存储器</strong>（实际上不存在）</p><p>这是由系统提供了对用户透明的<u>部分装入、请求调入、置换功能</u>实现的</p><ul><li><strong>虚拟内存的实际容量 ≤ 内存容量和外存容量之和</strong></li><li><strong>虚拟内存的最大容量 ≤ 计算机的地址位数能容乃的最大容量</strong></li></ul><p>虚拟存储器有以下三个主要特征：</p><ol><li>多次性：无须在作业运行时一次性地全部装入内存，而<strong>允许被分成多次调入内存运行</strong></li><li>对换性：无须在作业运行时一直常驻内存，而<strong>允许在作业的运行过程中，进行换进和换出</strong></li><li>虚拟性：从逻辑上扩充内存的容量，使<strong>用户所看到的内存容量远大于实际的内存容量</strong></li></ol><h4 id="虚拟内存技术的实现" tabindex="-1"><a class="header-anchor" href="#虚拟内存技术的实现" aria-hidden="true">#</a> 虚拟内存技术的实现</h4><p><strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上</strong>，否则将作业分多次调入内存时，难以分配连续内存</p><p>虚拟内存的实现有<strong>以下三种方式</strong>：</p><ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ul><p>不管哪种方式，都需要有一定的硬件支持，一般需要：</p><ul><li>一定容量的<strong>内存和外存</strong></li><li><strong>页表机制或段表机制</strong>，作为主要的数据结构</li><li><strong>中断机构</strong>，当用户程序要访问的部分尚未调入内存时，则产生中断</li><li><strong>地址变换机构</strong>，逻辑地址到物理地址的变换</li></ul><h3 id="请求分页管理方式" tabindex="-1"><a class="header-anchor" href="#请求分页管理方式" aria-hidden="true">#</a> 请求分页管理方式</h3><p>在基本分页系统基础之上，增加了<strong>请求调页功能和页面置换功能</strong>，从而支持虚拟存储器功能</p><p>在请求分页管理方式中：</p><ol><li>只需将<u>当前需要的一部分页面装入内存</u>，便可以启动作业运行</li><li>在作业执行过程中，<u>要访问的页面不在内存中时，通过调页功能将其调入</u></li><li>还可通过置换功能<u>将暂时不用的页面换出到外存上，以便腾出内存空间</u></li></ol><p>为了实现请求分页需要：<strong>一定容量的内存及外存、页表机制、缺页中断机构、地址变换机构</strong></p><h4 id="页表机制" tabindex="-1"><a class="header-anchor" href="#页表机制" aria-hidden="true">#</a> 页表机制</h4><p>因为没有一次加载进内存，请求分页系统必须解决的两个基本问题：<strong>如何发现和处理要访问的页面不在内存中的情况</strong></p><p>因此在请求页表项中增加了 4 个字段：</p><figure><img src="'+v+'" alt="image-20211113205422298" tabindex="0" loading="lazy"><figcaption>image-20211113205422298</figcaption></figure><ul><li>状态位 P：指示<strong>该页是否已调入内存</strong>，供程序访问时参考</li><li>访问字段 A：记录本页在一段时间内被访问的次数或多长时间未被访问，<strong>供置换算法换出页面时参考</strong></li><li>修改位 M：标识该页在<strong>调入内存后是否被修改过</strong></li><li>外存地址：用于指出该页<strong>在外存上的地址</strong>，供调入该页时参考，通常和物理块号共用</li></ul><p>思考：当程序被挂起时，把页面都调到外存，并修改页表的物理块号，令其为外存地址；这样可以只留最高级页表在内存</p><h4 id="缺页中断机构" tabindex="-1"><a class="header-anchor" href="#缺页中断机构" aria-hidden="true">#</a> 缺页中断机构</h4><p>在请求分页系统中，每当所要访问的页面不在内存中时：</p><ol><li><strong>产生一个缺页中断</strong>，请求操作系统将所缺的页调入内存</li><li><strong>将缺页的进程阻塞</strong>，调页完成后唤醒</li><li>若没有空闲块，则要<strong>淘汰某页</strong>，若其<strong>修改位为 1，则要将其写回外存</strong>，此时有空闲块</li><li><strong>分配一个空闲块</strong>，将要调入的页装入该块，并<strong>修改页表中的相应页表项</strong></li></ol><p>缺页中断与一般的中断相比，有以下不同的区别:</p><ul><li>在<strong>指令执行期间产生和处理中断信号</strong>，属于<strong>内部中断</strong></li><li>一条指令在执行期间，可能<strong>产生多次缺页中断</strong></li><li>执行完中断后会<strong>回到引发中断的指令重新执行</strong></li></ul><h4 id="地址变换机构-1" tabindex="-1"><a class="header-anchor" href="#地址变换机构-1" aria-hidden="true">#</a> 地址变换机构</h4><p>请求分页系统中的地址变换机构，是<strong>在分页系统地址变换机构的基础上</strong>，为实现虚拟内存又<strong>增加了某些功能</strong>而形成的</p><figure><img src="'+L+'" alt="image-20211113205529519" tabindex="0" loading="lazy"><figcaption>image-20211113205529519</figcaption></figure><p>一般来说<strong>只需修改快表中的数据</strong>，只有要将<strong>快表项删除时才需要写回内存中的慢表</strong></p><ol><li>快表当查询成功时，要<strong>修改访问位，写指令要额外修改修改位</strong>，最后<strong>计算出物理地址</strong>，而失败时去慢表查找</li><li>慢表找到表项后检查状态位，若<strong>在内存将表项复制到快表</strong>转步骤 1，若<strong>在外存产生缺页中断</strong></li><li>页面调入内存后，需要<strong>修改慢表</strong>，同时也需要<strong>将表项复制到快表中</strong>，转步骤 1</li></ol><h3 id="页面置换算法" tabindex="-1"><a class="header-anchor" href="#页面置换算法" aria-hidden="true">#</a> 页面置换算法</h3><p>页面对换时，若内存已无空闲空间，就需要<strong>使用页面置换算法从内存中调出一页程序或数据</strong>到外存</p><p>好的页面置换算法应有较低的页面更换频率，应将<strong>以后或较长时间内不会再访问的页面先调出</strong></p><h4 id="最佳-opt-置换算法" tabindex="-1"><a class="header-anchor" href="#最佳-opt-置换算法" aria-hidden="true">#</a> 最佳 OPT 置换算法</h4><p>最佳置换算法：被淘汰页面是<strong>永不使用或最长时间内不再被访问</strong>的页面，<strong>缺页率最低</strong>，因无法预知未来<strong>该算法无法实现</strong></p><p>最佳置换算法<strong>用来评价其他算法</strong>；下面是例子有 3 个物理块，和页面引用串，<strong>每次置换出最晚访问的页面</strong>：</p><figure><img src="'+B+'" alt="image-20211113224027924" tabindex="0" loading="lazy"><figcaption>image-20211113224027924</figcaption></figure><h4 id="先进先出-fifo-页面置换算法" tabindex="-1"><a class="header-anchor" href="#先进先出-fifo-页面置换算法" aria-hidden="true">#</a> 先进先出 FIFO 页面置换算法</h4><p>优先<strong>淘汰最早进入内存的页面</strong>；该算法<strong>与进程实际运行时的规律不适应</strong>，进入内存的时间和以后是否访问没有关系</p><p>下面是例子，数据和上面的一样，但这里进行了 12 次页面置换：</p><figure><img src="'+O+'" alt="image-20211113224308406" tabindex="0" loading="lazy"><figcaption>image-20211113224308406</figcaption></figure><p>Belady 异常：产生所分配的<strong>物理块数增大而页故障数不减反增</strong>的异常现象，<strong>只有 FIFO 算法可能出现 Belady 异常</strong></p><p>下面是 Belady 的例子，物理块增大了，但缺页次数不减反增：</p><figure><img src="'+P+'" alt="image-20211113224342794" tabindex="0" loading="lazy"><figcaption>image-20211113224342794</figcaption></figure><h4 id="最近最久未使用-lru-置换算法" tabindex="-1"><a class="header-anchor" href="#最近最久未使用-lru-置换算法" aria-hidden="true">#</a> 最近最久未使用 LRU 置换算法</h4><p>淘汰<strong>最近最长时间未访问过的页面</strong>，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问</p><p>该算法为每个页面<strong>设置一个访问字段</strong>，记录页面自上次被访问以来所经历的时间，淘汰时<strong>选择现有页面中值最大的予以淘汰</strong></p><figure><img src="'+U+'" alt="image-20211113224416563" tabindex="0" loading="lazy"><figcaption>image-20211113224416563</figcaption></figure><p>LRU 算法是向前看的，最佳置换算法是向后看的；LRU 算法的性能较好，但<strong>需要寄存器和栈的硬件支持</strong></p><p>LRU 是堆栈类的算法，<strong>堆栈类算法不可能出现 Belady 异常</strong></p><h4 id="时钟-clock-置换算法" tabindex="-1"><a class="header-anchor" href="#时钟-clock-置换算法" aria-hidden="true">#</a> 时钟 CLOCK 置换算法</h4><p>CLOCK 算法给每帧关联一个附加位，称为<strong>使用位</strong>：</p><ol><li>当某页<strong>首次装入主存或再被访问</strong>时，将该帧的<strong>使用位设置为 1</strong></li><li>有一个指针指向用于替换的候选帧集合（看作循环缓冲区），<strong>一页被替换时，指针指向下一帧</strong></li><li>需要替换一页时，<strong>从指针位置开始循环查找</strong>，找出<strong>使用位为 0 的来替换</strong>，把<strong>跳过的帧的使用位 1 的帧置为 0</strong></li></ol><p>因为算法要<strong>循环扫描缓冲区</strong>，像时钟的指针一样转动，所以称为 CLOCK 算法，又称<strong>最近未用 NRU 算法</strong></p><p>CLOCK 算法的性能比较接近 LRU 算法，而通过增加使用的位数目，可以使得 CLOCK 算法更加高效</p><p>下面使用一个例子来详细说明 CLOCK 算法：</p><figure><img src="'+F+'" alt="image-20211114165819204" tabindex="0" loading="lazy"><figcaption>image-20211114165819204</figcaption></figure><p>进程依次访问 1, 3, 4, 2, 5 号页面，系统会将这些页面连成一个循环队列，刚开始扫描指针指向第一个被访问的页面，如图 a</p><p>进程请求访问 6 号页面，选择一个页面置换出去，在第一轮扫描中，指针扫过的页面的使用位置为 0，如图 b</p><p>第二轮扫描中换出首个使用位为 0 的页面，换入 6 号页面并设置访问位为 1，将扫描指针后移，下次从 3 号页开始，如图 c</p><p>注意：1 号页面原先占有的是 x 号物理块，则 6 号页面换入内存后也放在 x 号物理块中</p><h4 id="改进型-clock-置换算法" tabindex="-1"><a class="header-anchor" href="#改进型-clock-置换算法" aria-hidden="true">#</a> 改进型 CLOCK 置换算法</h4><p>改进型 CLOCK 置换算法：在使用位的基础上<strong>再增加一个修改位</strong></p><p>每帧都处于以下 4 种情况之一：</p><ol><li>未访问未修改：u = 0, m = 0</li><li>被访问未修改：u = 1, m = 0</li><li>未访问被修改：u = 0, m = 1</li><li>被访问被修改：u = 1, m = 1</li></ol><p>算法执行如下操作步骤：</p><ol><li>从指针的当前位置开始，扫描帧缓冲区<strong>选择 u = 0, m = 0 来替换，不做任何修改</strong></li><li>若第 1 步失败，则重新扫描，<strong>选择 u = 0, m = 1 来替换</strong>，每个<strong>跳过的帧的使用位设置成 0</strong></li><li>若第 2 步失败，返回第 1 步</li></ol><p>改进型 CLOCK 算法<strong>首选没访问的页，次选没修改的页</strong>，没修改的页被替换时<strong>不用写回</strong>，这样做会节省时间</p><p>优化页面置换算法的原则：<strong>尽可能保留曾经使用过的页面</strong>，而<strong>淘汰未使用的页面</strong>，认为可以在总体上减少换页次数</p><h3 id="页面分配策略" tabindex="-1"><a class="header-anchor" href="#页面分配策略" aria-hidden="true">#</a> 页面分配策略</h3><h4 id="驻留集大小" tabindex="-1"><a class="header-anchor" href="#驻留集大小" aria-hidden="true">#</a> 驻留集大小</h4><p>进程的<strong>驻留集</strong>：给一个进程<strong>分配的物理页框的集合</strong>；操作系统必须<strong>决定给特定的进程分配几个页框</strong></p><p>需要考虑以下几点：</p><ol><li>驻留集越小，驻留在主存中的进程数就越多，可以<strong>提高处理机的时间利用效率</strong></li><li>驻留集过少，则尽管有局部性原理，<strong>页错误率仍然会相对较高</strong></li><li>驻留集过多，则由于局部性原理，分配更多的主存空间<strong>对该进程的错误率没有明显的影响</strong></li></ol><p>页面的分配置换策略有：</p><ul><li>固定分配：操作系统为进程分配好物理块后，<strong>驻留集大小不变</strong></li><li>可变分配：操作系统为进程分配好物理块后，<strong>驻留集大小可变</strong></li><li>局部置换：只能选进程<strong>自己的物理块进行置换</strong></li><li>全局置换：可以<strong>从操作系统拿物理块</strong>，也可以<strong>抢其他进程的物理块</strong></li></ul><p>现代操作系统通常采用三种策略，<u>开始时都为进程分配一定的物理块</u>：</p><ol><li><p>固定分配 + 局部置换：<strong>驻留集固定</strong>，缺页时<strong>只能从自己的物理块进行置换</strong></p><p><strong>难以确定驻留集大小</strong>：太少会频繁出现缺页中断，太多又会使 CPU 和其他资源利用率下降</p></li><li><p>可变分配 + 全局置换：<strong>驻留集可变</strong>，缺页时 OS 会<strong>从空闲块中分配一个物理块给该进程</strong>，最简单的策略</p><p>可以动态的增加物理块，但也<strong>会盲目地给进程增加物理块</strong>，从而<strong>导致系统多道程序的并发能力下降</strong></p></li><li><p>可变分配 + 局部置换：<strong>驻留集可变</strong>，缺页时只能从自己的物理块进行置换，但 OS <strong>根据缺页率动态调整驻留集</strong></p><p>优点：在<strong>保证进程不会过多地调页</strong>的同时，也<strong>保持了系统的多道程序并发能力</strong></p><p>缺点：需要<strong>更复杂的实现</strong>，也需要<strong>更大的开销</strong>，但对比频繁地换入/换出所浪费的计算机资源，这种牺牲是值得的</p></li></ol><p>注意：没有固定分配 + 全局置换，因为全局置换就会增加物理块与固定分配矛盾</p><h4 id="调入页面的时机" tabindex="-1"><a class="header-anchor" href="#调入页面的时机" aria-hidden="true">#</a> 调入页面的时机</h4><p>为确定系统将进程运行时所缺的页面调入内存的时机，有以下调页策略：</p><ol><li><p>预调页策略：<u>一次调入多页比多次调入多页时间要短</u>，可以根据局部性原理，<strong>一次调入多个相邻页</strong></p><p>这样可能会更高效，但若调入页面中大多数都未被访问又是低效的</p><p>因此需要采用以预测为基础的预调页策略，但目前预调页的成功率仅约 50%</p><p>因此<strong>主要用于进程的首次调入</strong>，由程序员指出应先调入哪些页，如调入 main 函数</p></li><li><p>请求调页策略：访问的页面不在内存时，<strong>请求 OS 将所需页面调入内存</strong></p><p>调入的页<strong>一定会被访问</strong>，且策略<strong>更易于实现</strong>，故目前的虚拟存储器中<strong>大多采用此策略</strong></p><p>缺点：每次只调入一页，<u>调入/调出页面数多时会花费过多的 I/O 开销</u></p></li></ol><p>预调入就是<strong>运行前的调入</strong>，请求调页就是<strong>运行期间调入</strong>；通常两种调页策略会<strong>同时使用</strong></p><h4 id="从何处调入页面" tabindex="-1"><a class="header-anchor" href="#从何处调入页面" aria-hidden="true">#</a> 从何处调入页面</h4><p>外存分为<strong>离散分配方式的文件区</strong>和<strong>连续分配方式的对换区</strong>，因此<strong>对换区的磁盘 I/O 速度比文件区的更快</strong></p><p>从何处调入页面存在三种情况：</p><ol><li><p>系统拥有足够的对换区空间：运行前，将进程有关的文件<strong>复制到对换区</strong>；运行时，<strong>从对换区调入所需页面</strong></p></li><li><p>系统缺少足够的对换区空间：</p><p>刚开始进程`有关的文件<strong>都从文件区读入</strong>，换出时：</p><ul><li>不会被修改的文件<strong>直接覆盖</strong></li><li>可能被修改的文件<strong>换到对换区</strong>，需要时再从对换区调入（读比写快）</li></ul></li><li><p>UNIX 方式：</p><p>与进程有关的文件都放在文件区，因此<strong>未运行过的页面都应从文件区调入</strong></p><p><strong>换出是都换出到对换区</strong>，曾经运行过但又被换出的页面，下次调入时应从对换区调入</p><p>进程请求的共享页面若被其他进程调入内存，则无须再从对换区调入</p></li></ol><h3 id="抖动" tabindex="-1"><a class="header-anchor" href="#抖动" aria-hidden="true">#</a> 抖动</h3><p>抖动，颠簸：<strong>频繁进行页面调度</strong>，如刚换出又要换入，刚换入又要换出，这是由 CPU 的<strong>调度算法不合理</strong>引起的</p><p>进程在颠簸：一个进程<strong>在换页上用的时间多于执行时间</strong></p><p>频繁发生缺页中断的主要原因：某个进程频繁<strong>访问的页面数目高于可用的物理页帧数目</strong></p><p>虚拟内存技术可在内存中<strong>保留更多的进程以提高系统效率</strong></p><p>在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程</p><p>如果管理不当，那么处理机的<strong>大部分时间都将用于交换块</strong>，会大大降低系统效率</p><h3 id="工作集" tabindex="-1"><a class="header-anchor" href="#工作集" aria-hidden="true">#</a> 工作集</h3><p>基于局部性原理，可以<strong>用最近访问过的页面来确定工作集</strong>，最近访问的页面以后很可能会再访问</p>',145),E=s("p",null,[t("工作集："),s("strong",null,"在某段时间间隔内，进程要访问的页面集合"),t("，工作集 W 可由时间 t 和工作集窗口大小 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"Δ")]),s("annotation",{encoding:"application/x-tex"},"\\Delta")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord"},"Δ")])])]),t(" 来确定")],-1),T=s("p",null,[t("工作集"),s("u",null,"反映了进程在接下来的一段时间内很有可能会频繁访问的页面集合")],-1),V=s("p",null,"例如，某进程对页面的访问次序如下：",-1),X=s("p",{"1,2,3,4":""},[t("假设工作集窗口大小 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"Δ")]),s("annotation",{encoding:"application/x-tex"},"\\Delta")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord"},"Δ")])])]),t(" 为5，则在 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"t"),s("mn",null,"1")])]),s("annotation",{encoding:"application/x-tex"},"t_1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7651em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"t"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),t(" 时刻，进程的工作集为{2,3,5}，在 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"t"),s("mn",null,"2")])]),s("annotation",{encoding:"application/x-tex"},"t_2")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7651em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"t"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),t(" 时刻，进程的工作集为")],-1),Y=s("figure",null,[s("img",{src:K,alt:"image-20211113224837075",tabindex:"0",loading:"lazy"}),s("figcaption",null,"image-20211113224837075")],-1),j=s("p",null,[t("实际应用中，工作集窗口会设置得很大，即对于"),s("u",null,[t("局部性好的程序，工作集大小一般会比工作集窗口 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"Δ")]),s("annotation",{encoding:"application/x-tex"},"\\Delta")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord"},"Δ")])])]),t(" 小很多")])],-1),q=n("<p>若<strong>驻留集大小小于工作集大小</strong>，则该进程就很有<strong>可能频繁缺页</strong>，为防止这种抖动现象，<strong>驻留集大小要大于工作集大小</strong></p><p>工作集模型的原理是：</p><ul><li>让操作系统<strong>跟踪每个进程的工作集</strong>，并为进程<strong>分配大于其工作集的物理块</strong></li><li>工作集内的页面需要<strong>调入驻留集中</strong>，工作集外的页面可<strong>从驻留集中换出</strong></li><li>若还有<strong>空闲物理块</strong>，则可以再<strong>调一个进程到内存</strong>以增加多道程序数</li><li>若所有<strong>工作集之和超过可用物理块数</strong>，则<strong>暂停一个进程</strong>，将其页面调出并将其物理块分配给其他进程，以防止抖动</li></ul>",3),G=[W,A,N,R,D,E,T,V,X,Y,j,q];function H(J,Q){return o(),g("div",null,G)}const $=r(S,[["render",H],["__file","第三章 内存管理.html.vue"]]);export{$ as default};
