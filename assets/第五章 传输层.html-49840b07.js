import{_ as o,X as l,Y as a,a2 as r,Z as n,a1 as s}from"./framework-0cdb5b8e.js";const g="/408doc/408noteImg/images/image-20211218152842763.png",i="/408doc/408noteImg/images/image-20211218153029279.png",p="/408doc/408noteImg/images/image-20211218213310008.png",e="/408doc/408noteImg/images/image-20211218213357580.png",c="/408doc/408noteImg/images/image-20211218213451915.png",d="/408doc/408noteImg/images/image-20211218213535980.png",h="/408doc/408noteImg/images/image-20211219154359807.png",u="/408doc/408noteImg/images/image-20211219154554463.png",m="/408doc/408noteImg/images/image-20211219154814274.png",t="/408doc/408noteImg/images/image-20211219155015917.png",P="/408doc/408noteImg/images/image-20211219155211882.png",T="/408doc/408noteImg/images/image-20211219155521144.png",C="/408doc/408noteImg/images/image-20211219155756204.png",f={},x=r('<h2 id="传输层提供的服务" tabindex="-1"><a class="header-anchor" href="#传输层提供的服务" aria-hidden="true">#</a> 传输层提供的服务</h2><h3 id="传输层的功能" tabindex="-1"><a class="header-anchor" href="#传输层的功能" aria-hidden="true">#</a> 传输层的功能</h3><p>传输层向它上面的应用层提供通信服务，它是面向<strong>通信部分的最高层</strong>，也是<strong>用户功能中的最低层</strong></p><p>传输层位于网络层之上，它<strong>为运行在不同主机上的进程之间提供了逻辑通信</strong>，而网络层提供主机之间的逻辑通信</p><p>只有<strong>主机的协议栈才有传输层和应用层</strong>，而路由器在转发分组时都只用到下三层的功能（<strong>通信子网中没有传输层</strong>）</p><figure><img src="'+g+'" alt="image-20211218152842763" tabindex="0" loading="lazy"><figcaption>image-20211218152842763</figcaption></figure><p>传输层的功能如下：</p><ol><li><p>传输层提供应用进程之间的<strong>逻辑通信</strong>，即<strong>端到端通信</strong>；而网络层提供的是主机之间的逻辑通信</p></li><li><p>复用和分用：</p><ul><li>复用：发送方<u>不同的应用进程都可使用同一个传输层协议</u>传送数据</li><li>分用：接收方的传输层在剥去报文的首部后<u>能够把这些数据正确交付到目的应用进程</u></li></ul><p>注意：网络层也有复用分用的功能：</p><ul><li>复用：发送方<u>不同协议的数据都可以封装成 IP 数据报</u>发送出去</li><li>分用：接收方的网络层在剥去首部后<u>把数据交付给相应的协议</u></li></ul></li><li><p>传输层还要对收到的整个报文进行<strong>差错检测</strong>；而网络层只检查 IP 数据报的首部</p></li><li><p>提供两种不同的传输协议，即<strong>面向连接的 TCP 和无连接的 UDP</strong>；而网络层无法同时提供</p></li></ol><p>传输层向高层用户屏蔽了低层网络核心的细节，让进程间存在一条逻辑通信信道，但使用的协议不同也会有很大差别：</p><ul><li><p>采用 TCP 时，这种逻辑通信信道就相当于一条全双工的<strong>可靠信道</strong></p></li><li><p>采用 UDP 时，这种逻辑通信信道仍然是一条<strong>不可靠信道</strong></p></li></ul><h3 id="传输层的寻址与端口" tabindex="-1"><a class="header-anchor" href="#传输层的寻址与端口" aria-hidden="true">#</a> 传输层的寻址与端口</h3><h4 id="端口的作用" tabindex="-1"><a class="header-anchor" href="#端口的作用" aria-hidden="true">#</a> 端口的作用</h4><p>应用进程将数据通过端口交付给传输层，传输层将数据通过端口交付给应用进程，<strong>端口是传输层服务访问点 <code>TSAP</code></strong></p><p>在协议栈层间的抽象的协议端口是软件端口，它与路由器的硬件端口是完全不同的概念：</p><ul><li>硬件端口：<strong>不同硬件设备进行交互的接口</strong></li><li>软件端口：应用层的各种协议进程与传输实体进行<strong>层间交互的一种地址</strong></li></ul><p>传输层使用的是<strong>软件端口</strong></p><h4 id="端口号" tabindex="-1"><a class="header-anchor" href="#端口号" aria-hidden="true">#</a> 端口号</h4><p>应用进程通过端口号进行标识，<strong>端口号长度为 <code>16bit</code>，能够表示 65536 个不同的端口号</strong></p><p>端口号<strong>只具有本地意义</strong>，在因特网中，不同计算机的相同端口号是没有联系的</p><p>根据端口号范围可将端口分为两类：</p><ol><li><p>服务器端使用的端口号，它又分为两类：</p><ol><li><p><strong>熟知端口号：数值为 0 ~ 1023</strong>，互联网地址指派机构 <code>IANA</code> 把这些端口号指派给了 TCP/IP 最重要的一些应用程序</p><p>一些常用的熟知端口号如下：</p><figure><img src="'+i+'" alt="image-20211218153029279" tabindex="0" loading="lazy"><figcaption>image-20211218153029279</figcaption></figure></li><li><p><strong>登记端口号：数值为 1024 ~ 49151</strong>，供没有熟知端口号的应用程序使用</p></li></ol></li><li><p>客户端使用的端口号，短暂端口号：数值为 49152 ~ 65535，这类端口号<strong>仅在客户进程运行时才动态地选择</strong></p><p>通信结束后，刚用过的客户端口号就不复存在，从而这个端口号就可供其他客户进程以后使用</p></li></ol><h4 id="套接字" tabindex="-1"><a class="header-anchor" href="#套接字" aria-hidden="true">#</a> 套接字</h4><p>通过 IP 地址来找到主机，通过端口号找到应用进程；<strong>端口号拼接到 IP 地址即构成套接字 Socket</strong></p><p>在网络中<strong>采用发送方和接收方的套接字来识别端点</strong>，套接字 Socket = (IP 地址, 端口号)，它唯一地标识网络中的一个端点</p><p>在网络通信中，主机 A 发给主机 B 的<strong>报文段包含目的端口号和源端口号</strong>，源端口号是返回地址的一部分</p><h3 id="无连接服务与面向连接服务" tabindex="-1"><a class="header-anchor" href="#无连接服务与面向连接服务" aria-hidden="true">#</a> 无连接服务与面向连接服务</h3><ul><li>面向连接服务：通信前建立连接，通信中实时地监控和管理连接，通信结束释放连接</li><li>无连接服务：通信不需要建立连接；通信时，直接发送信息，尽力而为地往目的地传送</li></ul><p>TCP/IP 协议族在 IP 层之上使用了两个传输协议：</p><ol><li><p>面向连接的<strong>传输控制协议 TCP</strong>：传输层向上提供的是一条<strong>全双工的可靠逻辑信道</strong></p><p>TCP <strong>不提供广播或组播服务</strong>，由于提供了面向连接的可靠传输服务，因此增加了许多开销</p><p>这不仅使协议数据单元的头部增大很多，还要占用许多的处理机资源</p><p>因此 TCP 主要适用于<strong>可靠性更重要的场合</strong>，如 FTP、HTTP、TELNET 等</p></li><li><p>无连接的<strong>用户数据报协议 UDP</strong>：传输层向上提供的是一条<strong>不可靠的逻辑信道</strong></p><p>UDP 在 IP 之上仅提供<strong>多路复用和对数据的错误检查</strong>两个附加服务</p><p>UDP 在传送数据之前不需要先建立连接，远程主机的传输层收到 UDP 报文后，不需要给出任何确认</p><p>由于 UDP 比较简单，因此<strong>执行速度比较快、实时性好</strong>，使用 UDP 的应用主要包括 <code>TFTP</code>、DNS、<code>SNMP</code>、<code>RTP</code></p></li></ol><h2 id="udp-协议" tabindex="-1"><a class="header-anchor" href="#udp-协议" aria-hidden="true">#</a> UDP 协议</h2><h3 id="udp-数据报" tabindex="-1"><a class="header-anchor" href="#udp-数据报" aria-hidden="true">#</a> UDP 数据报</h3><h4 id="udp-概述" tabindex="-1"><a class="header-anchor" href="#udp-概述" aria-hidden="true">#</a> UDP 概述</h4><p>UDP 仅在 IP 的数据报服务之上增加了两个最基本的服务：<strong>复用和分用以及差错检测</strong></p><p>如果应用开发者选择 UDP 而非 TCP，那么应用程序几乎直接与 IP 打交道，但 UDP 具有如下优点：</p><ol><li><p>UDP 无须建立连接，因此 <strong>UDP 不会引入建立连接的时延</strong></p></li><li><p>UDP 不维护连接状态，也<strong>不跟踪拥塞控制等参数</strong>，某些专用应用服务器使用 UDP 时，能支持更多的活动客户机</p></li><li><p><strong>分组首部开销小</strong>，TCP 有 <code>20B</code> 的首部开销，而 UDP 仅有 <code>8B</code> 的开销</p></li><li><p>应用层能更好地控制要发送的数据和发送时间，UDP 没有拥塞控制，因此<strong>网络中的拥塞不会影响主机的发送效率</strong></p><p>某些实时应用要求以稳定的速度发送，能容忍一些数据的丢失，但不允许有较大的时延，而 UDP 正好满足需求</p></li><li><p>UDP <strong>支持一对一、一对多、多对一和多对多的交互通信</strong></p></li></ol><p>UDP 常用于<strong>一次性传输较少数据的网络应用</strong>；UDP 也常用于<strong>多媒体应用</strong>，如实时视频会议（UDP 延迟小）</p><p>UDP 不保证可靠交付，但这并不意味着应用对数据的要求是不可靠的，所有维护<strong>可靠性的工作可由用户在应用层来完成</strong></p><p>UDP 是<strong>面向报文的</strong>，发送方 UDP 对应用层交下来的报文，在<strong>添加首部后就向下交付给 IP 层</strong>；接收方 UDP 对 IP 层交上来 UDP 数据报，在<strong>去除首部后就原封不动地交付给上层应用进程</strong>；因此，应用程序必须选择合适大小的报文</p><h4 id="udp-的首部格式" tabindex="-1"><a class="header-anchor" href="#udp-的首部格式" aria-hidden="true">#</a> UDP 的首部格式</h4><p>UDP 数据报包含两部分：UDP 首部和用户数据，UDP 首部有 <code>8B</code>，由 4 个字段组成，每个字段的长度都是 <code>2B</code></p><p>各字段意义如下：</p><ol><li>源端口：源端口号，在<strong>需要对方回信时选用</strong>，不需要时可用全 0</li><li>目的端口：目的端口号，<strong>必须使用</strong></li><li>长度：UDP 数据报的长度，<strong>包括首部和数据</strong>，其最小值是 8</li><li>校验和：<strong>检测 UDP 数据报在传输中是否有错</strong>，有错就丢弃；<strong>可选字段</strong>，不使用时，则直接令该字段为全 0</li></ol><figure><img src="'+p+'" alt="image-20211218213310008" tabindex="0" loading="lazy"><figcaption>image-20211218213310008</figcaption></figure><p>当传输层从 IP 层收到 UDP 数据报时，就<strong>根据首部中的目的端口</strong>，把 UDP 数据报通过相应的端口<strong>上交给应用进程</strong></p><p>如果接收方 UDP 发现<strong>不存在对应于目的端口号的应用进程</strong>，那么就丢弃该报文，并由 ICMP <strong>发送端口不可达</strong></p><figure><img src="'+e+'" alt="image-20211218213357580" tabindex="0" loading="lazy"><figcaption>image-20211218213357580</figcaption></figure><h3 id="udp-校验" tabindex="-1"><a class="header-anchor" href="#udp-校验" aria-hidden="true">#</a> UDP 校验</h3><p>在计算校验和时，要在 UDP 数据报之前增加 <code>12B</code> 的伪首部：</p><ul><li>伪首部只是在计算校验和时，临时添加在 UDP 数据报的前面，得到一个临时的 UDP 数据报</li><li>校验和就是<strong>按照这个临时的 UDP 数据报来计算的</strong></li><li><strong>伪首部既不向下传送又不向上递交</strong>，而只是为了计算校验和</li></ul><p>下面是伪首部的格式：</p><figure><img src="'+c+'" alt="image-20211218213451915" tabindex="0" loading="lazy"><figcaption>image-20211218213451915</figcaption></figure><p>UDP 校验和的计算方法和 IP 数据报首部校验和的计算方法相似：</p><ol><li><p>发送方首先把<strong>全零放入校验和字段</strong>并<strong>添加伪首部</strong>，其中 UDP 数据报<strong>必须是偶数个字节</strong></p></li><li><p>若 UDP 数据报的数据部分<strong>不是偶数个字节</strong>，则要<strong>在末尾填入一个全零字节</strong>（不发送）</p></li><li><p>然后按二进制反码<strong>计算出这些 16 位字的和</strong>，将此<strong>和的二进制取反码再写入校验和字段</strong>，并发送</p><p>直接相加，若<strong>加法时发生溢出时，要加 1</strong>，结果取反后写入校验字段；使用 16 进制来相加会简单很多</p></li><li><p>接收方把收到的 UDP 数据报加上伪首部后，按二进制反码求这些 16 位字的和</p></li><li><p><strong>无差错时其结果应为全 1</strong>，否则就表明有差错出现，接收方就应该丢弃这个 UDP 数据报</p></li></ol><p>下图为例子：UDP 数据报的长度是 <code>15B</code>，因此需要添加一个全 0 字节：</p><figure><img src="'+d+'" alt="image-20211218213535980" tabindex="0" loading="lazy"><figcaption>image-20211218213535980</figcaption></figure><p>注意：</p><ol><li>校验时，若 UDP 数据报部分的<strong>长度不是偶数个字节，则需填入一个全 0 字节</strong>，此字节是不发送的</li><li>如果校验出 UDP 数据报是错误的，<strong>可以丢弃或交付给上层</strong>，但交付时需要附上错误报告</li></ol><p>这种简单的差错检验方法的检错能力并不强，但它的好处是<strong>简单、处理速度快</strong></p><h2 id="tcp-协议" tabindex="-1"><a class="header-anchor" href="#tcp-协议" aria-hidden="true">#</a> TCP 协议</h2><h3 id="tcp-协议的特点" tabindex="-1"><a class="header-anchor" href="#tcp-协议的特点" aria-hidden="true">#</a> TCP 协议的特点</h3><p>TCP 是<strong>在不可靠的 IP 层之上实现的可靠的数据传输协议</strong>，它的主要特点如下：</p><ol><li>TCP 是面向连接的传输层协议</li><li>每条 TCP 连接只能有两个端点，每条 TCP 连接<strong>只能是点对点的</strong></li><li>TCP 提供可靠的交付服务，保证传送的数据<strong>无差错、不丢失、不重复且有序</strong></li><li>TCP 提供<strong>全双工通信</strong>，为此 TCP 连接的两端都<strong>设有发送缓存和接收缓存</strong>，用来临时存放双向通信的数据 <ul><li>发送缓存用来暂时存放以下数据：TCP <strong>准备发送</strong>的数据；TCP <strong>已发送但尚未收到确认</strong>的数据</li><li>接收缓存用来暂时存放以下数据：按序到达但尚<strong>未被接收应用程序读取</strong>的数据；<strong>不按序到达</strong>的数据</li></ul></li><li>TCP 是<strong>面向字节流</strong>的，它把应用程序交下来的数据仅视为一连串的无结构的字节流</li></ol><p>注意：UDP 报文的长度由发送应用进程决定；TCP 报文的长度则根据<strong>接收方给出的窗口值和当前网络拥塞程度</strong>来决定</p><p>如果应用进程传送到 TCP 缓存的数据块太长，TCP 就把它<strong>划分得短一些再传送</strong>；如果太短，TCP 也可以等到<strong>积累足够多的字节后再组成报文段发送出去</strong></p><h3 id="tcp-报文段" tabindex="-1"><a class="header-anchor" href="#tcp-报文段" aria-hidden="true">#</a> TCP 报文段</h3><p><strong>TCP 传送的数据单元称为报文段</strong>，TCP 报文段可以用来运载数据、建立连接、释放连接和应答</p><p>一个 TCP 报文段分为首部和数据两部分，整个 TCP 报文段作为 IP 数据报的数据部分封装在 IP 数据报中</p><p>首部的前 <code>20B</code> 是固定的，TCP 报文段的首部<strong>最短为 <code>20B</code></strong>，后面有 <code>4N</code> 字节是根据需要而增加的选项，<strong>长度为 <code>4B</code> 的整数倍</strong></p><figure><img src="'+h+'" alt="image-20211219154359807" tabindex="0" loading="lazy"><figcaption>image-20211219154359807</figcaption></figure><p>TCP 的全部功能体现在其首部的各个字段中，各字段意义如下：</p>',70),D=n("ol",null,[n("li",null,[n("p",null,[s("源端口和目的端口：各占 "),n("code",null,"2B"),s("，和 UDP 端口作用一样")])]),n("li",null,[n("p",null,[s("序号：占 "),n("code",null,"4B"),s("，范围为 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mn",null,"0"),n("mo",null,"∼"),n("msup",null,[n("mn",null,"2"),n("mn",null,"32")]),n("mo",null,"−"),n("mn",null,"1")]),n("annotation",{encoding:"application/x-tex"},"0\\sim2^{32}-1")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6444em"}}),n("span",{class:"mord"},"0"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"∼"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.8974em","vertical-align":"-0.0833em"}}),n("span",{class:"mord"},[n("span",{class:"mord"},"2"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8141em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},[n("span",{class:"mord mtight"},"32")])])])])])])])]),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"−"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6444em"}}),n("span",{class:"mord"},"1")])])]),s("，"),n("strong",null,"本报文段所发送的数据的第一个字节的序号")])]),n("li",null,[n("p",null,[s("确认号：占 "),n("code",null,"4B"),s("，"),n("strong",null,"期望收到对方下一个报文段的第一个数据字节的序号")]),n("p",null,"若确认号为 N，则表明到序号 N - 1 为止的所有数据都已正确收到")]),n("li",null,[n("p",null,[s("数据偏移，即首部长度：占 4 位，表示首部长度，它"),n("strong",null,"指出 TCP 报文段的数据起始位置"),s("，数据"),n("strong",null,"偏移的单位是 32 位")])]),n("li",null,[n("p",null,"保留：占 6 位，保留为今后使用，但目前应置为 0")]),n("li",null,[n("p",null,[s("紧急位 "),n("code",null,"URG"),s("："),n("code",null,"URG"),s(" = 1 时，表明"),n("strong",null,"紧急指针字段有效"),s("，它告诉系统此报文段中"),n("strong",null,"有紧急数据，应尽快传送"),s("（发送方使用）")]),n("p",null,[s("但 "),n("code",null,"URG"),s(" 需要"),n("strong",null,"和紧急指针配合使用"),s("，即数据"),n("strong",null,"从第一个字节到紧急指针所指字节就是紧急数据")])]),n("li",null,[n("p",null,[s("确认位 ACK：仅"),n("strong",null,"当 ACK = 1 时确认号字段才有效"),s("；TCP 规定，在"),n("u",null,"连接建立后所有传送的报文段都必须把 ACK 置 1")])]),n("li",null,[n("p",null,[s("推送位 "),n("code",null,"PSH"),s("："),n("strong",null,"接收方"),s(" TCP 收到 "),n("code",null,"PSH"),s(" = 1 的报文段，就"),n("strong",null,"尽快地交付给接收应用进程"),s("，不用等到缓存填满后再向上交付")])]),n("li",null,[n("p",null,[s("复位位 "),n("code",null,"RST"),s("："),n("code",null,"RST"),s(" = 1 时，"),n("u",null,"表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立运输连接")])]),n("li",null,[n("p",null,[s("同步位 SYN：同步 SYN = 1 表示"),n("strong",null,"这是一个连接请求或连接接受报文")]),n("p",null,"当 SYN = 1，ACK = 0 时，表明这是一个连接请求报文；若对方同意建立连接，则在响应报文中使用 SYN = 1，ACK = 1")]),n("li",null,[n("p",null,[s("终止位 FIN：用来"),n("strong",null,"释放一个连接"),s("，当 FIN = 1 时，表明数据已发送完毕，并要求释放传输连接")])]),n("li",null,[n("p",null,[s("窗口：占 "),n("code",null,"2B"),s("，范围为 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mn",null,"0"),n("mo",null,"∼"),n("msup",null,[n("mn",null,"2"),n("mn",null,"16")]),n("mo",null,"−"),n("mn",null,"1")]),n("annotation",{encoding:"application/x-tex"},"0\\sim2^{16}-1")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6444em"}}),n("span",{class:"mord"},"0"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"∼"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.8974em","vertical-align":"-0.0833em"}}),n("span",{class:"mord"},[n("span",{class:"mord"},"2"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8141em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},[n("span",{class:"mord mtight"},"16")])])])])])])])]),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"−"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6444em"}}),n("span",{class:"mord"},"1")])])]),s("，它指出现在"),n("strong",null,"允许对方发送的数据量")]),n("p",null,"接收方的数据缓存空间是有限的，因此用窗口值作为接收方让发送方设置其发送窗口的依据"),n("p",null,"注意：滑动窗口过大会产生过多的 ACK，而过小会使路由器变得拥塞，导致主机丢失分组")]),n("li",null,[n("p",null,[s("校验和：占 "),n("code",null,"2B"),s("，检验的范围包括首部和数据两部分，"),n("strong",null,"计算方法和 UDP 一样"),s("，唯一不同是"),n("strong",null,"伪首部的第 4 字段是 6")])]),n("li",null,[n("p",null,[s("紧急指针：占 "),n("code",null,"2B"),s("，仅在 "),n("code",null,"URG"),s(" = 1 时才有意义，它指出在本报文段中"),n("strong",null,"紧急数据共有多少字节")])]),n("li",null,[n("p",null,[s("选项：长度可变，TCP 最初只有最大报文段长度 MSS 一种选项，MSS 是 TCP "),n("strong",null,"报文段中的数据字段的最大长度")])]),n("li",null,[n("p",null,[s("填充："),n("strong",null,[s("使整个首部长度是 "),n("code",null,"4B"),s(" 的整数倍")])])])],-1),U=r('<p>思考：TCP 没有长度字段是因为在 IP 上给出分组的长度，减一下就得到 TCP 的长度，UDP 那个长度字段是冗余的</p><h3 id="tcp-连接管理" tabindex="-1"><a class="header-anchor" href="#tcp-连接管理" aria-hidden="true">#</a> TCP 连接管理</h3><p>TCP 是面向连接的协议，因此每个 TCP 连接都有三个阶段：连接建立、数据传送、连接释放</p><p>在 TCP 连接建立的过程中，要解决以下三个问题：</p><ol><li>要使每一方能够<strong>确知对方的存在</strong></li><li>要允许双方<strong>协商一些参数</strong>，如最大窗口值、时间戳选项等</li><li>能够<strong>对运输实体资源进行分配</strong>，如缓存大小等</li></ol><p>TCP 把连接作为最基本的抽象，每条 TCP 连接有两个端点，<strong>TCP 连接的端点为套接字 socket 或插口</strong></p><p><strong>TCP 连接的建立采用 C/S 方式</strong>，主动发起连接建立的应用进程称为客户，而被动等待连接建立的应用进程称为服务器</p><h4 id="tcp-连接的建立" tabindex="-1"><a class="header-anchor" href="#tcp-连接的建立" aria-hidden="true">#</a> TCP 连接的建立</h4><p>连接的建立经历以下 3 个步骤，通常称为三次握手：</p><figure><img src="'+u+'" alt="image-20211219154554463" tabindex="0" loading="lazy"><figcaption>image-20211219154554463</figcaption></figure><p>连接建立前，服务器进程处于 LISTEN 状态，等待客户的连接请求：</p><ol><li><p>客户机的 TCP 首先<strong>向服务器的 TCP 发送连接请求</strong>报文段</p><p>这个特殊报文段的首部中的<strong>同步位 SYN 置 1</strong>，同时<strong>选择一个初始序号 seq = x</strong></p><p>SYN 报文段<strong>不能携带数据，但要消耗掉 1 个序号</strong>；TCP 客户进程进入同步已发送 SYN-SENT 状态</p></li><li><p>服务器的 TCP 收到连接请求报文段后，如同意建立连接，则<strong>向客户机发回确认</strong>，并<strong>为该 TCP 连接分配缓存和变量</strong></p><p>在确认报文段中，把 <strong>SYN 位和 ACK 位都置 1</strong>，<strong>确认号是 ack = x + 1</strong>，同时<strong>选择一个初始序号 seq = y</strong></p><p>确认报文段<strong>不能携带数据，但要消耗掉 1 个序号</strong>；TCP 服务器进程进入同步收到 <code>SYN-RCVD</code> 状态</p></li><li><p>当客户机收到确认报文段后<strong>向服务器给出确认</strong>，并<strong>为该 TCP 连接分配缓存和变量</strong></p><p>确认报文段的 <strong>ACK 位置 1，确认号 ack = y + 1，序号 seq = x + 1</strong></p><p>该报文段<strong>可以携带数据</strong>，若<strong>不携带数据则不消耗序号</strong>；TCP 家无过列结患入已建立连接 ESTABLISHED 状态</p></li></ol><p>TCP 提供的是全双工通信，因此<strong>通信双方的应用进程在任何时候都能发送数据</strong></p><p>注意：由于服务器比客户端早一步分配资源，这就使得服务器易于受到 SYN 洪泛攻击</p><p>额外：若采用两次握手：若客户端向服务端的连接请求在某个结点长时间滞留，客户端再次连接并完成传输后断开，这时滞留的连接请求到达服务端，服务端返回确认报文段，但客户端认为无效并丢弃，但服务端认为连接建立，就白白消耗了资源</p><p>额外：若序号都从 1 开始：假设带数据的报文段滞留，在下个连接才到，序号又刚好在新连接的窗口内，从而被收下导致结果错误，因此新连接的序号一定要和前面的连接用过的序号不同</p><h4 id="tcp-连接的释放" tabindex="-1"><a class="header-anchor" href="#tcp-连接的释放" aria-hidden="true">#</a> TCP 连接的释放</h4><p>TCP 连接释放的过程通常称为四次握手，两边都能终止连接：</p><figure><img src="'+m+'" alt="image-20211219154814274" tabindex="0" loading="lazy"><figcaption>image-20211219154814274</figcaption></figure><ol><li><p>客户机关闭连接时，向其 TCP <strong>发送连接释放报文段</strong>，并停止发送数据，主动关闭 TCP 连接</p><p>该报文段的终止位 <strong>FIN 置 1，序号 seq = u</strong>，它是<strong>最后一个字节的序号加 1</strong></p><p>FIN 报文段即使<strong>不携带数据，消耗掉 1 个序号</strong>；TCP 客户进程进入终止等待1 FIN-WAIT-1 状态</p></li><li><p>服务器收到连接释放报文段后即<strong>发出确认</strong></p><p><strong>确认号 ack = u + 1，序号 seq = v</strong>，它是<strong>最后一个字节的序号加 1</strong></p><p>然后服务器进入关闭等待 CLOSE-WAIT 状态；<u>客户机到服务器这个方向的连接就释放了</u></p></li><li><p>若服务器没有要发送的数据了，此时发出 <strong>FIN = 1，序号 seq = w 的连接释放报文段</strong></p><p>还须重复上次已发送的<strong>确认号 ack = u + 1</strong>；服务器进入最后确认 LAST-ACK 状态</p></li><li><p>客户机收到连接释放报文段后，必须<strong>发出确认</strong></p><p>把确认报文段中的确认位 <strong>ACK 置 1，确认号 ack = w + 1，序号 seq = u + 1</strong></p><p>经过时间最长报文段寿命 <code>2MSL</code> 后，客户机才进入连接关闭 CLOSED 状态</p><p>额外：等待 <code>2MSL</code> 是为了防止确认报文段丢失，不然丢失后服务器会一直重发，客户端关闭了也收不到</p></li></ol><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h4><ol><li><strong>连接建立，分为 3 步：</strong><ol><li>SYN = 1，seq = x</li><li>SYN = 1，ACK = 1，seq = y，ack = x + 1</li><li>ACK = 1，seq = x + 1，ack = y + 1</li></ol></li><li><strong>释放连接，分为 4 步：</strong><ol><li>FIN = 1，seq = u</li><li>ACK = 1，seq = v，ack = u + 1</li><li>FIN = 1，ACK = 1，seq = w， ack = u + 1</li><li>ACK = 1，seq = u + 1，ack = w + 1</li></ol></li></ol><h3 id="tcp-可靠传输" tabindex="-1"><a class="header-anchor" href="#tcp-可靠传输" aria-hidden="true">#</a> TCP 可靠传输</h3><p>TCP 的任务是<strong>在 IP 层上建立一种可靠数据传输服务</strong>，保证接收方进程收到的字节流与发送方发出的字节流完全一样</p><p>TCP 使用了<strong>校验、序号、确认和重传</strong>等机制来达到这一目的，其中 TCP 的校验机制与 UDP 校验一样</p><h4 id="序号" tabindex="-1"><a class="header-anchor" href="#序号" aria-hidden="true">#</a> 序号</h4><p>TCP 首部的序号字段用来保证<strong>数据能有序提交给应用层</strong>，TCP 把数据视为一个无结构但有序的字节流</p><p>TCP 连接传送的数据流中的<strong>每个字节都编上一个序号</strong>，序号字段的值是指本报文段所发送的数据的<strong>第一个字节的序号</strong></p><p>如下图，发送缓冲区共有 <code>10B</code>，序号从 0 开始，第一个报文段的序号是 0，第二个报文的的序号是 3</p><figure><img src="'+t+'" alt="image-20211219155015917" tabindex="0" loading="lazy"><figcaption>image-20211219155015917</figcaption></figure><h4 id="确认" tabindex="-1"><a class="header-anchor" href="#确认" aria-hidden="true">#</a> 确认</h4><p>TCP 首部的确认号是<strong>期望收到对方的下一个报文段的数据的第一个字节的序号</strong>，TCP 默认使用<strong>累计确认</strong></p><p>下图中，如果接受了第一个报文段，那么发送的确认号为 3</p><figure><img src="'+t+'" alt="image-20211219155015917" tabindex="0" loading="lazy"><figcaption>image-20211219155015917</figcaption></figure><p>发送方缓存区会继续<strong>存储那些已发送但未收到确认的报文段</strong>，以便在需要时重传</p><p>注意：TCP 采用的是<strong>对报文段的确认机制</strong>，因为它是对每个报文段进行确认，而不是对每个字节进行确认</p><h4 id="重传" tabindex="-1"><a class="header-anchor" href="#重传" aria-hidden="true">#</a> 重传</h4><p>有两种事件会导致 TCP 对报文段进行重传：超时和冗余 ACK</p><p>选择题：分组重传的最大值是发送方能发送的最大值，等于滑动窗口大小</p><h5 id="超时" tabindex="-1"><a class="header-anchor" href="#超时" aria-hidden="true">#</a> 超时</h5><p>TCP 每发送一个报文段，就对这个报文段<strong>设置一次计时器</strong>，重传时间到期但还未收到确认时，就要重传这一报文段</p><p>由于 TCP 的下层是一个互联网环境，IP 数据报所选择的路由变化很大，因而<strong>传输层的往返时延的方差也很大</strong></p><p>为了计算超时计时器的重传时间，TCP 采用一种自适应算法，它记录一个报文段的往返时间 RTT</p><p>TCP <strong>保留了 RTT 的一个加权平均往返时间 <code>RTTs</code></strong>，它会随新测量 RTT 样本值的变化而变化</p><p>超时计时器设置的<strong>超时重传时间 <code>RTO</code> 应略大于 <code>RTTs</code></strong>，但也不能大太多，否则 TCP 不能很快重传，导致数据传输时延大</p><h5 id="冗余-ack" tabindex="-1"><a class="header-anchor" href="#冗余-ack" aria-hidden="true">#</a> 冗余 ACK</h5><p>超时重传的周期往往太长，因此发送方<strong>通过注意冗余 ACK 来较好地检测丢包情况</strong></p><p>冗余 ACK：接收方<strong>再次发送某个报文段的确认 ACK</strong>，而发送方先前已经收到过该报文段的确认了</p><p>TCP 规定每当<strong>比期望序号大的失序报文段到达时</strong>，就<strong>发送一个冗余 ACK</strong> 指明下一个期待字节的序号</p><p>TCP 规定发送方<strong>收到对同一个报文段的 3 个冗余 ACK 时</strong>，就认为<strong>被确认报文段之后的报文段已经丢失</strong></p><p>这种技术通常称为<strong>快速重传</strong>，冗余 ACK 还被用在拥塞控制中，<a href="#%E5%BF%AB%E9%87%8D%E4%BC%A0">这将在后面的内容中讨论</a></p><h3 id="tcp-流量控制" tabindex="-1"><a class="header-anchor" href="#tcp-流量控制" aria-hidden="true">#</a> TCP 流量控制</h3><p>TCP 提供流量控制服务来<strong>消除发送方发送速率太快，从而使接收方缓存区溢出</strong>的可能性</p><p>TCP 提供一种<strong>基于滑动窗口协议的流量控制机制</strong>，滑动窗口在数据链路层有介绍</p><p>在通信过程中，<strong>接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小</strong>来实现流量控制</p><ul><li>接收窗口 rwnd：<strong><code>TCP</code> 报文段首部中的窗口字段值</strong>；通过调整 rwnd，来限制发送方向网络注入报文的速率</li></ul><p>发送方总是<strong>根据最新收到的 rwnd 值来限制自己发送窗口的大小</strong>，从而保证<strong>不会使接收方的接受缓冲溢出</strong></p><p>如下图，建立连接时确认 rwnd 为 400，期间进行了三次流量控制，最后把窗口减小到 rwnd = 0</p><figure><img src="'+P+'" alt="image-20211219155211882" tabindex="0" loading="lazy"><figcaption>image-20211219155211882</figcaption></figure><p>TCP 为每一个连接设有一个持续计时器，只要 TCP 连接的一方<strong>收到对方的零窗口通知，就启动持续计时器</strong></p><p>若持续计时器设置的时间到期，就<strong>发送一个零窗口探测报文段</strong>，接收方收到探测报文段时<strong>给出现在的窗口值</strong></p><p>传输层和数据链路层的流量控制的区别是：</p><ol><li>传输层定义<strong>端到端用户之间的流量控制</strong>，数据链路层定义两个中间的相邻结点的流量控制</li><li>数据链路层的滑动窗口协议的窗口大小不能动态变化，<strong>传输层的则可以动态变化</strong></li></ol><h3 id="tcp-拥塞控制" tabindex="-1"><a class="header-anchor" href="#tcp-拥塞控制" aria-hidden="true">#</a> TCP 拥塞控制</h3><p>拥塞控制是指<strong>防止过多的数据注入网络，保证网络中的路由器或链路不致过载</strong></p><p>出现拥塞时，端点并不了解拥塞发生的细节，对通信连接的端点来说，<strong>拥塞往往表现为通信时延的增加</strong></p><p>拥塞控制与流量控制的区别：</p><ul><li>拥塞控制：让网络能够承受现有的网络负荷，<strong>是一个全局性的过程</strong>，涉及所有与降低网络传输性能有关的所有因素</li><li>流量控制：对点对点的通信量的控制，<strong>是个端到端的问题</strong>，它抑制发送端发送数据的速率，以便接收端来得及接收</li></ul><p>但拥塞控制和流量控制<strong>都通过控制发送方发送数据的速率来达到控制效果</strong></p><p>TCP 协议要求发送方维护以下两个窗口：</p><ol><li><p>接收窗口 rwnd：接收方根据目前接收缓存大小来确定的最新窗口值，<strong>反映接收方的容量</strong></p></li><li><p>拥塞窗口 cwnd：发送方根据自己估算的网络拥塞程度而设置的窗口值，<strong>反映网络的当前容量</strong></p><p>只要网络未出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去</p><p>但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入网络的分组数</p></li></ol><p>发送方在确定发送报文段的速率时，<strong>既要考虑接收方的接收能力，又要考虑不要使网络发生拥塞</strong></p><p>因此发送窗口的上限值应取接收窗口 rwnd 和拥塞窗口 cwnd 中较小的一个，即<strong>发送窗口的上限值 = min[rwnd, cwnd]</strong></p><p>因特网建议标准定义了进行拥塞控制的 4 种算法：慢开始、拥塞避免、快重传、快恢复；下面介绍发送方如何维护 cwnd</p><h4 id="慢开始和拥塞避免" tabindex="-1"><a class="header-anchor" href="#慢开始和拥塞避免" aria-hidden="true">#</a> 慢开始和拥塞避免</h4><h5 id="慢开始算法" tabindex="-1"><a class="header-anchor" href="#慢开始算法" aria-hidden="true">#</a> 慢开始算法</h5><p>在 TCP 刚刚连接好并开始发送 TCP 报文段时，先<strong>令拥塞窗口 cwnd = 1</strong>，即<strong>一个最大报文段长度 MSS</strong></p><p><strong>每收到一个对新报文段的确认后，将 cwnd 加 1</strong>，逐步增大发送方的 cwnd，<strong>使分组注入网络的速率更加合理</strong></p><p>注意：是收到对新报文段确认才加 1，每次发送的报文段数量翻倍，所以接收到的确认翻倍，即 cwnd 翻倍</p><p>慢开始的慢是指在 TCP 开始发送报文段时先设置 cwnd = 1，然后再逐渐增大 cwnd，这对防止网络出现拥塞很有用</p><p><strong>每经过一个传输轮次</strong>，即往返时延 RTT，<strong>cwnd 就会加倍，当 cwnd 达到慢开始门限 ssthresh，就改用拥塞避免算法</strong></p><p>注意：这里 cwnd = 1 是方便写法，实际上 cwnd = 1 × MSS</p><h5 id="拥塞避免算法" tabindex="-1"><a class="header-anchor" href="#拥塞避免算法" aria-hidden="true">#</a> 拥塞避免算法</h5><p>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，具体做法是：</p><p><strong>每经过一个往返时延 RTT 就把 cwnd 加 1</strong>，使拥塞窗口 cwnd 按线性规律缓慢增长，这比慢开始的增长速率缓慢得多</p><p>根据 cwnd 的大小执行不同的算法，可归纳如下：</p><ul><li><strong>当 cwnd &lt; ssthresh 时，使用慢开始算法</strong></li><li><strong>当 cwnd &gt; ssthresh 时，改用拥塞避免算法</strong></li><li><strong>当 cwnd = ssthresh 时，既可使用拥塞避免算法（通常做法）</strong>，又可使用慢开始算法</li></ul><h5 id="网络拥塞的处理" tabindex="-1"><a class="header-anchor" href="#网络拥塞的处理" aria-hidden="true">#</a> 网络拥塞的处理</h5><ol><li><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方<strong>判断网络出现拥塞（即出现超时重传）</strong></p><p>就要<strong>把慢开始门限 ssthresh 设置为出现拥塞时的发送方的 cwnd 值的一半</strong>，但不能小于 2</p></li><li><p>然后<strong>把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法</strong></p><p>以便迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完</p></li></ol><p>慢开始和拥塞避免算法的实现过程如下图：</p><ol><li><p>初始时，拥塞窗口置为 1，即 cwnd = 1，慢开始门限置为 16，即 ssthresh = 16</p></li><li><p>慢开始阶段，cwnd 的初值为 1，以后发送方每收到一个确认 ACK，cwnd 加 1</p><p>当拥塞窗口 cwnd 增长到慢开始门限 ssthresh 时，就改用拥塞避免算法，cwnd 按线性规律增长</p></li><li><p>假定 cwnd = 24 时网络出现超时，更新 ssthresh 值为 12，cwnd 重置为 1，执行慢开始算法</p></li></ol><figure><img src="'+T+'" alt="image-20211219155521144" tabindex="0" loading="lazy"><figcaption>image-20211219155521144</figcaption></figure><p>注意：在慢开始阶段，<strong>若 <code>2cwnd &gt; ssthresh</code>，则下一个 RTT 后的 cwnd 等于 ssthresh</strong>，而不等于 <code>2cwnd</code></p><p>在慢开始和拥塞避免算法中使用了乘法减小和加法增大方法：</p><ul><li><p>乘法减小：在慢开始阶段或拥塞避免阶段，<u>出现超时，就把慢开始门限值 ssthresh 设置为当前拥塞窗口的一半</u></p><p><strong>网络频繁出现拥塞时，ssthresh 值就下降得很快</strong>，以大大减少注入网络的分组数</p></li><li><p>加法增大：执行拥塞避免算法后，在收到对所有报文段的确认后，即经过一个 RTT</p><p>就把拥塞窗口 cwnd 增加一个 MSS 大小，<strong>使拥塞窗口缓慢增大，以防止网络过早出现拥塞</strong></p></li></ul><p>拥塞避免不是指完全避免拥塞，而是指在拥塞避免阶段把拥塞窗口控制为按线性规律增长，<strong>使网络比较不容易出现拥塞</strong></p><h4 id="快重传和快恢复" tabindex="-1"><a class="header-anchor" href="#快重传和快恢复" aria-hidden="true">#</a> 快重传和快恢复</h4><p>快重传和快恢复算法是对慢开始和拥塞避免算法的改进</p><h5 id="快重传" tabindex="-1"><a class="header-anchor" href="#快重传" aria-hidden="true">#</a> 快重传</h5><p>[TCP 可靠传输机制中](#冗余 ACK)，快重传技术使用了冗余 ACK 来检测丢包的发生</p><p>同样，<strong>冗余 ACK 也用于网络拥塞的检测</strong>，因为丢包了就意味着网络可能出现了拥塞</p><p>快重传<strong>并非取消重传计时器</strong>，而是在某些情况下可<strong>更早地重传丢失的报文段</strong></p><h5 id="快恢复" tabindex="-1"><a class="header-anchor" href="#快恢复" aria-hidden="true">#</a> 快恢复</h5><p>快恢复算法的原理如下：</p><ol><li><p>发送方连续<strong>收到三个冗余 ACK 时，执行乘法减小算法</strong>，把慢开始门限 ssthresh 设置为此时发送方 cwnd 的一半</p></li><li><p>并<strong>把 cwnd 值设置为慢开始门限 ssthresh 改变后的数值</strong>，然后开始<strong>执行拥塞避免算法</strong>，使拥塞窗口缓慢地线性增大</p><p>发送方认为网络很可能没有发生严重拥塞，否则就不会有几个报文段连续到达接收方也不会连续收到重复确认</p></li></ol><p>由于跳过了拥塞窗口 cwnd 从 1 起始的慢开始过程，所以被称为<strong>快恢复</strong></p><p>快恢复算法的实现过程如下，作为对比，虚线为慢开始的处理过程：</p><figure><img src="'+C+'" alt="image-20211219155756204" tabindex="0" loading="lazy"><figcaption>image-20211219155756204</figcaption></figure><p>在流量控制中，发送方发送数据的量<strong>由接收方决定</strong>；在拥塞控制中，则由发送方<strong>自己通过检测网络状况来决定</strong></p><p>总结：TCP <strong>连接建立和网络出现超时</strong>时，采用<strong>慢开始和拥塞避免</strong>算法；<strong>接收到冗余 ACK</strong> 时，采用<strong>快重传和快恢复</strong>算法</p>',110),b=[x,D,U];function w(_,I){return l(),a("div",null,b)}const A=o(f,[["render",w],["__file","第五章 传输层.html.vue"]]);export{A as default};
