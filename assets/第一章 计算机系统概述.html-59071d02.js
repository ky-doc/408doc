import{_ as l,X as t,Y as r,a2 as n,Z as s,a1 as a}from"./framework-0cdb5b8e.js";const i="/408doc/408noteImg/images/image-20211002131847132.png",e={},o=n('<h2 id="计算机发展历程" tabindex="-1"><a class="header-anchor" href="#计算机发展历程" aria-hidden="true">#</a> *计算机发展历程</h2><h3 id="计算机硬件的发展" tabindex="-1"><a class="header-anchor" href="#计算机硬件的发展" aria-hidden="true">#</a> 计算机硬件的发展</h3><h4 id="计算机的四代变化" tabindex="-1"><a class="header-anchor" href="#计算机的四代变化" aria-hidden="true">#</a> 计算机的四代变化</h4><p>从 1946 年世界上第一台电子数字计算机（Electronic Numerical Integrator And Computer，<code>ENIAC</code>）问世以来，计算机的发展已经经历了四代</p><ol><li>第一代计算机（1946—1957年）电子管时代，特点： <ol><li>逻辑元件采用<strong>电子管</strong></li><li>使用<strong>机器语言</strong>进行编程</li><li>主存用延迟线或磁鼓存储信息，<strong>容量极小</strong></li><li>体积庞大，成本高</li><li><strong>运算速度较低</strong>，一般只有几千次到几万次每秒</li></ol></li><li>第二代计算机（1958—1964年）晶体管时代，特点： <ol><li>逻辑元件采用<strong>晶体管</strong></li><li>运算速度提高到几万次到几十万次每秒</li><li>主存使用磁心存储器</li><li>软件<strong>开始使用高级语言</strong>，如 FORTRAN，有了操作系统的雏形</li></ol></li><li>第三代计算机（1965—1971年）中小规模集成电路时代，特点： <ol><li>逻辑元件采用<strong>中小规模集成电路</strong></li><li><strong>半导体存储器</strong>开始取代磁心存储器</li><li><strong>高级语言发展迅速</strong>，操作系统也进一步发展，开始有了分时操作系统</li></ol></li><li>第四代计算机（1972年至今）超大规模集成电路时代，特点： <ol><li>逻辑元件采用<strong>大规模集成电路和超大规模集成电路</strong>，产生了<strong>微处理器</strong></li><li>诸如并行、流水线、高速缓存和虚拟存储器等概念用在了这代计算机中</li></ol></li></ol><h4 id="计算机元件的更新换代" tabindex="-1"><a class="header-anchor" href="#计算机元件的更新换代" aria-hidden="true">#</a> 计算机元件的更新换代</h4><ol><li><p>摩尔定律：当价格不变时，集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍</p></li><li><p>半导体存储器的发展：</p><p>1970 年，仙童半导体公司生产出第一个较大容量的半导体存储器，至今，半导体存储器经历了11 代：</p><p>单芯片 <code>1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、256MB</code> 和现在的 <code>1GB</code></p></li><li><p>微处理器的发展：</p><p>自1971年Intel公司开发出第一个微处理器Intel 4004至今，微处理器经历了 Intel 8008 （8位）、Intel 8080 （8位）、Intel 8086 （16位）、Intel 8088 （16位）、Intel 80286 （16位）、Intel 80386 （32位）、Intel 80486 （32位）、Pentium （32位）、Pentium pro （64位）、Pentium II （64 位）、Pentium II （64位）、Pentium 4 （64位）等</p><p>这里的 32 位、64 位指的是机器字长，是指计算机进行一次整数运算所能处理的二进制数据的位数</p></li></ol><h3 id="计算机软件的发展" tabindex="-1"><a class="header-anchor" href="#计算机软件的发展" aria-hidden="true">#</a> 计算机软件的发展</h3><p>计算机软件技术的蓬勃发展，也为计算机系统的发展做出了很大的贡献</p><p>计算机语言的发展经历了<strong>面向机器的机器语言和汇编语言</strong>、<strong>面向问题的高级语言</strong></p><p>其中高级语言的发展真正促进了软件的发展，它经历了从科学计算和工程计算的 FORTRAN、结构化程序设计的 PASCAL 到面向对象的 C++ 和适应网络环境的 Java</p><p>直接影响计算机系统性能提升的各种系统软件也有了长足的发展，特别是操作系统，如 Windows、UNIX、Linux 等</p><p>选择题：把汇编语言源程序转变为机械语言程序的过程是汇编</p><h3 id="计算机的分类与发展方向" tabindex="-1"><a class="header-anchor" href="#计算机的分类与发展方向" aria-hidden="true">#</a> 计算机的分类与发展方向</h3><p>电子计算机可分为电子模拟计算机和电子数字计算机</p><p>数字计算机又可按用途分为<strong>专用计算机</strong>和<strong>通用计算机</strong>。这是根据计算机的效率、速格及运行的经济性和适应性来划分的</p><p>通用计算机又分为巨型机、大型机、中型机、小型机、微型机和单片机 6 类，它们的体积、功耗、性能、数据存储量、指令系统的复杂程度和价格依次递减</p><p>此外，计算机按指令和数据流还可分为：</p><ol><li>单指令流和单数据流系统（<code>SISD</code>），即传统<strong>冯·诺依曼</strong>体系结构</li><li>单指令流和多数据流系统（<code>SIMD</code>），包括阵列处理器和向量处理器系统</li><li>多指令流和单数据流系统（<code>MISD</code>），这种计算机实际上不存在</li><li>多指令流和多数据流系统（<code>MIMD</code>），包括<strong>多处理器和多计算机</strong>系统</li></ol><p>计算机的发展趋势正向着两极分化：</p><ol><li>是微型计算机向更微型化、网络化、高效能、多用途方向发展</li><li>是巨型机向更巨型化、超高速、并行处理、智能化方向发展</li></ol><h2 id="计算机系统层次结构" tabindex="-1"><a class="header-anchor" href="#计算机系统层次结构" aria-hidden="true">#</a> 计算机系统层次结构</h2><h3 id="计算机系统的组成" tabindex="-1"><a class="header-anchor" href="#计算机系统的组成" aria-hidden="true">#</a> 计算机系统的组成</h3><p><strong>硬件系统和软件系统共同构成了一个<u>完整的计算机系统</u></strong></p><p>硬件即物理设备；软件是再硬件上运行的程序和相关的数据及文档</p><p>计算机系统性能的好坏，很大程度上是由<strong>软件的效率和作用来表征的</strong>（软件的运行情况），而软件性能的发挥又离不开硬件的支持、对某一功能来说，其<strong>既可以用软件实现，又可以用硬件实现</strong>，则称为软硬件在<strong>逻辑上是等效的</strong></p><p>在设计计算机系统时，要进行软/硬件的功能分配。一个功能若使用较为频繁且用硬件实现的成本较为理想，则使用硬件解决可以提高效率。而用软件实现可以提高灵活性，但效率往往不如硬件实现高</p><h3 id="计算机硬件的基本组成" tabindex="-1"><a class="header-anchor" href="#计算机硬件的基本组成" aria-hidden="true">#</a> 计算机硬件的基本组成</h3><h4 id="早期的冯-·-诺依曼机" tabindex="-1"><a class="header-anchor" href="#早期的冯-·-诺依曼机" aria-hidden="true">#</a> 早期的冯 · 诺依曼机</h4><p>冯 · 诺依曼在研究 <code>EDVAC</code> 机时提出了存储程序的概念，存储程序的思想奠定了现代计算机的基本结构，以此概念为基础的各类计算机通称为冯 · 诺依曼机，其特点如下：</p><ol><li>计算机硬件系统由<strong>运算器、存储器、控制器、输入设备、输出设备</strong> 5 大部件组成</li><li><strong>指令和数据以同等地位存储在存储器中</strong>，并可按地址寻访</li><li>指令和数据<strong>均用二进制代码表示</strong></li><li>指令由<strong>操作码和地址码</strong>组成，操作码指出操作的类型，地址码指出操作数的地址</li><li>指令在存储器内按顺序存放。指令是<strong>顺序执行</strong>的，在特定条件下可根据运算结果或根据设定的条件改变执行顺序</li><li>早期的冯 · 诺依曼机以<strong>运算器为中心</strong>，输入/输出设备通过运算器与存储器传送数据</li></ol><p>注意：存储程序的概念是指将指令以代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束</p><p>选择题：冯 · 诺依曼机最根本的特征是采用存储程序原理，基本工作方式是<strong>控制流驱动方式</strong></p><p>选择题：冯 · 诺依曼机中指令和数据均以二进制形式存放在存储器中，CPU 区分它们的依据是<strong>指令周期的不同阶段</strong>，取值阶段取指令，执行阶段取数据</p><h4 id="现代计算机的组织结构" tabindex="-1"><a class="header-anchor" href="#现代计算机的组织结构" aria-hidden="true">#</a> 现代计算机的组织结构</h4><p>在微处理器问世之前，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递</p><p>大量 I/O 设备的速度太慢，因此以运算器为中心的结构不能够满足计算机发展的要求</p><p><strong>现代计算机已发展为以存储器为中心</strong>，使 I/O 操作尽可能地绕过 CPU，直接在 I/O 设备和存储器之间完成，以提高系统的整体运行效率</p><p>目前绝大多数现代计算机仍遵循冯 · 诺依曼的存储程序的设计思想</p><h4 id="计算机的功能部件" tabindex="-1"><a class="header-anchor" href="#计算机的功能部件" aria-hidden="true">#</a> 计算机的功能部件</h4><p>传统冯·诺依曼计算机和现代计算机的结构虽然有所不同，但<strong>功能部件是一致的</strong></p><h5 id="输入设备" tabindex="-1"><a class="header-anchor" href="#输入设备" aria-hidden="true">#</a> 输入设备</h5><p>输入设备的主要功能是<u>将程序和数据以机器所能识别和接受的形式输入计算机</u> 最常用也最基本的输入设备是键盘，此外还有鼠标、扫描仪、摄像机等</p><h5 id="输出设备" tabindex="-1"><a class="header-anchor" href="#输出设备" aria-hidden="true">#</a> 输出设备</h5><p>输出设备的任务是将计算机处理的结果<strong>以人们所能接受的形式</strong>或其他系统所要求的信息形式<strong>输出</strong></p><p>最常用、最基本的输出设备是显示器、打印机。计算机的输入/输出设备（简称 I/O 设备）是计算机与外界联系的桥梁，是计算机中不可缺少的重要组成部分</p><h5 id="存储器" tabindex="-1"><a class="header-anchor" href="#存储器" aria-hidden="true">#</a> 存储器</h5><p><strong>存储器是计算机的存储部件，用来存放程序和数据</strong></p><p>存储器分为主存储器（简称主存，也称内存储器）和辅助存储器（简称辅存，也称外存储器）</p><p>CPU 能够<strong>直接访问的主存储器</strong>。辅助存储器用于<strong>记忆更多的信息</strong>，辅助存储器中必须调入主存后，才能为CPU 所访问</p><p>主存储器是<strong>按存储单元的地址进行存取</strong>，这种存取方式称为按地址存取方式（<strong>相联存储器也可以按内容访问的</strong>）</p><p>主存储器由四个部分组成：</p><ol><li><p><strong>存储体存放二进制信息</strong>，由存储单元组成，存储单元由存储元件组成，每个存储元件存储一位的二进制代码</p><p><strong>存储单元的的长度称为存储字</strong>，存储字长是字节的偶数倍</p></li><li><p>地址寄存器（<code>MAR</code>）<strong>存放访存地址</strong>，经过地址译码后找到所选的存储单元</p><p>其位数对于着存储单元的个数，<strong>MAR 的长度与 PC 寄存器的长度相等</strong></p></li><li><p>数据寄存器（<code>MDR</code>）用于<strong>暂存要从存储器中读或写的信息</strong>，一般<strong>与存储字长相等</strong></p></li><li><p>时序控制逻辑用于产生存储器操作所需的各种时序信号（表示是读还是写操作）</p></li></ol><p>注意：<code>MAR</code> 与 <code>MDR</code> 虽然是存储器的一部分，但在现代 CPU 中却是存在于 CPU 中的；另外，后文提到的高速缓存（Cache）也存在于CPU中</p><h5 id="运算器" tabindex="-1"><a class="header-anchor" href="#运算器" aria-hidden="true">#</a> 运算器</h5><p>运算器是计算机的执行部件，用于进行<strong>算术运算和逻辑运算</strong></p><ol><li>算术运算是按算术运算规则进行的运算，如加、减、乘、除</li><li>逻辑运算包括与、或、非、异或、比较、移位等运算</li></ol><p><strong>运算器的核心是算术逻辑单元</strong> （Arithmetic and Logical Unit，ALU）</p><p>运算器包含若干通用寄存器，用于暂存操作数和中间结果，如累加器（<code>ACC</code>）、乘商寄存器（<code>MQ</code>）、操作数寄存器（X）、变址寄存器（IX）、基址寄存器（BR）等，其中前3个寄存器是必须具备的</p><p>运算器内还有程序<strong>状态寄存器</strong>（<code>PSW</code>），也称标志寄存器，用于存放 ALU 运算得到的一些标志信息或处理机的状态信息，如结果是否溢出、有无产生进位或借位、结果是否为负等</p><h5 id="控制器" tabindex="-1"><a class="header-anchor" href="#控制器" aria-hidden="true">#</a> 控制器</h5><p>控制器是计算机的指挥中心，由其“指挥”各部件自动协调地进行工作</p><p>控制器由程序计数器（PC）、指令寄存器（IR）和控制单元（CU）组成</p><ul><li>PC 用来<strong>存放当前欲执行指令的地址</strong>，可以<strong>自动加 1</strong> 以形成下一条指令的地址，它<strong>与主存的 MAR 之间有一条直接通路</strong></li><li>IR 用来<strong>存放当前的指令</strong>，其<u>内容来自主存的 MDR</u></li><li>指令中的<strong>操作码 OP(IR) 送至 CU</strong>，用以<strong>分析指令</strong>并发出各种微操作命令序列</li><li>而<strong>地址码 Ad(IR) 送往 MAR</strong>，用以<strong>取操作数</strong></li></ul><p>一般将运算器和控制器集成到同一个芯片上，称为中央处理器（CPU），<strong>CPU 和主存储器共同构成主机</strong>，而除主机外的其他硬件装置（外存、I/O设备等）统称为外部设备，简称外设</p><p>CPU 包含 ALU、通用寄存器组 <code>GPRs</code>、标志寄存器、控制器、指令寄存器 IR、程序计数器 PC、存储器地址寄存器 MAR 和存储器数据寄存器 MDR</p><p>图中从控制器送出的虚线就是控制信号：</p><ol><li>控制如何修改 PC 以得到下一条指令的地址</li><li>控制 ALU 执行什么运算</li><li>控制主存是进行读操作还是写操作（读/写控制信号）</li></ol><figure><img src="'+i+'" alt="image-20211002131847132" tabindex="0" loading="lazy"><figcaption>image-20211002131847132</figcaption></figure><p>CPU 和主存之间通过一组总线相连，总线中有地址、控制和数据 3 组信号线</p><p>MAR 中的地址信息会直接送到地址线上，用于指向读/写操作的主存存储单元</p><p>控制线中有读/写信号线，指出数据是从 MDR 写入主存，还是主存读入 MDR</p><h3 id="计算机软件的分类" tabindex="-1"><a class="header-anchor" href="#计算机软件的分类" aria-hidden="true">#</a> 计算机软件的分类</h3><h4 id="系统软件和应用软件" tabindex="-1"><a class="header-anchor" href="#系统软件和应用软件" aria-hidden="true">#</a> 系统软件和应用软件</h4><p>系统软件是一组保证计算机系统高效、正确运行的基础软件，通常<strong>作为系统资源提供给用户使用</strong>。系统软件主要有操作系统（OS)、数据库管理系统（DBMS)、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序等</p><p>应用软件是指用户为<strong>解决某个应用领域中的各类问题而编制的程序</strong>，如各种科学计算类程序、工程设计类程序、数据统计与处理程序等</p><p>简单来说就是，系统软件提供接口，而应用软件是功能的实现</p><h4 id="三个级别的语言" tabindex="-1"><a class="header-anchor" href="#三个级别的语言" aria-hidden="true">#</a> 三个级别的语言</h4><ol><li>机器语言：又称二进制代码语言，机器语言是计算机<strong>唯一可以直接识别和执行的语言</strong></li><li>汇编语言：汇编语言用英文单词或其缩写代替二进制的指令代码，使用汇编语言编辑的程序，<strong>必须经过汇编程序的系统软件的翻译</strong>，转换为机器语言后，才能在计算机的硬件系统上执行</li><li>高级语言：高级语言是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言<strong>需要经过编译程序编译成汇编语言程序</strong>，然后经过<strong>汇编操作得到机器语言程序</strong>，或<strong>直接由高级语言程序翻译成机器语言程序</strong></li></ol><h3 id="计算机工作步骤" tabindex="-1"><a class="header-anchor" href="#计算机工作步骤" aria-hidden="true">#</a> 计算机工作步骤</h3><p>计算机的工作过程分为以下三个步骤：</p><ol><li>把源程序和数据装入主存储器</li><li>将源程序转换成可执行文件</li><li>从可执行文件的首地址开始逐条执行指令</li></ol><h4 id="从源程序到可执行程序" tabindex="-1"><a class="header-anchor" href="#从源程序到可执行程序" aria-hidden="true">#</a> 从源程序到可执行程序</h4><p>C 语言程序都必须被<strong>转换为一系列的低级机器指令</strong>，这些指令按照一种称为<strong>可执行目标文件的格式打好包</strong>，并以<strong>二进制磁盘文件的形式存放起来</strong></p><p>以 UNIX 系统中的 GCC 编译器程序为例，翻译源程序文件 <code>hello.c</code> 的整个翻译过程可分为4个阶段完成：</p><ol><li>预处理阶段：对<strong>预处理语句</strong>（以 ## 开头）进行编译，输出结果是一个以 .i 为扩展名的源文件 <code>hello.i</code></li><li>编译阶段：编译器（<code>ccl</code>）<strong>生成一个汇编语言源程序</strong> <code>hello.s</code></li><li>汇编阶段：汇编器（as）将 <code>hello.s</code> <strong>翻译成机器语言指令</strong>，打包成一个称为可重定位目标文件的 <code>hello.o</code></li><li>链接阶段：链接器（<code>ld</code>）<strong>将多个可重定位目标文件</strong>和标准库函数<strong>合并为一个可执行目标文件</strong>，或简称可执行文件</li></ol><p>选择题：硬件描述语言程序是一种描述电路的代码，计算机不可直接执行</p><h4 id="指令执行过程的描述" tabindex="-1"><a class="header-anchor" href="#指令执行过程的描述" aria-hidden="true">#</a> 指令执行过程的描述</h4><p>PC 寄存器存放第一条指令位置，根据 PC 取出第一条指令，经过译码、执行步骤等，控制计算机各功能部件协同运行，完成这条指令的功能，并计算下一条指令的地址，用新得到的指令地址继续读出第二条指令并执行，直到程序结束为止</p><p>下面以取数指令为例进行说明，其信息流程如下：</p><ol><li><strong>取指令</strong>：(PC)→MAR→M→MDR→IR 根据 PC 取指令到 IR <ol><li>将 PC 的内容送 MAR</li><li>MAR 中的内容直接送地址线</li><li>控制器将读信号送读/写信号线</li><li>主存根据地址线上的地址和读信号，从指定存储单元读出指令，送到数据线上</li><li>MDR 从数据线接收指令信息，并传送到 IR 中</li></ol></li><li><strong>分析指令</strong>：OP(IR)→CU 指令译码并送出控制信号 <ul><li>控制器根据 IR 中指令的操作码，生成相应的控制信号，送到不同的执行部件</li><li>这里是取数指令，因此读控制信号被送到总线的控制线上</li></ul></li><li><strong>执行指令</strong>：Ad(IR)→MAR→M→MDR→ACC 取数操作 <ol><li>将 IR 中指令的地址码送 MAR，MAR 中的内容送地址线</li><li>控制器将读信号送读/写信号线，从主存指定存储单元读出操作数</li><li>通过数据线送至 MDR 再传送到 ACC 中</li><li>取完一条指令，还须为取下一条指令做准备，形成下一条指令的地址，即 (PC) + 1→PC</li></ol></li></ol><h3 id="计算机系统的多级层次结构" tabindex="-1"><a class="header-anchor" href="#计算机系统的多级层次结构" aria-hidden="true">#</a> 计算机系统的多级层次结构</h3><p><strong>现代计算机是一个硬件与软件组成的综合体</strong>。由于计算机越来越复杂，所以使用分层模式把整个领域，分成多个层次，让负责每个层次的人仅需关心自己负责的区域，而不需要关心下层的实现，以便构成合理、高效的计算机系统</p><ol><li>第 1 级是微程序机器层，这是一个实在的硬件层，它由机器硬件直接执行微指令（即一个指令执行的每个过程）</li><li>第 2 级是传统机器语言层，它也是一个实际的机器层，·由微程序解释机器指令系统</li><li>第 3 级是操作系统层，它由操作系统程序实现。操作系统程序是由机器指令和广义指令组成的，这些广义指令是为了扩展机器功能而设置的，是由操作系统定义和解释的软件指令，所以这一层也称混合层</li><li>第 4 级是汇编语言层，它为用户提供一种符号化的语言，借此可编写汇编语言源程序，这一层由汇编程序支持和执行</li><li>第 5 级是高级语言层，它是面向用户的，是为方便用户编写应用程序而设置的，该层由各种高级语言编译程序支持和执行</li></ol><p>在<strong>高级语言层之上，还可以有应用程序层</strong>，它由解决实际问题和应用问题的处理程序组成，如文字处理软件、数据库软件、多媒体处理软件和办公自动化软件等</p><p><strong>把没有配备软件的纯硬件系统称为裸机</strong>。第 3 层～第 5 层称为虚拟机，简单来说就是软件实现的机器。虚拟机只对该层的观察者存在，这里的分层和计算机网络的分层类似，对于某层的观察者来说，只能通过该层次的语言来了解和使用计算机，而不必关心下层是如何工作的</p><p>层次之间的关系紧密，<strong>下层是上层的基础，上层是下层的扩展</strong>。随着超大规模集成电路技术的不断发展，<strong>部分软件功能将由硬件来实现</strong>，因而软/硬件交界面的划分也不是绝对的</p><h2 id="计算机性能的指标" tabindex="-1"><a class="header-anchor" href="#计算机性能的指标" aria-hidden="true">#</a> 计算机性能的指标</h2><h3 id="计算机的主要性能指标" tabindex="-1"><a class="header-anchor" href="#计算机的主要性能指标" aria-hidden="true">#</a> 计算机的主要性能指标</h3><h4 id="机械字长" tabindex="-1"><a class="header-anchor" href="#机械字长" aria-hidden="true">#</a> 机械字长</h4><p>机器字长是指计算机<strong>进行一次整数运算所能处理的二进制数据的位数</strong>，通常与 CPU 的寄存器位数、加法器有关</p><p><strong>机器字长一般等于内部寄存器的大小</strong>，字长越长，数的表示范围越大，计算精度越高</p><p>计算机字长通常选定为字节（8位）的整数倍</p><h4 id="数据通路带宽" tabindex="-1"><a class="header-anchor" href="#数据通路带宽" aria-hidden="true">#</a> 数据通路带宽</h4><p>数据通路带宽是指<strong>数据总线一次所能并行传送信息的位数</strong></p><p>数据通路宽度是指<strong>外部数据总线的宽度</strong>，它与 CPU 内部的数据总线宽度有可能不同</p><p>注意：各个子系统通过数据总线连接形成的数据传送路径称为数据通路</p><h4 id="主存容量" tabindex="-1"><a class="header-anchor" href="#主存容量" aria-hidden="true">#</a> 主存容量</h4><p>主存容量是指<strong>主存储器所能存储信息的最大容量</strong>，通常以字节来衡量，也可用字数 × 字长（如 <code>512K×16</code> 位）来表示存储容量</p><p>其中，MAR 的位数反映存储单元的个数，MAR 的位数反映可寻址范围的最大值（而不一定是实际存储器的存储容量）</p>',110),p=s("p",null,[a("例如，MAR 为 16 位，表示 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mn",null,"16")]),s("mo",null,"="),s("mn",null,"65536")]),s("annotation",{encoding:"application/x-tex"},"2^{16}= 65536")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8141em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"16")])])])])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"65536")])])]),a("，即此存储体内有 65536 个存储单元；若 MDR 为 32 位，表示每次取 32 位的数据，存储容量写作 "),s("code",null,"64K×32"),a(" 位")],-1),h=n('<h4 id="运算速度" tabindex="-1"><a class="header-anchor" href="#运算速度" aria-hidden="true">#</a> 运算速度</h4><h5 id="吞吐量和响应时间" tabindex="-1"><a class="header-anchor" href="#吞吐量和响应时间" aria-hidden="true">#</a> 吞吐量和响应时间</h5><ul><li><p>吞吐量：指<strong>系统在单位时间内处理请求的数量</strong></p><p>它取决于信息能多快地输入内存，CPU 能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备</p><p>几乎每步都关系到主存，因此<strong>系统吞吐量主要取决于主存的存取周期</strong></p></li><li><p>响应时间：指从<u>用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间</u></p><p>通常包括 CPU 时间（执行时间）与等待时间（I/O 时间）</p></li></ul><h5 id="主频和-cpu-时钟周期" tabindex="-1"><a class="header-anchor" href="#主频和-cpu-时钟周期" aria-hidden="true">#</a> 主频和 CPU 时钟周期</h5><ul><li><p>主频（CPU 时钟频率）：<strong>机器内部主时钟的频率</strong>，是衡量机器速度的重要参数</p><p>对于同一个型号的计算机，其主频越高，完成指令的一个执行步骤所用的时间越短，执行指令的速度越快</p></li><li><p>CPU时钟周期：通常为节拍脉冲或 T 周期，即<strong>主频的倒数</strong>，它是 CPU 中<strong>最小的时间单位</strong>，执行指令的每个动作至少需要 1 个时钟周期</p></li></ul><h5 id="cpi-指令执行周期" tabindex="-1"><a class="header-anchor" href="#cpi-指令执行周期" aria-hidden="true">#</a> CPI 指令执行周期</h5><p>CPI（Clock cycle Per Instruction）：即执行<strong>一条指令所需的时钟周期数</strong></p><p>不同指令的时钟周期数可能不同，因此对于一个程序或一台机器来说，其 CPI 指该程序或该机器指令集中的<strong>所有指令执行所需的平均时钟周期数</strong>，此时 CPI 是一个平均值</p><h5 id="cpu-执行时间" tabindex="-1"><a class="header-anchor" href="#cpu-执行时间" aria-hidden="true">#</a> CPU 执行时间</h5><p>CPU 执行时间：指<strong>运行一个程序所花费的时间</strong></p><p>CPU 执行时间 = CPU 时钟周期数 / 主频 = (指令条数 × CPI) / 主频</p><p>CPU 执行时间取决于三个要素：</p><ol><li>主频（时钟频率）</li><li>每条指令执行所用的时钟周期数（CPI）</li><li>指令条数</li></ol><p>主频、CPI 和指令条数是相互制约的，<strong>更改指令集可以减少程序所含指令的条数</strong>，但同时可能引起 CPU 结构的调整，从而<strong>可能会增加时钟周期的宽度</strong>（降低主频）</p><p>选择题：CPU 的 CPI 与时钟频率无关，因为时钟频率的变化并不会影响 CPI</p><h5 id="mips" tabindex="-1"><a class="header-anchor" href="#mips" aria-hidden="true">#</a> MIPS</h5><p>MIPS（Million Instructions Per Second），即<strong>每秒执行多少百万条指令</strong></p>',17),c=s("p",null,[a("MIPS = 指令条数 / (执行时间 × "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1"),s("msup",null,[s("mn",null,"0"),s("mn",null,"6")])]),s("annotation",{encoding:"application/x-tex"},"10^6")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8141em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mord"},[s("span",{class:"mord"},"0"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"6")])])])])])])])])])]),a(")=主频 / (CPI × "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1"),s("msup",null,[s("mn",null,"0"),s("mn",null,"6")])]),s("annotation",{encoding:"application/x-tex"},"10^6")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8141em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mord"},[s("span",{class:"mord"},"0"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"6")])])])])])])])])])]),a(")")],-1),g=s("p",null,[a("MIPS 对不同机器进行性能比较是有缺陷的，因为在机器 "),s("code",null,"M1"),a(" 上某条指令的功能，在机器 "),s("code",null,"M2"),a(" 上要用多条指令来完成")],-1),d=s("p",null,[s("u",null,"不同机器的 CPI 和时钟周期也不同，因而同一条指合在不同机器上所用的时间也不同")],-1),m=s("h5",{id:"浮点数指标",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#浮点数指标","aria-hidden":"true"},"#"),a(" 浮点数指标")],-1),u=s("ul",null,[s("li",null,[s("code",null,"MFLOPS"),a("（Mega Floating-point Operations Per Second），即每秒执行多少百万次浮点运算")]),s("li",null,[s("code",null,"GFLOPS"),a("（Giga Floating-point Operations Per Second），即每秒执行多少十亿次浮点运算")]),s("li",null,[s("code",null,"TFLOPS"),a("（Tera Floating-point Operations Per Second），即每秒执行多少万亿次浮点运算")]),s("li",null,[s("code",null,"PFLOPS"),a(" = 浮点操作次数（执行时间×"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1"),s("msup",null,[s("mn",null,"0"),s("mn",null,"15")])]),s("annotation",{encoding:"application/x-tex"},"10^{15}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8141em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mord"},[s("span",{class:"mord"},"0"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"15")])])])])])])])])])])]),a("）")]),s("li",null,[s("code",null,"EFLOPS"),a(" = 浮点操作次数（执行时间×"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1"),s("msup",null,[s("mn",null,"0"),s("mn",null,"18")])]),s("annotation",{encoding:"application/x-tex"},"10^{18}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8141em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mord"},[s("span",{class:"mord"},"0"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"18")])])])])])])])])])])]),a("）")]),s("li",null,[s("code",null,"ZFLOPS"),a(" = 浮点操作次数（执行时间×"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1"),s("msup",null,[s("mn",null,"0"),s("mn",null,"21")])]),s("annotation",{encoding:"application/x-tex"},"10^{21}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8141em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mord"},[s("span",{class:"mord"},"0"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"21")])])])])])])])])])])]),a("）")])],-1),x=s("p",null,[a("注意：在描述存储容量、文件大小等时，K、M、G、T 通常用 2 的幂次表示，如 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1"),s("mi",null,"K"),s("mi",null,"b"),s("mo",null,"="),s("msup",null,[s("mn",null,"2"),s("mn",null,"10")]),s("mi",null,"b")]),s("annotation",{encoding:"application/x-tex"},"1Kb =2^{10}b")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"K"),s("span",{class:"mord mathnormal"},"b"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8141em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"10")])])])])])])])]),s("span",{class:"mord mathnormal"},"b")])])]),a("；在描述速率、频率等时，k、M、G、T 通常用 10 的幂次表示，如 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1"),s("mi",null,"k"),s("mi",null,"b"),s("mi",{mathvariant:"normal"},"/"),s("mi",null,"s"),s("mo",null,"="),s("mn",null,"1"),s("msup",null,[s("mn",null,"0"),s("mn",null,"3")]),s("mi",null,"b"),s("mi",{mathvariant:"normal"},"/"),s("mi",null,"s")]),s("annotation",{encoding:"application/x-tex"},"1kb/s = 10^3b/s")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mord mathnormal"},"kb"),s("span",{class:"mord"},"/"),s("span",{class:"mord mathnormal"},"s"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mord"},[s("span",{class:"mord"},"0"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"3")])])])])])])]),s("span",{class:"mord mathnormal"},"b"),s("span",{class:"mord"},"/"),s("span",{class:"mord mathnormal"},"s")])])])],-1),M=n('<h4 id="基准程序" tabindex="-1"><a class="header-anchor" href="#基准程序" aria-hidden="true">#</a> 基准程序</h4><p>基准程序（Benchmarks）是<strong>通过运行时间来评价性能的一组程序</strong>，能够很好反映机器在运行实际负载时的性能</p><p>但有些机器在硬件上仅优化了基准程序使用的指令，导致基准程序运行得很快，得不到准确的性能评测结果</p><h3 id="几个专业术语" tabindex="-1"><a class="header-anchor" href="#几个专业术语" aria-hidden="true">#</a> 几个专业术语</h3><ol><li>系列机：具有<strong>基本相同的体系结构</strong>，使用<strong>相同基本指令系统</strong>的多个<strong>不同型号</strong>的计算机组成的一个产品系列</li><li>兼容：指<strong>计算机软件或硬件的通用性</strong>，即使用或运行在某个型号的计算机系统中的硬件/软件也能应用于另一个型号的计算机系统时，称这两台计算机在硬件或软件上存在兼容性，如 32 位的软件能在 64 位中运行</li><li>软件可移植性：指把使用在<strong>某个系列计算机中的软件</strong>直接或进行很少的修改就能<strong>运行在另一个系列计算机中的可能性</strong></li><li>固件：<strong>将程序固定在 ROM 中组成的部件称为固件</strong>。固件是一种具有软件特性的硬件，固件的性能指标介于硬件与软件之间，吸收了软/硬件各自的优点，其执行速度快于软件，灵活性优于硬件，是软/硬件结合的产物</li></ol><h2 id="常见问题和易混淆知识点" tabindex="-1"><a class="header-anchor" href="#常见问题和易混淆知识点" aria-hidden="true">#</a> 常见问题和易混淆知识点</h2><ol><li><p>同一个功能既可以由软件实现又可以由硬件实现吗？</p><p>在逻辑功能上，软件和硬件是等效的。许多功能<strong>既可以由硬件直接实现，又可以在硬件的配合下由软件实现</strong></p><p>乘法运算既可用专门的乘法器实现，硬件电路；也可用乘法子程序来实现，多个加法指令</p></li><li><p>翻译程序、汇编程序、编译程序、解释程序的区别和联系是什么？</p><p>翻译程序是指把高级语言源程序翻译成机器语言程序的软件，翻译程序有两种：</p><ol><li>编译程序：它将高级语言源程序一次全部翻译成目标程序，每次执行程序时，只需执行目标程序</li><li>解释程序：它将源程序的一条语句翻译成对应的机器目标代码，并立即执行，不会生成目标程序</li></ol><p>汇编程序也是一种语言翻译程序，它<strong>把汇编语言源程序翻译为机器语言程序</strong>，汇编语言与机器语言一一对应</p><p>编译程序与汇编程序的区别：</p><p>若源语言是高级语言，而目标语言是汇编语言或机器语言之类的低级语言，则这样的一个翻译程序称为编译程序</p><p>若源语言是汇编语言，而目标语言是机器语言，则这样的一个翻译程序称为汇编程序</p></li><li><p>什么是透明性？透明是指什么都能看见吗？</p><p>在计算机领域中，站在某类用户的角度，若<strong>感觉不到某个事物或属性的存在</strong>，则称某个事物或属性是<strong>透明的</strong></p><p>如在 CPU 中，IR、MAR 和 MDR 对各类程序员都是透明的</p></li><li><p>机器字长、指令字长、存储字长的区别和联系是什么？</p><ul><li>机器字长：计算机<strong>能直接处理的二进制数据的位数</strong>，机器字长一般等于<strong>内部寄存器的大小</strong>，它<strong>决定了计算机的运算精度</strong></li><li>指令字长：一个<strong>指令字中</strong>包含的<strong>二进制代码的位数</strong></li><li>存储字长：一个<strong>存储单元</strong>存储的<strong>二进制代码的长度</strong></li></ul><p>一般指令字长取<strong>存储字长的整数倍</strong>，若指令字长等于存储字长的 2 倍，则需要 2 次访存来取出一条指令，因此取指周期为机器周期的 2 倍</p><p>早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据</p><p>随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍</p></li><li><p>计算机体系结构和计算机组成的区别和联系是什么？</p><p><strong>计算机体系结构</strong>是指<strong>机器语言或汇编语言程序员所看得到的传统机器的属性</strong>，包括指令集、数据类型、存储器寻址技术等，大都属于抽象的属性（接口）</p><p><strong>计算机组成</strong>是指<strong>如何实现计算机体系结构所体现的属性</strong>，它包含对许多对程序员来说透明分析指令、取摩的硬件细节</p><p>许多计算机厂商提供一系列体系结构相同的计算机，而它们的组成却有相当大的差别，即使是同一系列的不同型号机器，其性能和价格差异也很大</p></li><li><p>基准程序执行得越快说明机器的性能越好吗？</p><p>一般情况下，基准测试程序能够反映机器性能的好坏</p><p>但是，由于基准程序中的语句存在频度的差异，因此<strong>运行结果并不能完全说明问题</strong></p></li></ol>',7),P=[o,p,h,c,g,d,m,u,x,M];function b(C,I){return t(),r("div",null,P)}const R=l(e,[["render",b],["__file","第一章 计算机系统概述.html.vue"]]);export{R as default};
