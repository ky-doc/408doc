<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.61" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://ky-doc.github.io/mydoc/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html"><meta property="og:site_name" content="研小布「考研资料站」"><meta property="og:title" content="第五章 树和二叉树"><meta property="og:description" content="树的基本概念 树的定义 树是 n（$n\geq0$）个结点的有限集。当 n = 0 时，称为空树，在任意一棵非空树中应满足： 1. 有且仅有一个特定的称为根的结点 2. 当 n > 1 时，其余结点可分为 m（m > 0）个互不相交的有限集 $T1,\cdots,Tm$，其中每个集合本身又是一棵树，并称为根的子树 树的定义是递归的，在树的定义中又用到了..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-04-23T10:21:12.000Z"><meta property="article:author" content="研小布"><meta property="article:modified_time" content="2023-04-23T10:21:12.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"第五章 树和二叉树","image":[""],"dateModified":"2023-04-23T10:21:12.000Z","author":[{"@type":"Person","name":"研小布","url":"https://ky-doc.github.io/mydoc/"}]}</script><title>第五章 树和二叉树 | 研小布「考研资料站」</title><meta name="description" content="树的基本概念 树的定义 树是 n（$n\geq0$）个结点的有限集。当 n = 0 时，称为空树，在任意一棵非空树中应满足： 1. 有且仅有一个特定的称为根的结点 2. 当 n > 1 时，其余结点可分为 m（m > 0）个互不相交的有限集 $T1,\cdots,Tm$，其中每个集合本身又是一棵树，并称为根的子树 树的定义是递归的，在树的定义中又用到了...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/408doc/assets/style-3c304d4b.css" as="style"><link rel="stylesheet" href="/408doc/assets/style-3c304d4b.css">
    <link rel="modulepreload" href="/408doc/assets/app-c8d08271.js"><link rel="modulepreload" href="/408doc/assets/framework-0cdb5b8e.js"><link rel="modulepreload" href="/408doc/assets/第五章 树与二叉树.html-2b301d3b.js"><link rel="modulepreload" href="/408doc/assets/第五章 树与二叉树.html-7912f703.js"><link rel="prefetch" href="/408doc/assets/index.html-f3caf56d.js" as="script"><link rel="prefetch" href="/408doc/assets/408comeon.html-6ebe59f7.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-2fe497c8.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-6c1be11e.js" as="script"><link rel="prefetch" href="/408doc/assets/assembler.html-c5b7603d.js" as="script"><link rel="prefetch" href="/408doc/assets/Cbase.html-ab6c11e3.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-de8f8285.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-3754a632.js" as="script"><link rel="prefetch" href="/408doc/assets/第一章 计算机网络体系结构.html-4c93907b.js" as="script"><link rel="prefetch" href="/408doc/assets/第三章 数据链路层.html-919ccd1a.js" as="script"><link rel="prefetch" href="/408doc/assets/第二章 物理层.html-c97b3f4e.js" as="script"><link rel="prefetch" href="/408doc/assets/第五章 传输层.html-eec4ff65.js" as="script"><link rel="prefetch" href="/408doc/assets/第六章 应用层.html-726f2d89.js" as="script"><link rel="prefetch" href="/408doc/assets/第四章 网络层.html-7d5b2104.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-6991abd4.js" as="script"><link rel="prefetch" href="/408doc/assets/第一章 计算机系统概述.html-9787b137.js" as="script"><link rel="prefetch" href="/408doc/assets/第七章 输入输出系统.html-e408054d.js" as="script"><link rel="prefetch" href="/408doc/assets/第三章 存储系统.html-b3bd2a5f.js" as="script"><link rel="prefetch" href="/408doc/assets/第二章 数据的表示和运算.html-f6040afb.js" as="script"><link rel="prefetch" href="/408doc/assets/第五章 中央处理器.html-02d54831.js" as="script"><link rel="prefetch" href="/408doc/assets/第六章 总线.html-2d43a5d1.js" as="script"><link rel="prefetch" href="/408doc/assets/第四章 指令系统.html-c1a36d1c.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-1b88d9eb.js" as="script"><link rel="prefetch" href="/408doc/assets/第一章 绪论.html-d790a851.js" as="script"><link rel="prefetch" href="/408doc/assets/第七章 查找.html-045240fc.js" as="script"><link rel="prefetch" href="/408doc/assets/第三章 栈、队列和数组.html-cb32dc7e.js" as="script"><link rel="prefetch" href="/408doc/assets/第二章 线性表.html-1ab198f2.js" as="script"><link rel="prefetch" href="/408doc/assets/第八章 排序.html-cf794ec6.js" as="script"><link rel="prefetch" href="/408doc/assets/第六章 图.html-de3256fd.js" as="script"><link rel="prefetch" href="/408doc/assets/第四章 串.html-9a61f92c.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-700f5715.js" as="script"><link rel="prefetch" href="/408doc/assets/第一章 操作系统的基本概念.html-609759ea.js" as="script"><link rel="prefetch" href="/408doc/assets/第三章 内存管理.html-052e5b4f.js" as="script"><link rel="prefetch" href="/408doc/assets/第二章 进程管理.html-e90852d1.js" as="script"><link rel="prefetch" href="/408doc/assets/第五章 输入输出管理.html-aced0bdf.js" as="script"><link rel="prefetch" href="/408doc/assets/第四章 文件管理.html-b239627b.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary.html-f23f3973.js" as="script"><link rel="prefetch" href="/408doc/assets/1-physical-layer.html-089c9e70.js" as="script"><link rel="prefetch" href="/408doc/assets/2-data-link-layer.html-5cd4393a.js" as="script"><link rel="prefetch" href="/408doc/assets/3-network-layer.html-afb46e2d.js" as="script"><link rel="prefetch" href="/408doc/assets/4-transport-layer.html-b68dff0c.js" as="script"><link rel="prefetch" href="/408doc/assets/5-application-layer.html-7ec7180c.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-802237ec.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary.html-64e148e3.js" as="script"><link rel="prefetch" href="/408doc/assets/1-data-representation-and-operation.html-d4dc9a06.js" as="script"><link rel="prefetch" href="/408doc/assets/2-storage-system.html-cce076c0.js" as="script"><link rel="prefetch" href="/408doc/assets/3-instruction-system.html-a401042b.js" as="script"><link rel="prefetch" href="/408doc/assets/4-central-processing-unit.html-72dc5acc.js" as="script"><link rel="prefetch" href="/408doc/assets/5-bus.html-e1b68efa.js" as="script"><link rel="prefetch" href="/408doc/assets/6-input-output-system.html-8e65b5b0.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-5f693d8f.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary.html-b989714a.js" as="script"><link rel="prefetch" href="/408doc/assets/1-linear-list.html-bf60e9c2.js" as="script"><link rel="prefetch" href="/408doc/assets/2-stack.html-2b5d4dcd.js" as="script"><link rel="prefetch" href="/408doc/assets/5-string.html-4f11e25b.js" as="script"><link rel="prefetch" href="/408doc/assets/6-tree.html-563e159b.js" as="script"><link rel="prefetch" href="/408doc/assets/7-graph.html-d72196dc.js" as="script"><link rel="prefetch" href="/408doc/assets/8-search.html-b7487118.js" as="script"><link rel="prefetch" href="/408doc/assets/9-sort.html-e2780b3b.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-245528fa.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary.html-6f70cf45.js" as="script"><link rel="prefetch" href="/408doc/assets/1-process-management.html-cb66e14b.js" as="script"><link rel="prefetch" href="/408doc/assets/2-memory-management.html-40ece69e.js" as="script"><link rel="prefetch" href="/408doc/assets/3-file-management.html-e4fadd31.js" as="script"><link rel="prefetch" href="/408doc/assets/4-device-management.html-c004cdea.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-2c943bae.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary-ex.html-af600529.js" as="script"><link rel="prefetch" href="/408doc/assets/1-physical-layer-ex.html-a14aeb69.js" as="script"><link rel="prefetch" href="/408doc/assets/2-data-link-layer-ex.html-68848299.js" as="script"><link rel="prefetch" href="/408doc/assets/3-network-layer-ex.html-d0f425b3.js" as="script"><link rel="prefetch" href="/408doc/assets/4-transport-layer-ex.html-44fcde47.js" as="script"><link rel="prefetch" href="/408doc/assets/5-application-layer-ex.html-3e95cb76.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-eb2dd9c9.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary-ex.html-c7915484.js" as="script"><link rel="prefetch" href="/408doc/assets/1-data-representation-and-operation-ex.html-5adabc9e.js" as="script"><link rel="prefetch" href="/408doc/assets/2-storage-system-ex.html-6518bb77.js" as="script"><link rel="prefetch" href="/408doc/assets/3-instruction-system-ex.html-185f0273.js" as="script"><link rel="prefetch" href="/408doc/assets/4-central-processing-unit-ex.html-a1ad14f4.js" as="script"><link rel="prefetch" href="/408doc/assets/5-bus-ex.html-6dc23956.js" as="script"><link rel="prefetch" href="/408doc/assets/6-input-output-system-ex.html-bdf3f126.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-17029a33.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary-ex.html-cae17ed6.js" as="script"><link rel="prefetch" href="/408doc/assets/1-linear-list-ex.html-14824e9b.js" as="script"><link rel="prefetch" href="/408doc/assets/2-stack-ex.html-a6bb1e59.js" as="script"><link rel="prefetch" href="/408doc/assets/5-string-ex.html-4ca348ab.js" as="script"><link rel="prefetch" href="/408doc/assets/6-tree-ex.html-9f1ddee3.js" as="script"><link rel="prefetch" href="/408doc/assets/7-graph-ex.html-3782643c.js" as="script"><link rel="prefetch" href="/408doc/assets/8-search-ex.html-fbb6bfab.js" as="script"><link rel="prefetch" href="/408doc/assets/9-sort-ex.html-0547941a.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-816675b0.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary-ex.html-169f1e11.js" as="script"><link rel="prefetch" href="/408doc/assets/1-process-management-ex.html-80fa0ed1.js" as="script"><link rel="prefetch" href="/408doc/assets/2-memory-management-ex.html-3ba88312.js" as="script"><link rel="prefetch" href="/408doc/assets/3-file-management-ex.html-9b005e88.js" as="script"><link rel="prefetch" href="/408doc/assets/4-device-management-ex.html-e9604216.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-1cdd9d64.js" as="script"><link rel="prefetch" href="/408doc/assets/404.html-f6348886.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-fc37095a.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-945c1a7d.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-2aa0b05d.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-2b8f42ce.js" as="script"><link rel="prefetch" href="/408doc/assets/408comeon.html-3f4be526.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-750d153a.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-30ba0fd6.js" as="script"><link rel="prefetch" href="/408doc/assets/assembler.html-cc91330a.js" as="script"><link rel="prefetch" href="/408doc/assets/Cbase.html-4e08240d.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-7e8e766a.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-aa75103c.js" as="script"><link rel="prefetch" href="/408doc/assets/第一章 计算机网络体系结构.html-3df4f4f0.js" as="script"><link rel="prefetch" href="/408doc/assets/第三章 数据链路层.html-14888210.js" as="script"><link rel="prefetch" href="/408doc/assets/第二章 物理层.html-5d300969.js" as="script"><link rel="prefetch" href="/408doc/assets/第五章 传输层.html-49840b07.js" as="script"><link rel="prefetch" href="/408doc/assets/第六章 应用层.html-e29ffada.js" as="script"><link rel="prefetch" href="/408doc/assets/第四章 网络层.html-39cf2812.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-0ec09b36.js" as="script"><link rel="prefetch" href="/408doc/assets/第一章 计算机系统概述.html-59071d02.js" as="script"><link rel="prefetch" href="/408doc/assets/第七章 输入输出系统.html-dd6213e7.js" as="script"><link rel="prefetch" href="/408doc/assets/第三章 存储系统.html-068df467.js" as="script"><link rel="prefetch" href="/408doc/assets/第二章 数据的表示和运算.html-6a6a036b.js" as="script"><link rel="prefetch" href="/408doc/assets/第五章 中央处理器.html-519de68a.js" as="script"><link rel="prefetch" href="/408doc/assets/第六章 总线.html-1ae65a92.js" as="script"><link rel="prefetch" href="/408doc/assets/第四章 指令系统.html-99c59951.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-31a2b6a7.js" as="script"><link rel="prefetch" href="/408doc/assets/第一章 绪论.html-0eb2758c.js" as="script"><link rel="prefetch" href="/408doc/assets/第七章 查找.html-2479c6d5.js" as="script"><link rel="prefetch" href="/408doc/assets/第三章 栈、队列和数组.html-920aa592.js" as="script"><link rel="prefetch" href="/408doc/assets/第二章 线性表.html-b37f08c1.js" as="script"><link rel="prefetch" href="/408doc/assets/第八章 排序.html-4a546af4.js" as="script"><link rel="prefetch" href="/408doc/assets/第六章 图.html-85928e48.js" as="script"><link rel="prefetch" href="/408doc/assets/第四章 串.html-894731bf.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-a596ffbf.js" as="script"><link rel="prefetch" href="/408doc/assets/第一章 操作系统的基本概念.html-68157801.js" as="script"><link rel="prefetch" href="/408doc/assets/第三章 内存管理.html-588e1a30.js" as="script"><link rel="prefetch" href="/408doc/assets/第二章 进程管理.html-3c8f8367.js" as="script"><link rel="prefetch" href="/408doc/assets/第五章 输入输出管理.html-84ce04f1.js" as="script"><link rel="prefetch" href="/408doc/assets/第四章 文件管理.html-8e874daa.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary.html-5405b8b5.js" as="script"><link rel="prefetch" href="/408doc/assets/1-physical-layer.html-0fa046fa.js" as="script"><link rel="prefetch" href="/408doc/assets/2-data-link-layer.html-5e32d4f3.js" as="script"><link rel="prefetch" href="/408doc/assets/3-network-layer.html-16e1c681.js" as="script"><link rel="prefetch" href="/408doc/assets/4-transport-layer.html-d654636d.js" as="script"><link rel="prefetch" href="/408doc/assets/5-application-layer.html-b6913b35.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-c815c58d.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary.html-ff368639.js" as="script"><link rel="prefetch" href="/408doc/assets/1-data-representation-and-operation.html-4d9d1d2a.js" as="script"><link rel="prefetch" href="/408doc/assets/2-storage-system.html-c08dce2f.js" as="script"><link rel="prefetch" href="/408doc/assets/3-instruction-system.html-3e6c6c5d.js" as="script"><link rel="prefetch" href="/408doc/assets/4-central-processing-unit.html-5df2a4ba.js" as="script"><link rel="prefetch" href="/408doc/assets/5-bus.html-7afaedf0.js" as="script"><link rel="prefetch" href="/408doc/assets/6-input-output-system.html-0370933e.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-38be5f21.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary.html-5b270773.js" as="script"><link rel="prefetch" href="/408doc/assets/1-linear-list.html-7e7714bb.js" as="script"><link rel="prefetch" href="/408doc/assets/2-stack.html-032066f1.js" as="script"><link rel="prefetch" href="/408doc/assets/5-string.html-f55d8c54.js" as="script"><link rel="prefetch" href="/408doc/assets/6-tree.html-a5c94adf.js" as="script"><link rel="prefetch" href="/408doc/assets/7-graph.html-0873bc9a.js" as="script"><link rel="prefetch" href="/408doc/assets/8-search.html-86e3635b.js" as="script"><link rel="prefetch" href="/408doc/assets/9-sort.html-d04dd96a.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-7c74131d.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary.html-73f847d6.js" as="script"><link rel="prefetch" href="/408doc/assets/1-process-management.html-e6110b82.js" as="script"><link rel="prefetch" href="/408doc/assets/2-memory-management.html-43911ea5.js" as="script"><link rel="prefetch" href="/408doc/assets/3-file-management.html-7c223ca0.js" as="script"><link rel="prefetch" href="/408doc/assets/4-device-management.html-5b67e4d3.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-db07ad7b.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary-ex.html-cb5b666b.js" as="script"><link rel="prefetch" href="/408doc/assets/1-physical-layer-ex.html-6f95bd58.js" as="script"><link rel="prefetch" href="/408doc/assets/2-data-link-layer-ex.html-15b6fc83.js" as="script"><link rel="prefetch" href="/408doc/assets/3-network-layer-ex.html-99baa5a8.js" as="script"><link rel="prefetch" href="/408doc/assets/4-transport-layer-ex.html-db4557fd.js" as="script"><link rel="prefetch" href="/408doc/assets/5-application-layer-ex.html-90d13f07.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-45ee4db8.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary-ex.html-e0af4f2f.js" as="script"><link rel="prefetch" href="/408doc/assets/1-data-representation-and-operation-ex.html-55ad602c.js" as="script"><link rel="prefetch" href="/408doc/assets/2-storage-system-ex.html-025896de.js" as="script"><link rel="prefetch" href="/408doc/assets/3-instruction-system-ex.html-338f7920.js" as="script"><link rel="prefetch" href="/408doc/assets/4-central-processing-unit-ex.html-f6ee53b9.js" as="script"><link rel="prefetch" href="/408doc/assets/5-bus-ex.html-0e4b01e4.js" as="script"><link rel="prefetch" href="/408doc/assets/6-input-output-system-ex.html-5ba82ffc.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-788901e7.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary-ex.html-c277cc80.js" as="script"><link rel="prefetch" href="/408doc/assets/1-linear-list-ex.html-9b7e1a80.js" as="script"><link rel="prefetch" href="/408doc/assets/2-stack-ex.html-c448943d.js" as="script"><link rel="prefetch" href="/408doc/assets/5-string-ex.html-996b9027.js" as="script"><link rel="prefetch" href="/408doc/assets/6-tree-ex.html-2666bbc4.js" as="script"><link rel="prefetch" href="/408doc/assets/7-graph-ex.html-fc00e9f8.js" as="script"><link rel="prefetch" href="/408doc/assets/8-search-ex.html-8b677bbe.js" as="script"><link rel="prefetch" href="/408doc/assets/9-sort-ex.html-0934885e.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-56a3c197.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary-ex.html-a37a1d0d.js" as="script"><link rel="prefetch" href="/408doc/assets/1-process-management-ex.html-e76c8a07.js" as="script"><link rel="prefetch" href="/408doc/assets/2-memory-management-ex.html-083dd2e5.js" as="script"><link rel="prefetch" href="/408doc/assets/3-file-management-ex.html-8bf26420.js" as="script"><link rel="prefetch" href="/408doc/assets/4-device-management-ex.html-f20bd72a.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-0e09b7c7.js" as="script"><link rel="prefetch" href="/408doc/assets/404.html-1a44dc41.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-4c532139.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-b9f6aff9.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-4756c1f7.js" as="script"><link rel="prefetch" href="/408doc/assets/auto-ba5ecab5.js" as="script"><link rel="prefetch" href="/408doc/assets/index-b03bef79.js" as="script"><link rel="prefetch" href="/408doc/assets/flowchart-35969cab.js" as="script"><link rel="prefetch" href="/408doc/assets/mermaid.core-aac65d4d.js" as="script"><link rel="prefetch" href="/408doc/assets/highlight.esm-75b11b9d.js" as="script"><link rel="prefetch" href="/408doc/assets/markdown.esm-0191f9da.js" as="script"><link rel="prefetch" href="/408doc/assets/math.esm-70a288c8.js" as="script"><link rel="prefetch" href="/408doc/assets/notes.esm-a106bb2c.js" as="script"><link rel="prefetch" href="/408doc/assets/reveal.esm-ab04f0b1.js" as="script"><link rel="prefetch" href="/408doc/assets/search.esm-7e6792e2.js" as="script"><link rel="prefetch" href="/408doc/assets/zoom.esm-b83b91d0.js" as="script"><link rel="prefetch" href="/408doc/assets/VuePlayground-392583f5.js" as="script"><link rel="prefetch" href="/408doc/assets/photoswipe.esm-36cd6c3c.js" as="script"><link rel="prefetch" href="/408doc/assets/SearchResult-d9a61290.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button type="button" class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a href="/408doc/" class="brand"><img class="logo" src="/408doc/logo.png" alt="研小布「考研资料站」"><!----><span class="site-name hide-in-pad">研小布「考研资料站」</span></a><!--]--><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><!--[--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/408doc/" class="nav-link" aria-label="首页"><span class="font-icon icon iconfont icon-home" style=""></span>首页<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!--[--><!----><!----><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><button type="button" class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="placeholder">搜索</div><div class="key-hints"><kbd class="key">Ctrl</kbd><kbd class="key">K</kbd></div></button><!--]--><!--]--><!--[--><!----><!--]--><button type="button" class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/408doc/" class="nav-link sidebar-link sidebar-page" aria-label="研小布"><span class="font-icon icon iconfont icon-home" style=""></span>研小布<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><section class="sidebar-group"><p class="sidebar-heading clickable active"><span class="font-icon icon iconfont icon-note" style=""></span><a href="/408doc/408notes/" class="nav-link active title" aria-label="408笔记【常规版】"><!---->408笔记【常规版】<!----></a><!----></p><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable active" type="button"><!----><span class="title">01-数据结构</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/408doc/408notes/DS/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA.html" class="nav-link sidebar-link sidebar-page" aria-label="第一章 绪论"><!---->第一章 绪论<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8.html" class="nav-link sidebar-link sidebar-page" aria-label="第二章 线性表"><!---->第二章 线性表<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/408doc/408notes/DS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84.html" class="nav-link sidebar-link sidebar-page" aria-label="第三章 栈、队列和数组"><!---->第三章 栈、队列和数组<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/408doc/408notes/DS/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%B2.html" class="nav-link sidebar-link sidebar-page" aria-label="第四章 串"><!---->第四章 串<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第五章 树和二叉树"><!---->第五章 树和二叉树<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#树的基本概念" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="树的基本概念"><!---->树的基本概念<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#树的定义" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="树的定义"><!---->树的定义<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#基本术语" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="基本术语"><!---->基本术语<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#树的性质" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="树的性质"><!---->树的性质<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#二叉树的概念" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="二叉树的概念"><!---->二叉树的概念<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#二叉树的定义及其主要特征" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="二叉树的定义及其主要特征"><!---->二叉树的定义及其主要特征<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#二叉树的存储结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="二叉树的存储结构"><!---->二叉树的存储结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#精选试题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="精选试题"><!---->精选试题<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#二叉树的遍历和线索二叉树" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="二叉树的遍历和线索二叉树"><!---->二叉树的遍历和线索二叉树<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#二叉树的遍历" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="二叉树的遍历"><!---->二叉树的遍历<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#线索二叉树" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="线索二叉树"><!---->线索二叉树<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#综合应用题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="综合应用题"><!---->综合应用题<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#树、森林" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="树、森林"><!---->树、森林<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#树的存储结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="树的存储结构"><!---->树的存储结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#树、森林与二叉树的转换" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="树、森林与二叉树的转换"><!---->树、森林与二叉树的转换<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#树和森林的遍历" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="树和森林的遍历"><!---->树和森林的遍历<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#树的应用——并查集" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="*树的应用——并查集"><!---->*树的应用——并查集<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#层次序列及度构成孩子兄弟链表" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="层次序列及度构成孩子兄弟链表"><!---->层次序列及度构成孩子兄弟链表<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#树与二叉树的应用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="树与二叉树的应用"><!---->树与二叉树的应用<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#二叉排序树-1" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="二叉排序树"><!---->二叉排序树<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#平衡二叉树-1" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="平衡二叉树"><!---->平衡二叉树<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#哈夫曼树和哈夫曼编码" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="哈夫曼树和哈夫曼编码"><!---->哈夫曼树和哈夫曼编码<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#综合应用题-1" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="综合应用题"><!---->综合应用题<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#注意" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="注意"><!---->注意<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/408doc/408notes/DS/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%9B%BE.html" class="nav-link sidebar-link sidebar-page" aria-label="第六章 图"><!---->第六章 图<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/408doc/408notes/DS/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E6%9F%A5%E6%89%BE.html" class="nav-link sidebar-link sidebar-page" aria-label="第七章 查找"><!---->第七章 查找<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/408doc/408notes/DS/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E6%8E%92%E5%BA%8F.html" class="nav-link sidebar-link sidebar-page" aria-label="第八章 排序"><!---->第八章 排序<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><!----><span class="title">02-计算机组成原理</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><!----><span class="title">03-操作系统</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><!----><span class="title">04-计算机网络</span><span class="arrow end"></span></button><!----></section></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第五章 树和二叉树</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://ky-doc.github.io/mydoc/" target="_blank" rel="noopener noreferrer">研小布</a></span><span property="author" content="研小布"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-04-23T10:21:12.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 50 分钟</span><meta property="timeRequired" content="PT50M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#树的基本概念" class="router-link-active router-link-exact-active toc-link level2">树的基本概念</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#树的定义" class="router-link-active router-link-exact-active toc-link level3">树的定义</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#基本术语" class="router-link-active router-link-exact-active toc-link level3">基本术语</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#树的性质" class="router-link-active router-link-exact-active toc-link level3">树的性质</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#二叉树的概念" class="router-link-active router-link-exact-active toc-link level2">二叉树的概念</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#二叉树的定义及其主要特征" class="router-link-active router-link-exact-active toc-link level3">二叉树的定义及其主要特征</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#二叉树的存储结构" class="router-link-active router-link-exact-active toc-link level3">二叉树的存储结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#精选试题" class="router-link-active router-link-exact-active toc-link level3">精选试题</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#二叉树的遍历和线索二叉树" class="router-link-active router-link-exact-active toc-link level2">二叉树的遍历和线索二叉树</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#二叉树的遍历" class="router-link-active router-link-exact-active toc-link level3">二叉树的遍历</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#线索二叉树" class="router-link-active router-link-exact-active toc-link level3">线索二叉树</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#综合应用题" class="router-link-active router-link-exact-active toc-link level3">综合应用题</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#树、森林" class="router-link-active router-link-exact-active toc-link level2">树、森林</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#树的存储结构" class="router-link-active router-link-exact-active toc-link level3">树的存储结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#树、森林与二叉树的转换" class="router-link-active router-link-exact-active toc-link level3">树、森林与二叉树的转换</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#树和森林的遍历" class="router-link-active router-link-exact-active toc-link level3">树和森林的遍历</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#树的应用——并查集" class="router-link-active router-link-exact-active toc-link level3">*树的应用——并查集</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#层次序列及度构成孩子兄弟链表" class="router-link-active router-link-exact-active toc-link level3">层次序列及度构成孩子兄弟链表</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#树与二叉树的应用" class="router-link-active router-link-exact-active toc-link level2">树与二叉树的应用</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#二叉排序树-1" class="router-link-active router-link-exact-active toc-link level3">二叉排序树</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#平衡二叉树-1" class="router-link-active router-link-exact-active toc-link level3">平衡二叉树</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#哈夫曼树和哈夫曼编码" class="router-link-active router-link-exact-active toc-link level3">哈夫曼树和哈夫曼编码</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#综合应用题-1" class="router-link-active router-link-exact-active toc-link level3">综合应用题</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.html#注意" class="router-link-active router-link-exact-active toc-link level2">注意</a></li><!----><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><h2 id="树的基本概念" tabindex="-1"><a class="header-anchor" href="#树的基本概念" aria-hidden="true">#</a> 树的基本概念</h2><h3 id="树的定义" tabindex="-1"><a class="header-anchor" href="#树的定义" aria-hidden="true">#</a> 树的定义</h3><p>树是 n（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n\geq0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>）个结点的有限集。当 n = 0 时，称为空树，在任意一棵非空树中应满足：</p><ol><li>有且仅有<strong>一个特定的称为根的结点</strong></li><li>当 n &gt; 1 时，其余结点可分为 m（m &gt; 0）个互不相交的有限集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>T</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">T_1,\cdots,T_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中<strong>每个集合本身又是一棵树</strong>，并称为<strong>根的子树</strong></li></ol><p>树的定义是<strong>递归</strong>的，在<strong>树的定义中又用到了其自身</strong>，树作为一种<strong>逻辑结构</strong>，同时也是一种<strong>分层结构</strong>，有以下特定：</p><ol><li>树的<strong>根结点没有前驱</strong>，<strong>除根结点外</strong>的所有结点有且<strong>只有一个前驱</strong></li><li>树中所有结点可以有<strong>零个或多个后继</strong></li></ol><p><strong>树适合表示具有层次结构的数据</strong>，树中<strong>除根结点外</strong>的某个结点最多只和<strong>上一层</strong>的一个结点有<strong>直接关系</strong></p><p><strong>根结点没有直接上层结点</strong>，因此<u>在 n 个结点的树中有 n - 1 条边</u>，而树中每个结点与其<strong>下一层</strong>的零个或多个结点有<strong>直接关系</strong></p><h3 id="基本术语" tabindex="-1"><a class="header-anchor" href="#基本术语" aria-hidden="true">#</a> 基本术语</h3><figure><img src="/408doc/408noteImg/images/image-20210916160654157.png" alt="image-20210916160654157" tabindex="0" loading="lazy"><figcaption>image-20210916160654157</figcaption></figure><ol><li>根 A 到结点 K 的唯一路径上的任意结点，称为结点 K 的<strong>祖先</strong>；相对 K 就是它们的<strong>子孙</strong>，如 B 是 K 的祖先，K 是 B 的子孙</li><li>祖先中最接近 K 的结点 E 称为 K 的<strong>双亲</strong>，而 K 称为 K 的<strong>孩子</strong>，根结点是唯一没有双亲的结点</li><li>有相同双亲的结点称为<strong>兄弟</strong>，如结点 K 和结点 L 有相同的双亲，即 K 和 L 为兄弟</li><li>树中<strong>一个结点的孩子个数</strong>称为该<strong>结点的度</strong>，<strong>树中结点的最大度数</strong>称为<strong>树的度</strong>，如 B 的度 2，树的度 3</li><li>度大于 0 的结点称为<strong>分支结点</strong>或<strong>非终端结点</strong>；度为 0 的结点称为<strong>叶子结点</strong>或<strong>终端结点</strong>，每个结点的分支数就是该结点的度</li><li>结点的<strong>层次</strong>从树根开始定义，<strong>根结点为第 1 层</strong>，它的子结点为 2 层，它的子结点的子结点在 3 层，以此类推</li><li>结点的<strong>深度</strong>是从<strong>根结点开始</strong>自顶向下逐层累加的；结点的<strong>高度</strong>是从<strong>叶结点开始</strong>自低向上逐层累加的</li><li>双亲在<strong>同一层的结点</strong>，也就是在同一层的结点，<strong>互为堂兄弟</strong>，如 G 与 E、F、H、I、J 互为堂兄弟</li><li><strong>树的高度或深度</strong>是树中结点<strong>最大的层数</strong>，如图中树的高度或深度为 4</li><li><strong>有序树</strong>是指树中结点的各子树<strong>从左到右是有次序的</strong>，<strong>不能互换</strong>，若可互换就称为<strong>无序树</strong></li><li>树中两个结点之间的<strong>路径</strong>是由这两个结点之间所经过的<strong>结点序列</strong>构成的，而<strong>路径长度</strong>是路径上经过的<strong>边的个数</strong></li><li><strong>树的路径长度</strong>是从树根到每个结点的路径长度的<strong>总和</strong>，相同结点个数下，<strong>完全二叉树</strong>就是这种<strong>路径长度最短的二叉树</strong></li><li><strong>森林</strong>是 m（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">m\geq0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>）棵<strong>互不相交</strong>的<strong>树的集合</strong>，把树的根结点删去就成了森林，给森林加个根结点就成了树</li></ol><p>注意：树的分支是有向的，即从双亲指向孩子，所以<strong>树中路径是从上向下</strong>的，<u>同一双亲的两个孩子之间不存在路径</u></p><h3 id="树的性质" tabindex="-1"><a class="header-anchor" href="#树的性质" aria-hidden="true">#</a> 树的性质</h3><ol><li><p><strong>树中的结点数等于所有结点的度数之和加 1</strong>，因为结点的度数和等于边数和，而结点数等于边数加 1</p></li><li><p>度为 m 的树中第 i 层上至多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">m^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 个结点（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i\geq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>）</p></li><li><p>高度为 h 的 m 叉树至多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>m</mi><mi>h</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(m^h-1)/(m-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 个结点，根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mi>m</mi><mo>+</mo><msup><mi>m</mi><mn>2</mn></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mi>m</mi><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mo stretchy="false">(</mo><msup><mi>m</mi><mi>h</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1+m+m^2+\cdots+m^{h-1}=(m^h-1)/(m-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p></li><li><p>具有 n 个结点的 m 叉树的最小高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>m</mi></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil\log_m(n(m-1)+1)\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0573em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)⌉</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mi>m</mi><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mi>m</mi><mrow><mi>h</mi><mo>−</mo><mn>2</mn></mrow></msup><mo>&lt;</mo><mi>n</mi><mo>≤</mo><mn>1</mn><mo>+</mo><mi>m</mi><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mi>m</mi><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">1+m+\cdots+m^{h-2}&lt;n\leq1+m+\cdots+m^{h-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8882em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>m</mi><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mi>n</mi><mo>≤</mo><mo stretchy="false">(</mo><msup><mi>m</mi><mi>h</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(m^{h-1}-1)/(m-1)&lt;n\leq (m^h-1)/(m-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>m</mi><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>&lt;</mo><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>≤</mo><msup><mi>m</mi><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">m^{h-1}&lt;n(m-1)+1\leq m^h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8882em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span></p><p>拆开分别求解就有：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>&lt;</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>m</mi></msub><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h&lt;\log_m[n(m-1)+1]+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0573em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>≥</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>m</mi></msub><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">h\geq \log_m[n(m-1)+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0573em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p><p>由于 h 只能是正整数，故 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mo stretchy="false">⌈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>m</mi></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">h=\lceil\log_m(n(m-1)+1)\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0573em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)⌉</span></span></span></span></p></li><li><p>具有 n 个结点，度为 m 的树，它的高度至多是 n - m + 1</p></li><li><p>度为 n、高度为 h 的树，至少有 h + n - 1 个结点</p></li></ol><h2 id="二叉树的概念" tabindex="-1"><a class="header-anchor" href="#二叉树的概念" aria-hidden="true">#</a> 二叉树的概念</h2><h3 id="二叉树的定义及其主要特征" tabindex="-1"><a class="header-anchor" href="#二叉树的定义及其主要特征" aria-hidden="true">#</a> 二叉树的定义及其主要特征</h3><h4 id="二叉树的定义" tabindex="-1"><a class="header-anchor" href="#二叉树的定义" aria-hidden="true">#</a> 二叉树的定义</h4><p>二叉树是另一种树形结构，其特点是<strong>每个结点至多只有两棵子树</strong>，并且二叉树的<strong>子树有左右之分</strong>，其次序不能任意颠倒</p><p>二叉树也<strong>以递归的形式定义</strong>，二叉树是 n（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n\geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>）点的有限集合：</p><ol><li>当 n = 0 时，为<strong>空二叉树</strong></li><li>当 n &gt; 0 时，由一个<strong>根结点</strong>和两个互不相交的<strong>左子树和右子树</strong>组成，左子树和右子树分别是一棵二叉树</li></ol><p>二叉树有 <strong>5 种基本形态</strong>：空二叉树、只有根结点、只有左子树、左右子树都有、只有右子树</p><p>二叉树与度为 2 的有序树的区别：</p><ol><li>度为 2 的树至少有 3 个结点，而<strong>二叉树可以为空</strong></li><li>若度为 2 的树某个<strong>结点只有一个孩子</strong>，则这个<strong>孩子无需区分左右次序</strong>，而<strong>二叉树必须区分</strong></li></ol><h4 id="几个特殊的二叉树" tabindex="-1"><a class="header-anchor" href="#几个特殊的二叉树" aria-hidden="true">#</a> 几个特殊的二叉树</h4><h5 id="满二叉树" tabindex="-1"><a class="header-anchor" href="#满二叉树" aria-hidden="true">#</a> 满二叉树</h5><p><strong>一棵高度为 h，且含有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^h-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个结点的二叉树称为满二叉树</strong></p><p>即树中<u>每层都含有最多的结点</u>，且<u>叶子结点都集中在最下一层</u>，并且<u>除叶子结点外每个结点的度均为 2</u></p><p>对满二叉树按层序编号：从根结点 1 起，自上而下，自左向右，这样每个结点都对应一个编号</p><p>对于编号为 i 的结点，若有双亲则为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mi>i</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor i/2\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">i</span><span class="mord">/2</span><span class="mclose">⌋</span></span></span></span>；若有左孩子则为 <code>2i</code>；若有有孩子则为 <code>2i + 1</code></p><figure><img src="/408doc/408noteImg/images/image-20210916202647863.png" alt="image-20210916202647863" tabindex="0" loading="lazy"><figcaption>image-20210916202647863</figcaption></figure><h5 id="完全二叉树" tabindex="-1"><a class="header-anchor" href="#完全二叉树" aria-hidden="true">#</a> 完全二叉树</h5><p>高度为 h、有 n 个结点的二叉树，当且仅当<strong>其每个结点都与高度为 h 的满二叉树种编号为 1 ~ n 的结点一一对应</strong>时，称为<strong>完全二叉树</strong></p><figure><img src="/408doc/408noteImg/images/image-20210916202710346.png" alt="image-20210916202710346" tabindex="0" loading="lazy"><figcaption>image-20210916202710346</figcaption></figure><p>高度为 h、有 n 个结点的完全二叉树具有以下特点：</p><ol><li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≤</mo><mo stretchy="false">⌊</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">i\leq\lfloor n/2\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">n</span><span class="mord">/2</span><span class="mclose">⌋</span></span></span></span>，则结点 i 为<strong>分支结点</strong>，否则为<strong>叶子结点</strong></li><li><strong>叶子结点</strong>只可能在<strong>层次最大的两层</strong>上出现，对于<strong>最大层次中的叶子结点</strong>，都一次排序在<strong>该层最左边位置</strong>上</li><li>若有<strong>度为 1 的结点</strong>，则<strong>只可能有一个</strong>，且该结点<strong>只有左孩子</strong>而无右孩子</li><li>按层序编号后，一旦出现某结点为<strong>叶子结点或只有左孩子</strong>，则<strong>编号大于它</strong>的结点<strong>均为叶子结点</strong></li><li>若 n 为奇数，则每个分支结点都有左孩子和右孩子；若 <strong>n 为偶数</strong>，<strong>最大的分支结点只有左孩子</strong>，其余的左右都有</li></ol><h5 id="二叉排序树" tabindex="-1"><a class="header-anchor" href="#二叉排序树" aria-hidden="true">#</a> 二叉排序树</h5><ol><li><u>左子树上所有子结点的关键字均小于根结点的关键字</u></li><li><u>右子树上的所有结点的关键字均大于根结点的关键字</u></li><li><u>左子树和右子树右各是一棵二叉排序树</u></li></ol><h5 id="平衡二叉树" tabindex="-1"><a class="header-anchor" href="#平衡二叉树" aria-hidden="true">#</a> 平衡二叉树</h5><p>平衡二叉树是一棵二叉排序树</p><p>树上任意结点的<strong>左子树和右子树的深度插不超过 1</strong></p><h4 id="二叉树的性质" tabindex="-1"><a class="header-anchor" href="#二叉树的性质" aria-hidden="true">#</a> 二叉树的性质</h4><ol><li><p><strong>非空二叉树上的叶子结点树等于度为 2 的结点数加 1，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0=n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></strong></p><p>结点总数：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n=n_0+n_1+n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，分支数：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mn>2</mn><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">B=n_1+2n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 又 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>B</mi><mo>+</mo><mn>1</mn><mo>=</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mn>2</mn><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=B+1=n_1+2n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p><p>合并就解出方程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mo>=</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mn>2</mn><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo>→</mo><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0+n_1+n_2=n_1+2n_2+1\to n_0=n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p></li><li><p>非空二叉树上第 k 层上至多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 个结点（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k\geq1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>）</p></li><li><p>高度为 h 的二叉树至多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^h-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个结点（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h\geq1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>）</p></li><li><p>对完全二叉树按从上到下、从左到右的顺序依次编号 1,2,...,n 则有以下关系：</p><ol><li>当 i &gt; 1 时，结点 i 的双亲编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mi>i</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor i/2\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">i</span><span class="mord">/2</span><span class="mclose">⌋</span></span></span></span>；当 i 为偶数时，是左孩子；为奇数时，是右孩子</li><li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2i\leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 时，结点 i 的左孩子编号为 <code>2i</code>，否则无左孩子</li><li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2i+1\leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 时，结点 i 的右孩子编号为 <code>2i + 1</code>，否则无右孩子</li><li><strong>结点 i 所在层次或深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>i</mi><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lfloor\log_2i\rfloor+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></strong></li></ol></li><li><p><strong>具有 n 个（n &gt; 0）结点的完全二叉树的高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil\log_2(n+1)\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)⌉</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lfloor\log_2n\rfloor+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></strong></p><p>根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>2</mn></mrow></msup><mo>&lt;</mo><mi>n</mi><mo>≤</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">1+2+\cdots+2^{h-2}&lt;n\leq1+2+\cdots+2^{h-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8882em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 推出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mo stretchy="false">⌈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">h=\lceil\log_2(n+1)\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)⌉</span></span></span></span></p><p>根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>2</mn></mrow></msup><mo>+</mo><mn>1</mn><mo>≤</mo><mi>n</mi><mo>&lt;</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1+2+\cdots+2^{h-2}+1\leq n&lt; 1+2+\cdots+2^{h-1}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 推出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mo stretchy="false">⌊</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h=\lfloor\log_2n\rfloor+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p><p>具体的推导方法与 <a href="#%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8">树的性质</a> 类似</p></li></ol><h3 id="二叉树的存储结构" tabindex="-1"><a class="header-anchor" href="#二叉树的存储结构" aria-hidden="true">#</a> 二叉树的存储结构</h3><h4 id="顺序存储结构" tabindex="-1"><a class="header-anchor" href="#顺序存储结构" aria-hidden="true">#</a> 顺序存储结构</h4><p>二叉树的顺序存储是指<strong>用一组的地址连续的存储单元</strong>依次自上而下、自左至右<strong>存储完全二叉树上的结点元素</strong></p><p>将完全二叉树上<strong>编号为 i 的结点</strong>元素存储在一维数组<strong>下标为 i - 1 的分量</strong>中</p><p>根据二叉树的性质，<strong>完全二叉树和满二叉树采用顺序存储比较合适</strong>，它们可以<strong>最大可能地节省存储空间</strong>，又方便从数组中<strong>查找结点</strong>，以及<strong>结点之间的关系</strong></p><p>对于<strong>一般的二叉树</strong>，为了让数组反应结点之间的关系，只能<strong>添加空结点</strong>，让它在数组中看似完全二叉树</p><p>但这样的话会出现浪费空间的情况，最坏情况下一个高度为 h 且只有 h 结点的单支树需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^h-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个存储单元</p><figure><img src="/408doc/408noteImg/images/image-20210916221701804.png" alt="image-20210916221701804" tabindex="0" loading="lazy"><figcaption>image-20210916221701804</figcaption></figure><p>注意：<strong>数组是从 0 开始</strong>的，所以<strong>不能直接使用性质 4</strong>，需要一些变通</p><h4 id="链式存储结构" tabindex="-1"><a class="header-anchor" href="#链式存储结构" aria-hidden="true">#</a> 链式存储结构</h4><p>为了解决顺序存储的空间浪费问题，所以二叉树一般都采用<strong>链式存储结构</strong>，<strong>用链表结点来存储二叉树中的每个结点</strong></p><p>二叉链表<strong>至少</strong>包含 3 个域：<strong>数据域、左指针域、右指针域</strong></p><p>在实际的不同应用中，还可以增加某些指针域，如增加指向父结点的指针</p><p>二叉树的链式存储结构描述如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span> <span class="token punctuation">{</span>
    ElemType data<span class="token punctuation">;</span>  <span class="token comment">// 数据域</span>
    <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>  <span class="token comment">// 左右孩子指针</span>
<span class="token punctuation">}</span> BiTNode<span class="token punctuation">,</span> <span class="token operator">*</span>BiTree<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用不同存储结构时，实现二叉树操作的算法也会不同，依次要根据实际应用场合来选择合适的存储结构</p><p>在含有 <strong>n 个结点的二叉链表中</strong>，含有 <strong>n + 1 个空链域</strong></p><figure><img src="/408doc/408noteImg/images/image-20210916225214560.png" alt="image-20210916225214560" tabindex="0" loading="lazy"><figcaption>image-20210916225214560</figcaption></figure><h3 id="精选试题" tabindex="-1"><a class="header-anchor" href="#精选试题" aria-hidden="true">#</a> 精选试题</h3><ol><li><p>设二叉树有 <code>2n</code> 个结点，且 0 &lt; m &lt; n，则不可能存在 <code>2m</code> 个度为 1 的结点</p><p>因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mo>=</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mn>2</mn><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2n=n_0+n_1+n_2=n_1+2n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 由于 <code>2n</code> 是偶数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">2n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是偶数，所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 必定是奇数</p></li><li><p>若一个完全二叉树的第 h 层有 k 个叶结点，则该完全二叉树的结点个数最多为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo><mo>∗</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{h}-1+(2^{h-1}-k)*2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></p><p>当 h 和 h + 1 层有叶结点时结点数最大，逻辑是计算 1 ~ h 层的结点加上 h + 1 层的结点</p><p>1 ~ h 层结点个数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^h-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 而 h + 1 层结点个数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo><mo>∗</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">(2^{h-1}-k)*2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></p></li><li><p>若一棵深度为 h 的完全二叉树的第 h 层有 k 个叶子结点，则该二叉树共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>2</mn></mrow></msup><mo>−</mo><mo stretchy="false">⌈</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">k+2^{h-2}-\lceil k/2\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">/2</span><span class="mclose">⌉</span></span></span></span></p><p>思路是第 h 层的叶子结点加上 h - 1 层的叶子结点</p></li><li><p>若一棵完全二叉树有 i 个结点，则该二叉树中叶子结点的个数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mo stretchy="false">⌊</mo><mi>i</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">i - \lfloor i / 2\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">i</span><span class="mord">/2</span><span class="mclose">⌋</span></span></span></span></p><p>思路是利用完全二叉树的特性，最后一个分支的序号是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mi>i</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor i / 2\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">i</span><span class="mord">/2</span><span class="mclose">⌋</span></span></span></span></p></li><li><p>一棵有 n 个叶子结点的完全二叉树，最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mo stretchy="false">⌈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">⌉</mo><mo separator="true">;</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo><mo>∗</mo><mn>2</mn><mo>+</mo><msup><mn>2</mn><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">h=\lceil \log_2n\rceil;(n-2^{h-1})*2+2^h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⌉</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span></p><p>拿到二叉树的高，使用 1 ~ h - 1 的结点加上 h 层的叶子结点</p></li></ol><p><strong>做题思路：</strong></p><ul><li>可以利用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n=n_0+n_1+n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0=n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mn>2</mn><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n=n_1+2n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 这三条公式</li><li>可以利用完全二叉树的性质，如高为 h，它的 h - 1 层的结点有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{h-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>，1 ~ h - 1 的结点有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{h-1}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li><li>可以直接在脑袋里面画出二叉树，用空间思维硬刚</li></ul><h2 id="二叉树的遍历和线索二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树的遍历和线索二叉树" aria-hidden="true">#</a> 二叉树的遍历和线索二叉树</h2><h3 id="二叉树的遍历" tabindex="-1"><a class="header-anchor" href="#二叉树的遍历" aria-hidden="true">#</a> 二叉树的遍历</h3><p>二叉树的遍历是指按某条搜索路径<strong>访问树中每个结点</strong>，，使得<strong>每个结点均被访问一次</strong>，而且<strong>仅被访问一次</strong></p><p>按照<strong>先遍历左子树再遍历右子树</strong>的原则，常见的遍历次序有：<strong>先序遍历、中序遍历、后续遍历</strong>，其中序是指根结点何时访问</p><h4 id="先序遍历" tabindex="-1"><a class="header-anchor" href="#先序遍历" aria-hidden="true">#</a> 先序遍历</h4><p>先序遍历（<code>PreOrder</code>）的操作过程如下：</p><p>若二叉树为空，则什么都不做；否则（<code>NLR</code>）：</p><ol><li>访问根结点</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ol><p>对于的递归算法代码如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>
    <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 访问根结点</span>
    <span class="token function">PreOrder</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 递归遍历左子树</span>
    <span class="token function">PreOrder</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 递归遍历右子树</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="中序遍历" tabindex="-1"><a class="header-anchor" href="#中序遍历" aria-hidden="true">#</a> 中序遍历</h4><p>中序遍历（<code>InOrder</code>）操作和先序遍历差不多，只是把访问根结点调整到第二步，先左再自己再右（<code>LNR</code>）</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>
    <span class="token function">InOrder</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">InOrder</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="后序遍历" tabindex="-1"><a class="header-anchor" href="#后序遍历" aria-hidden="true">#</a> 后序遍历</h4><p>后序遍历（<code>PostOrder</code>）操作和先序遍历差不多，只是把访问根结点调整到第三步，先左右再自己（<code>LRN</code>）</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>
    <span class="token function">PostOrder</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PostOrder</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个结点都访问一次且访问一次，故<strong>时间复杂度是 O(n)</strong></p><p>递归遍历中，最坏情况下有 n 个结点的二叉树是深度为 n 的单支树，<strong>空间复杂度为 O(n)</strong></p><p>当栈出一个结点 p 后，<strong>栈内的元素是 p 的全部祖先</strong>，从<strong>栈低到栈顶加上 p 是根结点到 p 的路径</strong></p><p>很多算法设计中都可以利用这一思路求解，如<strong>求根到某结点的路径</strong>、<strong>求两结点的最近公共祖先</strong>等</p><hr><p><strong>注意：考研很多题是基于这三个遍历模板延申出来的，要对它有很好的领会</strong></p><h4 id="递归算法和非递归算法的转换" tabindex="-1"><a class="header-anchor" href="#递归算法和非递归算法的转换" aria-hidden="true">#</a> 递归算法和非递归算法的转换</h4><h5 id="栈实现中序遍历" tabindex="-1"><a class="header-anchor" href="#栈实现中序遍历" aria-hidden="true">#</a> 栈实现中序遍历</h5><p><strong>使用栈实现中序遍历</strong>，考虑到<strong>中序遍历就是左中右遍历</strong>（对每个结点都进行左中右），就可以得到下面思路：</p><ol><li>拿到该结点最左子树，因为中序遍历第一步是做左操作，左又做左操作，所以就拿最左结点</li><li>因为是最左子树根据左中右原则，左没有了，自己就是中，先访问自己，然后把右子树做 1 操作</li><li>到了这里左右子树都没有了，考虑到父结点是做左操作到自己的，这时应该轮到父结点做中操作了，访问父结点，然后父结点做右操作，对父结点的右子树做 1 操作</li></ol><p>根据思路可以得到操作：</p><ol><li>如果当前结点不为空，把当前结点和一路左边结点压入栈；相当于第一步，使用栈是为了可以拿到父结点</li><li>弹栈访问，并对结点的右子树执行操作 1；这里就相当于把上面思路的 2，3 步合在一起</li></ol><p>原理讲完了下面是实现代码：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    LiStack S<span class="token punctuation">;</span>
    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    BiTree p <span class="token operator">=</span> T<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 第 1 步把左一路的压入栈</span>
            <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第 2 步访问自己，然后对右子树执行 1</span>
            p <span class="token operator">=</span> p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="栈实现前序遍历" tabindex="-1"><a class="header-anchor" href="#栈实现前序遍历" aria-hidden="true">#</a> 栈实现前序遍历</h5><p>使用栈实现前序遍历的思考和中序遍历差不多，区别在于<strong>前序遍历的逻辑是中左右</strong></p><p>前序遍历的结点使用顺序和前序一样，就是访问的位置不一样，只需要调整一下就可以了</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    LiStack S<span class="token punctuation">;</span>
    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    BiTree p <span class="token operator">=</span> T<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 把访问调整为前序遍历的先访问</span>
            <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="栈实现后序遍历" tabindex="-1"><a class="header-anchor" href="#栈实现后序遍历" aria-hidden="true">#</a> 栈实现后序遍历</h5><p>使用栈实现后序遍历思考也差不多，<strong>后序遍历的核心逻辑是左右中</strong>，但操作变得不一样了：</p><ol><li>首先和中序一样，先拿到最左的结点</li><li>然后直接对右子树做操作 1，因为左右中，现在进行右操作</li><li>到了这里左右操作都做完了，现在就可以做中操作，对结点进行访问了</li></ol><p>但在代码里面，<u>无法知道右操作是否有做，所以要做个判断</u>，判断不过就要乖乖做右操作：</p><ul><li>如果没有右子树，就相当于光速做了右操作，就可以中操作了</li><li>如果上一个做中的结点是右子树结点，那么就是以前做了右操作，可以做中操作</li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    LiStack S<span class="token punctuation">;</span>
    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    BiTree p <span class="token operator">=</span> T<span class="token punctuation">;</span>
    BiTNode <span class="token operator">*</span>r <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 做第一步操作，左边直入栈</span>
            <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token function">GetTop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// p 是 r 的父结点</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> rchild <span class="token operator">&amp;&amp;</span> p <span class="token operator">-&gt;</span> rchild <span class="token operator">!=</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 判断不过做第二步操作</span>
                p <span class="token operator">=</span> p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment">// 判断过了做第三步操作</span>
                <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
                r <span class="token operator">=</span> p<span class="token punctuation">;</span>
                p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">// 重置 p 指针省的第一步操作了</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="层次遍历" tabindex="-1"><a class="header-anchor" href="#层次遍历" aria-hidden="true">#</a> 层次遍历</h4><p>层次遍历是<strong>指按树的层从左到右访问结点</strong>，进行层次遍历要借助一个队列：</p><ol><li>初始化把根结点入队</li><li>队列不空，从队列取出一个元素，并访问它</li><li>有左子树把左子树入队</li><li>有右子树把右子树入队，回第二步</li></ol><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">LevelOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    LinkQueue Q<span class="token punctuation">;</span>
    <span class="token function">InitQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    BiTree p<span class="token punctuation">;</span>
    <span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第一步，根结点入队</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QueueEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">DeQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第二步，出列并访问</span>
        <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> lchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 第三步</span>
            <span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> rchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 第四步</span>
            <span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：这些代码作为一个模板需要达到<u>熟练手写的程度</u>，这样才能将层次遍历模板应用于各种题目之中</strong></p><h4 id="由遍历序列构造二叉树" tabindex="-1"><a class="header-anchor" href="#由遍历序列构造二叉树" aria-hidden="true">#</a> 由遍历序列构造二叉树</h4><p>由二叉树的<strong>先序序列</strong>和<strong>中序序列</strong>可以<strong>唯一地确定一棵二叉树</strong>：</p><ol><li><strong>先序序列的第一个是二叉树的根结点</strong>；拿它去中序序列可以把中序序列分成两半，变成左子树的中序和右子树的中序</li><li>然后在先序序列中找到对应的左子序列和右子序列</li><li>在先序序列中，左子序列的第一位就是左子树的根部；右子序列的第一位就是右子序列的根部</li><li>依次递归下去，就能找到唯一的二叉树了</li></ol><p>例子：求先序序列（<code>ABCDEFGHI</code>）和中序序列（<code>BCAEDGHFI</code>）所确定的二叉树</p><figure><img src="/408doc/408noteImg/images/image-20210917202041035.png" alt="image-20210917202041035" tabindex="0" loading="lazy"><figcaption>image-20210917202041035</figcaption></figure><p>同理，也可以求<strong>后序序列和中序序列</strong>的二叉树，<strong>后序序列的最后一个结点就是根结点</strong></p><p>同理，也可以求<strong>层序序列和中序序列</strong>的二叉树，第一个为根结点，若中序左右子树都有，第二个是左子树根结点，以此类推</p><p>注意：只知道二叉树的<strong>先序序列和后序序列</strong>，是<strong>无法确定唯一的二叉树</strong>的</p><h5 id="选择题得到的理论" tabindex="-1"><a class="header-anchor" href="#选择题得到的理论" aria-hidden="true">#</a> 选择题得到的理论</h5><ul><li><p>如果<strong>前序序列是后序序列的反转</strong>设长度为 n，那么一共<strong>可以构成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 棵二叉树</strong>，因为它们<strong>只会有一个叶结点</strong></p></li><li><p>当两个结点的<strong>前序序列为 <code>XY</code></strong>、<strong>后序序列为 <code>YX</code></strong> 时，则 <strong>X 为 Y 的祖先</strong>，<code>XZY</code> 这时不能确定 X 和 Y 的关系</p></li><li><p>先序序列为 1...n 的<strong>不同二叉树的个数</strong>是其<strong>出栈元素不同排列的个数</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mstyle><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">\dfrac{1}{n+1}C^{n}_{2n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0908em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span></p><p>先序序列输出的是入栈的元素，而中序序列输出的是出栈的元素</p><p>而先序和中序能确定一棵树，也就是有多少种中序就有多少棵树，也就是栈的出栈序列的个数</p><p>如何保证先序序列和中序序列真的能构成一棵树？</p><p>根据前序和后序思想，要进左子树必须先进其父结点，要进右子树必须前出其父结点，就有对于一个结点：</p><ul><li>当它在栈中时，往后入栈的元素都是它的左子树</li><li>出栈之后，往后入栈的元素都是它的右子树</li></ul><p>所以出栈的前后只会影响左右性，不会对是否构成一棵树构成影响</p></li></ul><h5 id="先中序列形成二叉树代码" tabindex="-1"><a class="header-anchor" href="#先中序列形成二叉树代码" aria-hidden="true">#</a> 先中序列形成二叉树代码</h5><p>思路：</p><ol><li>根据先序序列第一位确定树的根结点</li><li>根据根结点在中序序列中划分出二叉树的左右子树包含那些结点</li><li>根据左右子树结点在先序序列中的次序确定子树的根结点，即递归回步骤 1</li></ol><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/**
 * A: 前序序列
 * B: 中序序列
 * l1: A 的第一个结点的下标
 * h1: A 的最后一个结点的下标
 * l2: B 的第一个结点的下标
 * h2: B 的最后一个结点的下标
 */</span>
BiTree <span class="token function">PreInCreat</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ElemType B<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l1<span class="token punctuation">,</span> <span class="token keyword">int</span> h1<span class="token punctuation">,</span> <span class="token keyword">int</span> l2<span class="token punctuation">,</span> <span class="token keyword">int</span> h2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> llen<span class="token punctuation">,</span> rlen<span class="token punctuation">;</span>
    root <span class="token operator">=</span> <span class="token punctuation">(</span>BiTNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 建立根结点</span>
    root <span class="token operator">-&gt;</span> data <span class="token operator">=</span> A<span class="token punctuation">[</span>l1<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> l2<span class="token punctuation">;</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> root <span class="token operator">-&gt;</span> data<span class="token punctuation">;</span>  i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 在中序找出该结点的位置</span>
    llen <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">12</span><span class="token punctuation">;</span>  <span class="token comment">// 左子树序列的长度</span>
    rlen <span class="token operator">=</span> h2 <span class="token operator">-</span> i<span class="token punctuation">;</span>  <span class="token comment">// 右子树序列的长度</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>llen<span class="token punctuation">)</span>  <span class="token comment">// 如果左子树序列不为空，递归建立；否则设左子树为空</span>
        root <span class="token operator">-&gt;</span> lchild <span class="token operator">=</span> <span class="token function">PreInCreat</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> l1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> l1 <span class="token operator">+</span> llen<span class="token punctuation">,</span> l2<span class="token punctuation">,</span> l2 <span class="token operator">+</span> llen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        root <span class="token operator">-&gt;</span> lchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rlen<span class="token punctuation">)</span>
        root <span class="token operator">-&gt;</span> rchild <span class="token operator">=</span> <span class="token function">PreInCreat</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> h1 <span class="token operator">-</span> rlen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> h1<span class="token punctuation">,</span> h2 <span class="token operator">-</span> rlen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> h2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        root <span class="token operator">-&gt;</span> rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>  <span class="token comment">// 返回局部二叉树的根结点</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="线索二叉树" tabindex="-1"><a class="header-anchor" href="#线索二叉树" aria-hidden="true">#</a> 线索二叉树</h3><h4 id="线索二叉树的基本概念" tabindex="-1"><a class="header-anchor" href="#线索二叉树的基本概念" aria-hidden="true">#</a> 线索二叉树的基本概念</h4><p>线索二叉树就是把二叉表的 n + 1 个<strong>空指针利用起来</strong>，分别<strong>指向前驱和后继</strong></p><p>规定：若<strong>无左子树</strong>，令 <strong><code>lchild</code> 指向其前序结点</strong>；若<strong>无右子树</strong>，令 <strong><code>rchild</code> 指向其后继结点</strong>；此外还增加两个<u>标志域来表示指针域指向的是孩子还是前序或后继</u></p><p>引用线索二叉树是为了<strong>加快查找结点前驱和后继的速度</strong>，线索二叉树是一种<strong>物理结构</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ThreadNode</span><span class="token punctuation">{</span>
    ElemType data<span class="token punctuation">;</span>  <span class="token comment">// 数据域</span>
    <span class="token keyword">struct</span> <span class="token class-name">ThreadNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>  <span class="token comment">// 左右孩子指针</span>
    <span class="token keyword">int</span> ltag<span class="token punctuation">,</span> rtag<span class="token punctuation">;</span>  <span class="token comment">// 左右线索标志</span>
<span class="token punctuation">}</span>ThreadNode<span class="token punctuation">,</span> <span class="token operator">*</span>ThreadTree<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ltag</code> 为 1 时指向<strong>前驱</strong>，为 0 时指向<strong>左孩子</strong>；<code>rtag</code> 为 1 时指向<strong>后继</strong>，为 0 时指向<strong>右孩子</strong></p><p>以这种结构构成的二叉链表来存储二叉树叫做<strong>线索链表</strong>，其中<strong>指向前驱和后继的指针叫做线索</strong>，<strong>加上线索的二叉树称为线索二叉树</strong></p><h4 id="中序线索二叉树的构造" tabindex="-1"><a class="header-anchor" href="#中序线索二叉树的构造" aria-hidden="true">#</a> 中序线索二叉树的构造</h4><p><strong>二叉树的线索化</strong>是将二叉链表中的<strong>空指针改为指向前驱或后继的线索</strong>，通过遍历一次二叉树来实现</p><p><strong>中序线索二叉树的前驱</strong>就是<strong>中序遍历时结点的前驱</strong>，前序、后序线索二叉树类似</p><p>附设 <code>pre</code> 指针指向前驱结点（刚刚访问的结点），指针 p 是正在访问的结点，在中序遍历中，调整它们的关系，代码如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 中序遍历线索化二叉树，</span>
<span class="token keyword">void</span> <span class="token function">InThread</span><span class="token punctuation">(</span>ThreadTree <span class="token operator">&amp;</span>p<span class="token punctuation">,</span> ThreadTree <span class="token operator">&amp;</span>pre<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">InThread</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">,</span> pre<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 线索化左边的二叉树</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> lchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 当前结点左子树为空，指向前驱</span>
            p <span class="token operator">-&gt;</span> lchild <span class="token operator">=</span> pre<span class="token punctuation">;</span>
            p <span class="token operator">-&gt;</span> ltag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> pre <span class="token operator">-&gt;</span> rchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 前驱的右子树为空，指向后继</span>
            pre <span class="token operator">-&gt;</span> rchild <span class="token operator">=</span> p<span class="token punctuation">;</span>
            pre <span class="token operator">-&gt;</span> rtag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>  <span class="token comment">// 更新前驱，注意这个是引用类型</span>
        <span class="token function">InThread</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">,</span> pre<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 线索化右边的二叉树</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// 建立中序线索化二叉树</span>
<span class="token keyword">void</span> <span class="token function">CreatInThread</span><span class="token punctuation">(</span>ThreadTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    ThreadTree pre <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">InThread</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> pre<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 线索化</span>
        pre <span class="token operator">-&gt;</span> rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">// 处理遍历的最后一个结点</span>
        pre <span class="token operator">-&gt;</span> rtag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>二叉树的线索链表上<strong>添加一个头结点</strong>，令其 <strong><code>lchild</code> 指向二叉树的根结点</strong>，<strong><code>rchild</code> 指向中序遍历的最后一个结点</strong></p><p>令<strong>中序遍历</strong>的<strong>第一个结点的 <code>lchild</code></strong> 和<strong>最后一个结点的 <code>rchild</code></strong> 均<strong>指向头结点</strong></p><p>这就好比为二叉树建立了一个双向线索链表，<strong>方便</strong>从前往后或从后往前<strong>对线索二叉树进行遍历</strong></p><figure><img src="/408doc/408noteImg/images/image-20210917230116841.png" alt="image-20210917230116841" tabindex="0" loading="lazy"><figcaption>image-20210917230116841</figcaption></figure><h4 id="中序线索二叉树的遍历" tabindex="-1"><a class="header-anchor" href="#中序线索二叉树的遍历" aria-hidden="true">#</a> 中序线索二叉树的遍历</h4><p>线索二叉树的结点中隐含了线索二叉树的前驱与后继的信息</p><p>遍历时只要<strong>找到序列中的第一个结点</strong>，然后<strong>依次找结点的后继</strong>，<strong>直至后继为空</strong></p><p>当右标志为 1 时，<strong>后继为右线索</strong>；当右标志为 0 时，<strong>后继为右子树的最左子树</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 找中序线索二叉树中中序序列下的第一个结点</span>
ThreadNode <span class="token operator">*</span><span class="token function">Firstnode</span><span class="token punctuation">(</span>ThreadNode <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> ltag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> p <span class="token operator">=</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span> <span class="token comment">// 最左下结点（不一定是叶结点）</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// 找中序线索二叉树中结点 p 在中序序列下的后继</span>
ThreadNode <span class="token operator">*</span><span class="token function">Nextnode</span><span class="token punctuation">(</span>ThreadNode <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> rtag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">Firstnode</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>  <span class="token comment">// rtag == 1直接返回后继线索</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// 遍历线索二叉树</span>
<span class="token keyword">void</span> <span class="token function">Inorder</span><span class="token punctuation">(</span>ThreadNode <span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>ThreadNode <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">Firstnode</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> p <span class="token operator">=</span> <span class="token function">Nextnode</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="先序和后序线索二叉树" tabindex="-1"><a class="header-anchor" href="#先序和后序线索二叉树" aria-hidden="true">#</a> 先序和后序线索二叉树</h4><p>先序线索二叉树和后序线索二叉树的代码类似，只需变动<strong>线索化的代码</strong>与<strong>线索化左右子树递归</strong>的<strong>位置</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 先序线索化</span>
<span class="token keyword">void</span> <span class="token function">PreThread</span><span class="token punctuation">(</span>ThreadTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>  <span class="token comment">// 线索化，与中序先序化一样</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> ltag <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">// 因为上面进行了线索化，所以需要判断一下</span>
            <span class="token function">PreThread</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> rtag <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">// 避免回溯回来造成死循环，当父结点的后继是自己时，只有一个左结点时</span>
            <span class="token function">PreThread</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 后序线索化，与中序先序化一样</span>
<span class="token keyword">void</span> <span class="token function">PostThread</span><span class="token punctuation">(</span>ThreadTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">PostThread</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PostThread</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>  <span class="token comment">// 线索化</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先序线索二叉树中找后继结点：</p><ul><li>如果有左孩子，则其就是后继</li><li>如果只有右孩子，则其就是后继</li><li>如果为叶结点，右索引指向的就是后继</li></ul><p>后序线索二叉树中找后继结点：</p><ul><li>如果是二叉树的根，则没有后继</li><li>如果是双亲的左孩子，且双亲有右孩子，后继为双亲的右孩子按后序遍历列出的第一个结点</li><li>如果是双亲的右孩子，或是左孩子且没有右孩子，后继为双亲</li></ul><p>后序线索二叉树在找后继的时候<strong>需要知道双亲</strong>，所以在<strong>遍历的时候仍需要栈支持</strong>，或者<strong>采用带标志域的三叉链</strong>作为存储结构，<u>先序线索二叉树找其前驱时也不能直接找到</u></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 先序线索二叉树的后继</span>
ThreadNode <span class="token operator">*</span><span class="token function">Nextnode</span><span class="token punctuation">(</span>ThreadNode<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> rtag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> lchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>  <span class="token comment">// 有左孩子</span>
        <span class="token keyword">return</span> p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>  <span class="token comment">// 只有右孩子</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>  <span class="token comment">// 叶结点返回线索</span>
<span class="token punctuation">}</span>


<span class="token comment">// 遍历先序线索二叉树</span>
<span class="token keyword">void</span> <span class="token function">Preorder</span><span class="token punctuation">(</span>ThreadTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>ThreadNode <span class="token operator">*</span>p <span class="token operator">=</span> T<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> p <span class="token operator">=</span> <span class="token function">Nextnode</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 后序线索二叉树的前序</span>
ThreadNode <span class="token operator">*</span><span class="token function">Prenode</span><span class="token punctuation">(</span>ThreadNode<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 后序线索二叉树的前驱刚好就是先序线索二叉树的后继的反转</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> ltag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> rchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>
        <span class="token keyword">return</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 逆向遍历线索二叉树</span>
<span class="token keyword">void</span> <span class="token function">RevPostorder</span><span class="token punctuation">(</span>ThreadTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 如果想要正向遍历可以使用栈来辅助</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>ThreadNode <span class="token operator">*</span>p <span class="token operator">=</span> T<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> p <span class="token operator">=</span> <span class="token function">Prenode</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="综合应用题" tabindex="-1"><a class="header-anchor" href="#综合应用题" aria-hidden="true">#</a> 综合应用题</h3><h4 id="非递归求二叉树高度" tabindex="-1"><a class="header-anchor" href="#非递归求二叉树高度" aria-hidden="true">#</a> 非递归求二叉树高度</h4><p>问题：假设二叉树采用二叉链表存储，设计一个非递归算法求二叉树的高度</p><p>思路：</p><p>使用层次遍历，记录当前层的最后一个元素，当出列的是当前层的最后一个元素时，记录下一层的最后元素，层数加一</p><p>因为出列到当前层的最后一个元素时，下一层的所有元素已经入队了，所有这时记录队尾就是下一层最后一个元素</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">Btdepth</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> front <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> rear <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> last <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> level <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    BiTree Q<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
    Q<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> T<span class="token punctuation">;</span>  <span class="token comment">// 根入列</span>
    BiTree p<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>front <span class="token operator">&lt;</span> rear<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> Q<span class="token punctuation">[</span><span class="token operator">++</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 出队</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span>  <span class="token comment">// 左孩子入队</span>
            Q<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-&gt;</span>lchild<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span>  <span class="token comment">// 右孩子入队</span>
            Q<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>front <span class="token operator">==</span> last<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 当出队的是当前层最后一个时</span>
            level<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">// 层数加一</span>
            last <span class="token operator">=</span> rear<span class="token punctuation">;</span>  <span class="token comment">// 指向下一层的最后一个</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> level<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="访问-x-的所有祖先" tabindex="-1"><a class="header-anchor" href="#访问-x-的所有祖先" aria-hidden="true">#</a> 访问 x 的所有祖先</h4><p>问题：在二叉树中查找值为 x 的结点，试编写算法打印值为 x 的结点的所有祖先，假设值为 x 的结点不多于一个</p><p>思路：使用带栈的后序遍历，当访问到值为 x 的结点时，栈中所有元素均为该结点的祖先</p><p>后序遍历是指，访问可以任何时候访问，但入栈要先左后右，出栈要在左右入栈之后</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    BiTree t<span class="token punctuation">;</span>
    <span class="token keyword">int</span> tag<span class="token punctuation">;</span>  <span class="token comment">// 0 表示左孩子被访问；1 表示右孩子被访问</span>
<span class="token punctuation">}</span> stack<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Search</span><span class="token punctuation">(</span>BiTree bt<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    stack s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 假设栈足够大</span>
    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>bt <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> top <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 访问该结点，访问在左之前，而出栈在右之后，中操作其实就是出栈操作</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>bt <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> bt <span class="token operator">-&gt;</span> data <span class="token operator">!=</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            s<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>t <span class="token operator">=</span> bt<span class="token punctuation">;</span>
            s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            bt <span class="token operator">=</span> bt <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>bt <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> bt <span class="token operator">-&gt;</span> data <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 找到 x</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;所查结点的所有祖先结点的值为：\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> top<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>t <span class="token operator">-&gt;</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 退栈，右结点都被访问了的结点已经遍历完了，退到右结点没被访问的结点</span>
        <span class="token comment">// 感觉可以把判断操作放在出栈之后，而不是在入栈的时候直接判断，可能是为了节省性能才先访问吧</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>top <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
            top<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token comment">// 来到这里 bt 已经是 NULL，且栈顶只有右结点未被访问</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 设置为访问它的右结点</span>
            bt <span class="token operator">=</span> s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>t <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>  <span class="token comment">// 开始访问右结点</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>感觉这种递归没有<a href="#%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">栈实现后序遍历</a>的代码好用，思维也没它清晰</p><h4 id="访问-p、q-的最近共同祖先" tabindex="-1"><a class="header-anchor" href="#访问-p、q-的最近共同祖先" aria-hidden="true">#</a> 访问 p、q 的最近共同祖先</h4><p>问题：设一棵二叉树的结点结构为 <code>(LLINK, INFO, RLINK)</code>，ROOT为指向该二叉树根结点的指针，p 和 q 分别指向该二叉树中任意两个结点的指针，试编写算法 <code>ANCESTOR(ROOT, p, q, r)</code>，找到 p 和 q 的最近公共祖先结点 r</p><p>思路：使用后序遍历加辅助栈，把第一个找到的结点的所有祖先放入辅助栈中，找到第二个时把辅助栈与当前栈比较</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    BiTree t<span class="token punctuation">;</span>
    <span class="token keyword">int</span> tag<span class="token punctuation">;</span>  <span class="token comment">// 0 表示左孩子被访问；1 表示右孩子被访问</span>
<span class="token punctuation">}</span> stack<span class="token punctuation">;</span>

BiTree <span class="token function">Ancestor</span><span class="token punctuation">(</span>BiTree ROOT<span class="token punctuation">,</span> BiTNode <span class="token operator">*</span>p<span class="token punctuation">,</span> BiTNode <span class="token operator">*</span>q<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    stack s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 假设栈足够大</span>
    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> top1<span class="token punctuation">;</span>
    BiTree bt <span class="token operator">=</span> ROOT<span class="token punctuation">;</span>
    bool find <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>bt <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> top <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 访问该结点，访问在左之前，而出栈在右之后，中操作其实就是出栈操作</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>bt <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            s<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>t <span class="token operator">=</span> bt<span class="token punctuation">;</span>
            s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            bt <span class="token operator">=</span> bt <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 右结点都被访问了的结点已经遍历完了，出栈执行操作了</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>top <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>t <span class="token operator">==</span> p <span class="token operator">||</span> s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>t <span class="token operator">==</span> q<span class="token punctuation">)</span>  <span class="token comment">// 是要找的两结点之一</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>find<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 找到第一个</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> top<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">// 把栈拷贝到辅助中保存</span>
                        s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    top1 <span class="token operator">=</span> top<span class="token punctuation">;</span>
                    find <span class="token operator">=</span> true<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment">// 找到第二个</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> top<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">// 第一个不相等的结点的父结点就是最近的共同祖先</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>t <span class="token operator">!=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>t<span class="token punctuation">)</span>
                            <span class="token keyword">return</span> s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>t<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            top<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 来到这里 bt 已经是 NULL，且栈顶只有右结点未被访问</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 设置为访问它的右结点</span>
            bt <span class="token operator">=</span> s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">.</span>t <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>  <span class="token comment">// 开始访问右结点</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我看见答案的时候很失望，居然是这种简单普遍的解法，代码也有点问题，修改了一下不一定能执行</p><h4 id="树的最大宽度" tabindex="-1"><a class="header-anchor" href="#树的最大宽度" aria-hidden="true">#</a> 树的最大宽度</h4><p>题目：假设二叉树采用二叉链表存储结构，设计一个算法，求非空二叉树 b 的宽度（结点最多的那层的结点个数）</p><p>思路：使用队列层序遍历，队列中不仅带结点，还带结点所在的层数</p><p>根部层数为 1，入队时左子树的层数是自己层数加一，右子树也是一样</p><p>最后扫描队列求出各层的结点的总数，最大的层结点总数就是树的宽度了</p><h4 id="满二叉树的先序转后序" tabindex="-1"><a class="header-anchor" href="#满二叉树的先序转后序" aria-hidden="true">#</a> 满二叉树的先序转后序</h4><p>题目：设有一棵<strong>满二叉树</strong>，所有结点值均不同，已知其先序序列为 <code>pre</code>，设计一个算法求其后序序列 <code>post</code></p><p>思考：对于先序和后序有一条规则，<strong>先序的第一位等于后序的最后一位</strong>，那么我们根据这条规则就可以想出：</p><ol><li>取出先序序列的第一个放入后序序列的最后一个</li><li>除掉第一位的先序序列从中间拆开，左半是左子树，右半是右子树；左 1 就时左根，右 1 就是右根</li><li>后序序列是左右中，现在反过来就是中右左了，第二步时中放完了，现在放右，对右子树根结点递归到 1</li><li>根据中右左，右子树的信息放完了就该放左子树，从左子树开始，对左子树根结点递归到 1</li></ol><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/**
 * pre: 前序序列
 * l1: pre 的第一个结点的下标
 * h1: pre 的最后一个结点的下标
 * post: 后序序列
 * l2: post 的第一个结点的下标
 * h2: post 的最后一个结点的下标
 */</span>
<span class="token keyword">void</span> <span class="token function">PreToPost</span><span class="token punctuation">(</span><span class="token keyword">char</span> pre<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l1<span class="token punctuation">,</span> <span class="token keyword">int</span> r1<span class="token punctuation">,</span> <span class="token keyword">char</span> post<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l2<span class="token punctuation">,</span> <span class="token keyword">int</span> r2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> mid<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>r1 <span class="token operator">&gt;=</span> l1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        post<span class="token punctuation">[</span>r2<span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">[</span>l1<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 中</span>
        mid <span class="token operator">=</span> <span class="token punctuation">(</span>r1 <span class="token operator">-</span> l1<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token function">PreToPost</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> l1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> l1 <span class="token operator">+</span> mid<span class="token punctuation">,</span> post<span class="token punctuation">,</span> l2<span class="token punctuation">,</span> l2 <span class="token operator">+</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 左，前半段放左</span>
        <span class="token function">PreToPost</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> l1 <span class="token operator">+</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> post<span class="token punctuation">,</span> l2 <span class="token operator">+</span> mid<span class="token punctuation">,</span> r2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 右，后半段放右</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="中序结点找后序前驱" tabindex="-1"><a class="header-anchor" href="#中序结点找后序前驱" aria-hidden="true">#</a> 中序结点找后序前驱</h4><p>题目：写出在中序线索二叉树里查找指定结点在后序的前驱结点的算法</p><p>思路：结合中序和后序线索二叉树，思考各种情况，得到以下规律：</p><ol><li>若结点 p 有右孩子，则右孩子是其前驱</li><li>若无右孩子但有左孩子，则左孩子是其前驱</li><li>拿其中序左线索，为空就没有前驱</li><li>中序左线索指向的祖先 f，它有左子树，则前驱就是 f 的左子树</li><li>若 f 的左子树为空，就取其中序左线索，循环直到它左子树不为空，前驱就是左子树</li><li>若循环时 f 的左子树为空了（没有线索了）就没有前驱</li></ol><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>BiThrTree <span class="token function">InPostPre</span><span class="token punctuation">(</span>BiThrTree t<span class="token punctuation">,</span> BiThrTree p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    BiThrTree q<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> rtag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">// 第一步，有右返回右</span>
        q <span class="token operator">=</span> p <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">-</span> <span class="token operator">&gt;</span> ltag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">// 第二部，无右有左返回左</span>
        q <span class="token operator">=</span>  p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> lchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token comment">// 第三步，无线索无前驱</span>
        q <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> ltag <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> p <span class="token operator">-&gt;</span> lchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token comment">// 循环直到有左子树</span>
            p <span class="token operator">=</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> ltag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">// 有左子树，前驱是左子树</span>
            q <span class="token operator">=</span> p <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
        <span class="token keyword">else</span>  <span class="token comment">// 没有无前驱</span>
            q <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> q<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="树、森林" tabindex="-1"><a class="header-anchor" href="#树、森林" aria-hidden="true">#</a> 树、森林</h2><h3 id="树的存储结构" tabindex="-1"><a class="header-anchor" href="#树的存储结构" aria-hidden="true">#</a> 树的存储结构</h3><h4 id="双亲表示法" tabindex="-1"><a class="header-anchor" href="#双亲表示法" aria-hidden="true">#</a> 双亲表示法</h4><p>采用一组<strong>连续的空间</strong>存储每个结点，并在每个结点中<strong>记录其父结点的索引</strong>，它的存储结构描述：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_TREE_SIZE</span> <span class="token expression"><span class="token number">100</span></span></span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    ElemType data<span class="token punctuation">;</span>  <span class="token comment">// 数据元素</span>
    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>  <span class="token comment">// 双亲的索引</span>
<span class="token punctuation">}</span> PTNode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    PTNode nodes<span class="token punctuation">[</span>MAX_TREE_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 结点信息</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>  <span class="token comment">// 结点数</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/408doc/408noteImg/images/image-20210919141347791.png" alt="image-20210919141347791" tabindex="0" loading="lazy"><figcaption>image-20210919141347791</figcaption></figure><p>该存储结构利用了每个结点<strong>只有一个双亲</strong>的性质，可以很快得到结点的双亲，但<strong>获取结点的孩子</strong>需要<strong>遍历整个结构</strong></p><p>注意：注意树和二叉树的最大的区别是，它的<strong>儿子数量不是固定的</strong>，所以才需要记录双亲的索引</p><h4 id="孩子表示法" tabindex="-1"><a class="header-anchor" href="#孩子表示法" aria-hidden="true">#</a> 孩子表示法</h4><p>将<strong>每个结点的孩子都用单链表连接起来</strong>形成一个线性结构，此时 n 个结点就有 n 个孩子链表</p><p>该存储结构寻找子女操作很简单，但是<strong>寻找双亲</strong>就要<strong>迭代全部整个孩子链表</strong>了</p><figure><img src="/408doc/408noteImg/images/image-20210919142223692.png" alt="image-20210919142223692" tabindex="0" loading="lazy"><figcaption>image-20210919142223692</figcaption></figure><h4 id="孩子兄弟表示法" tabindex="-1"><a class="header-anchor" href="#孩子兄弟表示法" aria-hidden="true">#</a> 孩子兄弟表示法</h4><p>孩子兄弟表示法又称<strong>二叉树表示法</strong>，以二叉链表作为树的存储结构</p><p>其中<strong>左指针</strong>指向结点的<strong>第一个孩子结点</strong>，<strong>右指针</strong>指向该结点的<strong>下一个兄弟结点</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CSNode</span> <span class="token punctuation">{</span>
    ElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">CSNode</span> <span class="token operator">*</span>firstchild<span class="token punctuation">,</span> <span class="token operator">*</span>nextsibling<span class="token punctuation">;</span>
<span class="token punctuation">}</span> CSNode<span class="token punctuation">,</span> <span class="token operator">*</span>CSTree<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该存储结构可以方便地实现<strong>树转换为二叉树的操作</strong>，易于<strong>找结点的孩子</strong>，但<strong>找其双亲比较麻烦</strong></p><p>若为每个结点<strong>增设一个 parent 域</strong>指向其父结点，则查<strong>找结点的父结点也很方便</strong></p><figure><img src="/408doc/408noteImg/images/image-20210919144047050.png" alt="image-20210919144047050" tabindex="0" loading="lazy"><figcaption>image-20210919144047050</figcaption></figure><h3 id="树、森林与二叉树的转换" tabindex="-1"><a class="header-anchor" href="#树、森林与二叉树的转换" aria-hidden="true">#</a> 树、森林与二叉树的转换</h3><p>给定一森林，可以找到<strong>唯一的二叉树</strong>与之对应；同样的给定一棵二叉树，可以找到<strong>唯一的森林</strong>与它对应</p><p>二叉树与森林从物理结构上看它们的二叉链表是相同的，但<strong>解释不一样</strong></p><p>以下都是逻辑上的转换（考试画图，或选择题逻辑），因为在计算机内二叉树本就是森林的存储结构，不用转换</p><p>选择题：将森林 F 转换为对应的二叉树 T，F 中<strong>叶结点的个数</strong>等于 T 中<strong>左孩子指针为空的结点个数</strong>；F 中的<strong>非终端结点个数</strong>等于 T 中<strong>右孩子指针为空的结点个数减一</strong></p><ol><li><p>根据左孩子右兄弟，T 中左指针为空意味着森林的某个结点没有孩子，所以左指针空的个数是 F 中叶结点的个数</p></li><li><p>根据左孩子右兄弟，T 中右指针为空意味着森林中某个结点没有右兄弟</p><p>首先非终端结点肯定有孩子，那么它的孩子中肯定就会有一个没有右兄弟</p><p>就有 T 中右指针为空的个数至少为 F 中非终端的个数</p><p>其次对于根结点来说，除了它的孩子会没有右兄弟外它自己也没有右兄弟</p><p>把根结点算上，就有 T 的右指针为空的个数就是 F 的非终端的个数加一</p></li></ol><h4 id="树转换成二叉树" tabindex="-1"><a class="header-anchor" href="#树转换成二叉树" aria-hidden="true">#</a> 树转换成二叉树</h4><p>每个结点的<strong>左指针指向它的第一个孩子</strong>，<strong>右指针指向它在树中的相邻右兄弟</strong>，这是<strong>左孩子右兄弟</strong></p><p>树转换成二叉树的画法：</p><ol><li>在兄弟结点之间加一连线</li><li>仅保留指向第一个孩子的指针</li><li>以树根为中心顺时针旋转 45°</li></ol><h4 id="森林转换成二叉树" tabindex="-1"><a class="header-anchor" href="#森林转换成二叉树" aria-hidden="true">#</a> 森林转换成二叉树</h4><p>森林转换成二叉树与树类似，只要把<strong>第二棵树看成第一棵树的右兄弟</strong>，依次类推就好了</p><p>森林转换成二叉树的画法：</p><ol><li>将森林的没课树转换成相应的二叉树</li><li>每棵树的根视为兄弟关系，在每棵树的根间加一条连线</li><li>以第一棵树的根为中心顺时针旋转 45°</li></ol><h4 id="二叉树转换成树、森林" tabindex="-1"><a class="header-anchor" href="#二叉树转换成树、森林" aria-hidden="true">#</a> 二叉树转换成树、森林</h4><ul><li>若二叉树非空，二叉树的根及其左子树为第一棵树的二叉树形式</li><li>将根的右链断开，它的右子树视为一个森林来处理，如此反复，直到没有右子树</li><li>最后将每课二叉树依次转换成树，就得到原森林</li></ul><h3 id="树和森林的遍历" tabindex="-1"><a class="header-anchor" href="#树和森林的遍历" aria-hidden="true">#</a> 树和森林的遍历</h3><h4 id="树的遍历" tabindex="-1"><a class="header-anchor" href="#树的遍历" aria-hidden="true">#</a> 树的遍历</h4><ul><li><p>先根遍历：若树非空，先访问根结点，再依次遍历根结点的每个子树，遍历时仍采用先根遍历</p><p>其遍历序列与这棵树<strong>相应二叉树的先序遍历相同</strong></p></li><li><p>后根遍历：若树非空，先依次遍历根结点的每个子树，再访问根结点，遍历时仍采用后根遍历</p><p>其遍历序列与这棵树<strong>相应的二叉树的中序遍历相同</strong></p></li><li><p>层次遍历：与二叉树的层次遍历一样，使用队列，先入根结点，出列一个结点时把其子树全部入列</p></li></ul><h4 id="森林的遍历" tabindex="-1"><a class="header-anchor" href="#森林的遍历" aria-hidden="true">#</a> 森林的遍历</h4><ol><li>先序遍历森林，若森林非空，就执行遍历： <ul><li>访问森林中第一棵树的根结点</li><li>先序遍历第一棵树种根结点的子树森林（这两步相当于前根遍历，先自己，再遍历子结点）</li><li>先序遍历除去第一棵树之后剩余的树构成的森林（对第二棵树，第三棵等递归使用前根遍历）</li></ul></li><li>中序遍历森林（也可以叫后序遍历），若森林非空，就执行遍历： <ul><li>中序遍历森林中第一棵树的根结点的子树森林</li><li>访问第一棵树的根结点（这两步相当于后根遍历，先遍历子结点，再自己）</li><li>中序遍历除去第一棵树之后剩余的树构成的森林（对第二棵树，第三棵等递归使用后根遍历）</li></ul></li></ol><p><strong>先序遍历</strong>森林就相当于<strong>先序遍历其相应的二叉树</strong>；<strong>中序遍历</strong>森林就相当于<strong>中序遍历其相应的二叉树</strong></p><img src="/408doc/408noteImg/images/image-20210919152628452.png" alt="image-20210919152628452" style="zoom:200%;"><p>注意：<strong>中序遍历</strong>森林，<strong>也可以叫中根遍历</strong>因为对于其二叉树是中根遍历，<strong>也可以叫后根遍历</strong>因为对于树是后根遍历的</p><h3 id="树的应用——并查集" tabindex="-1"><a class="header-anchor" href="#树的应用——并查集" aria-hidden="true">#</a> *树的应用——并查集</h3><p>并查集是一种<strong>简单的集合表示</strong>，它支持以下三种操作：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">Union</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> Root1<span class="token punctuation">,</span> Root2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 把集合 S 的子集合 Root2 并入子集合 Root1，要求它们不能相交</span>
<span class="token function">Find</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 查找集合 S 中单元素 x 所在的子集合，返回子集合名字</span>
<span class="token function">Initial</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将集合 S 中的每个元素都初始化为只有一个单元的集合</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通常用<strong>森林的双亲表示</strong>作为并查集的存储结构，<strong>每个子集以一棵树表示</strong></p><p>通常以<strong>数组的下标表示元素名</strong>，用<strong>根结点的下标代表子集合名</strong>，<strong>根结点的双亲结点为负数</strong></p><p>合并两个子集，只需将其中<strong>一个子集合根结点的双亲指针指向另一个集合的根结点</strong></p><p>使用双亲指针数组作为并查集存储表示时，<strong>集合元素编号从 0 到 size - 1</strong>，其中 size 是最大元素的个数</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">defind</span> <span class="token expression">SIZE <span class="token number">100</span></span></span>
<span class="token keyword">int</span> UFSets<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 集合元素（双亲数组）</span>

<span class="token comment">// 初始化并查集，所有初始化为 -1，即各自都是一棵树</span>
<span class="token keyword">void</span> <span class="token function">Initial</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 查找 S 中包含 x 的树的根结点</span>
<span class="token keyword">int</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>S<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        x <span class="token operator">=</span> S<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 合并两个不相交的子集，即求并集</span>
<span class="token keyword">void</span> <span class="token function">Union</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> Root1<span class="token punctuation">,</span> <span class="token keyword">int</span> Root2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    S<span class="token punctuation">[</span>Root2<span class="token punctuation">]</span> <span class="token operator">=</span> Root1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="层次序列及度构成孩子兄弟链表" tabindex="-1"><a class="header-anchor" href="#层次序列及度构成孩子兄弟链表" aria-hidden="true">#</a> 层次序列及度构成孩子兄弟链表</h3><p>问题：已知一棵树的层次序列及每个结点的度，编写算法构成此树的孩子兄弟链表</p><p>思路：由于有结点的度，我们可以拿到结点的子结点并链到结点上，只需要使用遍历记录子结点的位置合父结点的位置</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">maxNodes</span> <span class="token expression"><span class="token number">15</span></span></span>

<span class="token keyword">void</span> <span class="token function">createCSTreeDegree</span><span class="token punctuation">(</span>CSTree <span class="token operator">&amp;</span>T<span class="token punctuation">,</span> DataType e<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> degree<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    CSTree <span class="token operator">*</span>pointer <span class="token operator">=</span> new CSTree<span class="token punctuation">[</span>maxNodes<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> d<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 初始化数组</span>
        pointer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> new CSNode<span class="token punctuation">;</span>
        pointer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-&gt;</span> data <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        pointer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-&gt;</span> lchild <span class="token operator">=</span> pointer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-&gt;</span> rsibling <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 调整树的关系</span>
        d <span class="token operator">=</span> degree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 当前结点的度数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            k<span class="token operator">++</span><span class="token punctuation">;</span>
            pointer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-&gt;</span> lchild <span class="token operator">=</span> pointer<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 把该结点的子结点链入</span>
                k<span class="token operator">++</span><span class="token punctuation">;</span>
                pointer<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> rsibling <span class="token operator">=</span> pointer<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    T <span class="token operator">=</span> pointer<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    delete <span class="token punctuation">[</span><span class="token punctuation">]</span> pointer<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>书上采用的是辅助数组直接初始化，然后分别链上去，而我更想用队列，下面是我使用队列写的</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 创建新的结点</span>
CSNode <span class="token operator">*</span><span class="token function">createCSNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	CSNode <span class="token operator">*</span>r <span class="token operator">=</span> new CSNode<span class="token punctuation">;</span>
	r<span class="token operator">-&gt;</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
	r<span class="token operator">-&gt;</span>rchild <span class="token operator">=</span> r<span class="token operator">-&gt;</span>lchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">createCSTreeDegree</span><span class="token punctuation">(</span>CSTree <span class="token operator">&amp;</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> degree<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	LinkQueue Q<span class="token punctuation">;</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> d<span class="token punctuation">;</span>
	CSNode <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>
	<span class="token function">InitQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>
	T <span class="token operator">=</span> <span class="token function">createCSNode</span><span class="token punctuation">(</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 创建根部结点</span>
	<span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">DeQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
		i<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">=</span> degree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 如果有度就是有儿子，把儿子链入然后入队列</span>
			k<span class="token operator">++</span><span class="token punctuation">;</span>
			q <span class="token operator">=</span> p<span class="token operator">-&gt;</span>lchild <span class="token operator">=</span> <span class="token function">createCSNode</span><span class="token punctuation">(</span>e<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				k<span class="token operator">++</span><span class="token punctuation">;</span>
				q<span class="token operator">-&gt;</span>rchild <span class="token operator">=</span> <span class="token function">createCSNode</span><span class="token punctuation">(</span>e<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				q <span class="token operator">=</span> q<span class="token operator">-&gt;</span>rchild<span class="token punctuation">;</span>
				<span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="树与二叉树的应用" tabindex="-1"><a class="header-anchor" href="#树与二叉树的应用" aria-hidden="true">#</a> 树与二叉树的应用</h2><h3 id="二叉排序树-1" tabindex="-1"><a class="header-anchor" href="#二叉排序树-1" aria-hidden="true">#</a> 二叉排序树</h3><h4 id="二叉排序树的定义" tabindex="-1"><a class="header-anchor" href="#二叉排序树的定义" aria-hidden="true">#</a> 二叉排序树的定义</h4><p><strong>二叉排序树</strong>也称<strong>二叉查找树</strong>，是<strong>一棵空树</strong>，或者是<strong>具有以下特性的二叉树</strong>：</p><ol><li>若左子树非空，则左子树上所有结点的值均小于根结点的值</li><li>若右子树非空，则右子树上所有结点的值均大于根结点的值</li><li>左、右子树也分配时一棵二叉排序树</li></ol><p>根据二叉树的定义有<strong>左子树的值 &lt; 根结点值 &lt; 右子树的值</strong>，所以对二叉排序树进行<strong>中序遍历</strong>就会得到一个<strong>递增序列</strong></p><h4 id="二叉排序树的查找" tabindex="-1"><a class="header-anchor" href="#二叉排序树的查找" aria-hidden="true">#</a> 二叉排序树的查找</h4><p>二叉排序树<strong>从根结点开始查找</strong>，先<strong>和根结点的值进行比较</strong>，<u>相等则查找成功；小于就递归左子树；大于就递归右子树</u></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>BSTNode <span class="token operator">*</span><span class="token function">BST_Search</span><span class="token punctuation">(</span>BSTree T<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> key <span class="token operator">!=</span> T <span class="token operator">-&gt;</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">&gt;</span> T <span class="token operator">-&gt;</span> key<span class="token punctuation">)</span> T <span class="token operator">=</span> T <span class="token operator">-&gt;</span> rchild<span class="token punctuation">;</span>
        <span class="token keyword">else</span> T <span class="token operator">=</span> T <span class="token operator">-&gt;</span> lchild<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> T<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="二叉排序树的插入" tabindex="-1"><a class="header-anchor" href="#二叉排序树的插入" aria-hidden="true">#</a> 二叉排序树的插入</h4><p>二叉排序树作为一种<strong>动态树表</strong>，特点是树的结构不是一次生成的，而是<strong>在查找过程中发现值不存在后的插入</strong></p><p>插入过程如下：</p><ul><li>若原二叉树为空则直接插入结点</li><li>若关键字 k 小于根结点值，则插入左子树；否则插入到右子树</li></ul><p>插入的点一定是一个<strong>新添加的叶结点</strong>，而且是查找失败时的<strong>查找路径上最后访问结点的子结点</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">BST_Insert</span><span class="token punctuation">(</span>BSTree <span class="token operator">&amp;</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        T <span class="token operator">=</span> <span class="token punctuation">(</span>BSTNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BSTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        T <span class="token operator">-&gt;</span> key <span class="token operator">=</span> k<span class="token punctuation">;</span>
        T <span class="token operator">-&gt;</span> lchild <span class="token operator">=</span> T <span class="token operator">-&gt;</span> rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 插入成功</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> key <span class="token operator">==</span> k<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 插入失败</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">&gt;</span> T <span class="token operator">-&gt;</span> key<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">BST_Insert</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> rchild<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// key 比根结点的大插到右边</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token function">BST_Insert</span><span class="token punctuation">(</span>T <span class="token operator">-&gt;</span> lchild<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// key 比根结点的小插到左边</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="二叉排序树的构造" tabindex="-1"><a class="header-anchor" href="#二叉排序树的构造" aria-hidden="true">#</a> 二叉排序树的构造</h4><p>二叉排序树的构造就是从一棵空树出发，一次输入元素，将它们插入二叉排序树中的合适位置</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">Creat_BST</span><span class="token punctuation">(</span>BSTree <span class="token operator">&amp;</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    T <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">BST_Insert</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="二叉排序树的删除" tabindex="-1"><a class="header-anchor" href="#二叉排序树的删除" aria-hidden="true">#</a> 二叉排序树的删除</h4><p>二叉排序树的删除不是把以该结点为根的子树都删除，而是<strong>仅删除该结点</strong>，然后<strong>调整二叉排序树</strong>，使他仍是二叉排序树</p><p>删除操作的实现过程按 3 种情况来处理：</p><ol><li>若被删除结点 z 是叶结点，则直接删除，因为不会破开二叉排序树的性质</li><li>若结点 z 只有一棵子树，则让 z 的子树称为 z 的父结点的子树，代替 z 的位置</li><li>若结点 z 有左右两棵子树，则令它的直接后继（或直接前驱）与 z 交换位置，这时再删除 z 情况就是第一步或第二步了</li></ol><p>思考：二叉排序树种删除后再插入某结点，的到的二叉树取决于删除的位置，若删除的是<strong>叶结点那么相同</strong>，<strong>否则不相同</strong></p><h4 id="二叉排序树的查找效率" tabindex="-1"><a class="header-anchor" href="#二叉排序树的查找效率" aria-hidden="true">#</a> 二叉排序树的查找效率</h4><p>二叉排序树的<strong>查找效率</strong>，<strong>主要取决于树的高度</strong>。二叉树的结点分布比较均匀像<strong>平衡二叉树</strong>那样，平均查找长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>；但如果是一个<strong>单支树</strong>，则平均查找长度为 O(n)</p><p>在最坏情况下，即构造二叉排序树的<strong>输入序列是有序的</strong>，则会<strong>形成一个倾斜的单支树</strong></p><p>在等概率情况下，<strong>查找成功的平均查找长度</strong>为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mstyle scriptlevel="0" displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>d</mi><mi>e</mi><mi>e</mi><mi>p</mi></mrow></munderover><mi>i</mi><mo>×</mo><mi>n</mi><mi>u</mi><msub><mi>m</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>n</mi></mstyle></mrow><annotation encoding="application/x-tex">(\displaystyle\sum_{i=1}^{deep}i\times num_i)/n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.1609em;vertical-align:-1.2777em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8832em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3471em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">ee</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">n</span></span></span></span> 其中 deep 是总深度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">num_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是第 i 层的结点数，n 是结点总数</p><p>在等概率情况下，<strong>查找失败的平均查找长度</strong>为 “(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mo>∑</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6em;vertical-align:-0.55em;"></span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∑</span></span></span></span> NULL 的父亲的层数) / NULL 的个数”</p><p>从查找过程看，二叉排序树与二分查找相似，其平均时间性能差不多，但<strong>二分查找的判定树唯一</strong>，而<strong>二叉排序树的查找不唯一</strong>，相同的关键字其<strong>插入顺序不同可能生成不同的二叉排序树</strong></p><p>维护表的有序性而言，<strong>插入和删除</strong>元素时，<strong>二叉排序树平均执行时间</strong>为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，而<strong>有序顺序表</strong>则需要 O(n)</p><p>所以，当有序表是<strong>静态查找表</strong>时，宜用<strong>顺序表作为存储结构</strong>；若有序表是<strong>动态查找表</strong>，则选择<strong>二叉排序树作为逻辑结构</strong></p><h3 id="平衡二叉树-1" tabindex="-1"><a class="header-anchor" href="#平衡二叉树-1" aria-hidden="true">#</a> 平衡二叉树</h3><h4 id="平衡二叉树的定义" tabindex="-1"><a class="header-anchor" href="#平衡二叉树的定义" aria-hidden="true">#</a> 平衡二叉树的定义</h4><p>避免树的高度增长过快，降低二叉排序树的性能，定义<strong>平衡二叉树</strong>，简称<strong>平衡树</strong>，它的<strong>左右子树高度差的绝对值不超过 1</strong></p><p>结点<strong>左子树与右子树的高度差</strong>称为该结点的<strong>平衡因子</strong>，则平衡二叉树的平衡因子只可能是 -1、0、1</p><p>平衡二叉树可以定义为<strong>一棵空树</strong>，或具有以下性质的树：它的<strong>左子树和右子树都是平衡二叉树</strong>，且<strong>左子树和右子树的高度差的绝对值不超过 1</strong></p><figure><img src="/408doc/408noteImg/images/image-20210920122745558.png" alt="image-20210920122745558" tabindex="0" loading="lazy"><figcaption>image-20210920122745558</figcaption></figure><h4 id="平衡二叉树的旋转" tabindex="-1"><a class="header-anchor" href="#平衡二叉树的旋转" aria-hidden="true">#</a> 平衡二叉树的旋转</h4><h5 id="左旋转" tabindex="-1"><a class="header-anchor" href="#左旋转" aria-hidden="true">#</a> 左旋转</h5><p>左旋是在保持二叉排序树的规则下，令左边层数加一，右边层数减一，步骤为：</p><ol><li>设 r 是根，p 为根的右子树</li><li>r 的右子树变成 p 的左子树</li><li>p 的左子树变成 r</li><li>根结点变成 p</li></ol><figure><img src="/408doc/408noteImg/images/v2-db1cdb0da952a71f9b6d64b2608467eb_b.webp" alt="v2-db1cdb0da952a71f9b6d64b2608467eb_b" tabindex="0" loading="lazy"><figcaption>v2-db1cdb0da952a71f9b6d64b2608467eb_b</figcaption></figure><h5 id="右旋转" tabindex="-1"><a class="header-anchor" href="#右旋转" aria-hidden="true">#</a> 右旋转</h5><p>右旋是在保持二叉排序树的规则下，令右边层数加一，左边层数减一，步骤为：</p><ol><li>设 r 是根，p 是根的左子树</li><li>r 的左子树变成 p 的右子树</li><li>p 的右子树变成 r</li><li>根结点变成 p</li></ol><figure><img src="/408doc/408noteImg/images/v2-05246384c1c16537ca6176983bdb2627_b.webp" alt="v2-05246384c1c16537ca6176983bdb2627_b" tabindex="0" loading="lazy"><figcaption>v2-05246384c1c16537ca6176983bdb2627_b</figcaption></figure><h4 id="平衡二叉树的插入" tabindex="-1"><a class="header-anchor" href="#平衡二叉树的插入" aria-hidden="true">#</a> 平衡二叉树的插入</h4><p>在<strong>插入或删除后</strong>，检查是否导<strong>致了平衡二叉树失衡</strong>，若失衡就找到距离插入点最近的失衡树，<strong>对它进行调整，使之平衡</strong></p><p>调整是递归的，从最小失衡树，即距离插入点最近的不平衡树，一直向上调整，<strong>直到整棵树没有失衡点为止</strong></p><p>平衡二叉树的<strong>插入部分和二叉查找树相同</strong>，若插入后<strong>不平衡需要调整</strong>，则有<strong>以下 4 条规律</strong>：</p><ol><li>LL 平衡旋转，当插入的点在失衡点的左子树的左子树内，以失衡点为轴进行右旋</li><li>RR 平衡旋转，当插入的点在失衡点的右子树的右子树内，以失衡点为轴进行左旋</li><li>LR 平衡旋转，当插入的点在失衡点的左子树的右子树内，以失衡点的左子树为轴进行左旋，旋转后变成情况 1</li><li>RL 平衡旋转，当插入的点在失衡点的右子树的左子树内，以失衡点的右子树为轴进行右旋，旋转后变成情况 2</li></ol><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/**
 * 插入后进行调整
 * root : 根结点
 * p : 要调整的结点
 * d : 插入的数据
 */</span>
<span class="token keyword">void</span> <span class="token function">fixAfterInsert</span><span class="token punctuation">(</span>btlink <span class="token operator">&amp;</span>root<span class="token punctuation">,</span> btlink p<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">&lt;</span> p <span class="token operator">-&gt;</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 情况 3，在左边的右边</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">&gt;</span> p <span class="token operator">-&gt;</span> left <span class="token operator">-&gt;</span> element<span class="token punctuation">)</span> <span class="token function">rotateLeft</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> p <span class="token operator">-&gt;</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 情况 1，在左边的左边</span>
        <span class="token function">rotateRight</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 情况 4，在右边的左边</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">&lt;</span> p <span class="token operator">-&gt;</span> right <span class="token operator">-&gt;</span> element<span class="token punctuation">)</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> p <span class="token operator">-&gt;</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 情况 2，在右边的右边</span>
        <span class="token function">rotateLeft</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>插入点在哪里就意味着哪里的层数多加了一层导致失衡，所以要使用旋转把插入点的层数分一层给它兄弟，以达到平衡</p><p>LR 时左旋把左边的右边多出的一层给到左边的左边，这样就是左边的左边多层数，就是 LL 了；RL 同理</p><p>旋转只会让这个被旋转的最小失衡树平衡起来，但这个树的祖先仍然有可能会失衡，所以要递归上去检查和调整</p><h4 id="平衡二叉树的查找" tabindex="-1"><a class="header-anchor" href="#平衡二叉树的查找" aria-hidden="true">#</a> 平衡二叉树的查找</h4><p>平衡二叉树的查找过程与二叉排序树的相同，因此关键字比较的次数不超过树的深度</p><p>假设以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">n_h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示深度为 h 的<strong>平衡树中含有的最少结点数</strong>，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>n</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>n</mi><mn>2</mn></msub><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n_0=0,n_1=1,n_2=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 并且有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>h</mi></msub><mo>=</mo><msub><mi>n</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>n</mi><mrow><mi>k</mi><mo>−</mo><mn>2</mn></mrow></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_h=n_{k-1}+n_{k-2}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p><p>那么就有<strong>平衡二叉树的最大深度</strong>为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，因此<strong>平衡二叉树的平均查找长度</strong>为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，注意这里是有 O 的</p><h5 id="平衡二叉树的最少结点数" tabindex="-1"><a class="header-anchor" href="#平衡二叉树的最少结点数" aria-hidden="true">#</a> 平衡二叉树的最少结点数</h5><p>根据平衡二叉树的定义，它的左右子树都是平衡二叉树</p><p>自己是含有最少结点数，当且仅当左右子树也是含有最小结点的情况下</p><p>那么自己的结点数是左子树的结点 + 右子树的结点 + 1（根结点）</p><p>含有最小结点数，那么左右子树的高度差必然为一</p><p>综上就得出：</p><ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>h</mi></msub><mo>=</mo><msub><mi>n</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>n</mi><mrow><mi>k</mi><mo>−</mo><mn>2</mn></mrow></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_h=n_{k-1}+n_{k-2}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，一个子树结点 + 另一个子树结点 + 1（根结点）</li><li><strong>非叶子结点的平衡叶子的绝对值都为一</strong>，那么这棵树是<strong>含结点最少的平衡二叉树</strong></li></ol><h3 id="哈夫曼树和哈夫曼编码" tabindex="-1"><a class="header-anchor" href="#哈夫曼树和哈夫曼编码" aria-hidden="true">#</a> 哈夫曼树和哈夫曼编码</h3><h4 id="哈夫曼树的定义" tabindex="-1"><a class="header-anchor" href="#哈夫曼树的定义" aria-hidden="true">#</a> 哈夫曼树的定义</h4><p>在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的权</p><p>该<strong>结点的带权路径长度</strong>，是从<strong>树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积</strong></p><p><strong>树的带权路径长度</strong>，记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi><mo>=</mo><mstyle scriptlevel="0" displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>w</mi><mi>i</mi></msub><msub><mi>l</mi><mi>i</mi></msub></mstyle></mrow><annotation encoding="application/x-tex">WPL=\displaystyle\sum^n_{i=1}w_il_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是第 i 个叶结点所带的权值，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">l_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是该也结点到根结点的路径长度，即<strong>所有叶结点的带权路径长度的和</strong></p><figure><img src="/408doc/408noteImg/images/image-20210920141556685.png" alt="image-20210920141556685" tabindex="0" loading="lazy"><figcaption>image-20210920141556685</figcaption></figure><p>哈夫曼树是相同的权叶结点，但 <code>WPL</code> 最小的树，如上面 c 是一棵哈夫曼树</p><h4 id="哈夫曼树的构造" tabindex="-1"><a class="header-anchor" href="#哈夫曼树的构造" aria-hidden="true">#</a> 哈夫曼树的构造</h4><p>给定 n 个权值分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>w</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">w_1,\cdots,w_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的结点，<strong>构造哈夫曼树的算法描述</strong>如下：</p><ol><li>将这 n 个结点分别作为 n 棵仅含一个结点的二叉树，构成森林 F</li><li>构造一个新结点，从 F 中取<strong>两棵根结点权重最小的树</strong>，<strong>合并在一起</strong>，<strong>根结点的权重是这两个权重的和</strong></li><li>从 F 中<strong>删除刚刚选出的两棵树</strong>，并<strong>加入它们的合并树</strong></li><li>重复 2、3 步骤，直至 F 中只剩下一棵树为止</li></ol><p>从上述构造过程中可以看出哈夫曼树具有以下特点：</p><ol><li><strong>每个初始结点最终都成为叶结点</strong>，且<strong>权值越小的结点到根结点的路径长度越大</strong></li><li>构造过程中共新建了 n - 1 个结点，因此<strong>哈夫曼树的结点总数为 <code>2n - 1</code></strong>，n 是叶结点的数量</li><li>每次构造都选择 2 棵树作为新结点的孩子，因此<strong>哈夫曼树中不存在度为 1 的结点</strong></li></ol><img src="/408doc/408noteImg/images/src=http___pic2.zhimg.com_v2-5591c52619c16ddd52a882981fa716cd_b.gif&amp;refer=http___pic2.zhimg.gif" alt="src=http___pic2.zhimg.com_v2-5591c52619c16ddd52a882981fa716cd_b.gif&amp;refer=http___pic2.zhimg"><h4 id="哈夫曼编码" tabindex="-1"><a class="header-anchor" href="#哈夫曼编码" aria-hidden="true">#</a> 哈夫曼编码</h4><p>在数据通信中，对每个字符用<strong>相等长度的二进制位表示</strong>，则称为<strong>固定长度编码</strong>；若对不同字符用<strong>不等长的二进制位表示</strong>，则称为<strong>可变长度编码</strong></p><p>可变长度编码的特点是，对<strong>频率高的字符赋以短编码</strong>，对<strong>频率低的字符赋以较长一点的编码</strong>，从而<strong>缩短字符的平均编码长度</strong>，起到压缩数据的作用</p><p>若<strong>没有一个编码是另一个编码的前缀</strong>，那么称这样的编码为<strong>前缀编码</strong>，如 {0, 00} 不是前缀码，{0, 10} 是前缀码</p><p>前缀编码的解码：因为没有一个编码是其他编码的前缀，解码时只<strong>需识别每一个编码，将它翻译成原码</strong></p><p>哈夫曼编码的构造：</p><ol><li>将每个出现的字符作为哈夫曼树的结点，其权值为字符出现的频率</li><li>拿这些字符结点构成一棵哈夫曼树</li><li>将哈夫曼树的左边标记 0，右边标记 1</li><li>每个字符的编码就是哈夫曼树的根到它所经过边的标记的集合</li></ol><figure><img src="/408doc/408noteImg/images/image-20210920150005087.png" alt="image-20210920150005087" tabindex="0" loading="lazy"><figcaption>image-20210920150005087</figcaption></figure><p>注意：<strong>0 和 1 是左边还是右边没有明确规定</strong>，且<strong>左右结点的顺序是任意的</strong>，所有<strong>构造出的哈夫曼树不唯一</strong>，但<strong>每个哈夫曼树的 <code>WPL</code> 相同且为最优</strong></p><h3 id="综合应用题-1" tabindex="-1"><a class="header-anchor" href="#综合应用题-1" aria-hidden="true">#</a> 综合应用题</h3><h4 id="检验是否为二叉排序树" tabindex="-1"><a class="header-anchor" href="#检验是否为二叉排序树" aria-hidden="true">#</a> 检验是否为二叉排序树</h4><p>题目：试编写一个算法，判断给定的二叉树是否为二叉排序树</p><p>思路：利用二叉排序树的中序会大于它的前驱，只要存储前驱的变量就好了</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> pre <span class="token operator">=</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">JudgeBST</span><span class="token punctuation">(</span>BiTree bt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bt <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">JudgeBST</span><span class="token punctuation">(</span>bt <span class="token operator">-&gt;</span> lchild<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> pre <span class="token operator">&gt;=</span> bt <span class="token operator">-&gt;</span> data<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    pre <span class="token operator">=</span> bt <span class="token operator">-&gt;</span> data<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">JudgeBST</span><span class="token punctuation">(</span>bt <span class="token operator">-&gt;</span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="最小代价合并多个有序表" tabindex="-1"><a class="header-anchor" href="#最小代价合并多个有序表" aria-hidden="true">#</a> 最小代价合并多个有序表</h4><p>问题：设有 6 个有序表 A，B，C，D，E，F，分别含有 10，35，40，50，60，200 个数据元素，各表中的元素按升序排序。要求通过 5 次两两合并，将 6 个表最终合并为 1 个升序表，并使最坏情况下比较的总次数达到最小</p><p>思路：先合并的表中元素在后序的每次合并中都会再次参与比较，因此求最小合并次数类似于求最小带权路径长度，所以就考虑使用哈夫曼树进行运算</p><p>求最坏情况下的比较次数，利用两个有序表合并的最坏情况需要比较 m + n - 1 次来求</p><h2 id="注意" tabindex="-1"><a class="header-anchor" href="#注意" aria-hidden="true">#</a> 注意</h2><p>二叉树是极其重要的考点，关于二叉树的有关操作，出现了树的算法设计题</p><p>遍历时各种操作的基础，统考时会考查遍历过程对结点的各种操作</p><p><strong>需要重点掌握各种遍历方法的手写，如递归算法和利用栈或队列的非递归算法</strong></p></div><!----><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: doc_408@163.com">408doc</span><!--]--><!--]--></div></div></footer><nav class="page-nav"><a href="/408doc/408notes/DS/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%B2.html" class="nav-link prev" aria-label="第四章 串"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->第四章 串</div></a><a href="/408doc/408notes/DS/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%9B%BE.html" class="nav-link next" aria-label="第六章 图"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">第六章 图<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">微信公众号：研小布</div><div class="copyright">Copyright © 2023 研小布</div></footer></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/408doc/assets/app-c8d08271.js" defer></script>
  </body>
</html>
