<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.61" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://ky-doc.github.io/mydoc/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html"><meta property="og:site_name" content="研小布「考研资料站」"><meta property="og:title" content="第四章 指令系统"><meta property="og:description" content="指令格式 指令（机器指令）是指示计算机执行某种操作的命令 一台计算机的所有指令的集合构成该机的指令系统，也称指令集 指令系统是计算机的主要属性，位于硬件和软件的交界面上 指令的基本格式 一条指令就是机器语言的一个语句，一条指令通常包括操作码字段 + 地址码字段： 操作码：该指令应该执行什么性质的操作以及具有何种功能; 操作码是识别指令、了解指令功能及区..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-04-23T10:21:12.000Z"><meta property="article:author" content="研小布"><meta property="article:modified_time" content="2023-04-23T10:21:12.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"第四章 指令系统","image":[""],"dateModified":"2023-04-23T10:21:12.000Z","author":[{"@type":"Person","name":"研小布","url":"https://ky-doc.github.io/mydoc/"}]}</script><title>第四章 指令系统 | 研小布「考研资料站」</title><meta name="description" content="指令格式 指令（机器指令）是指示计算机执行某种操作的命令 一台计算机的所有指令的集合构成该机的指令系统，也称指令集 指令系统是计算机的主要属性，位于硬件和软件的交界面上 指令的基本格式 一条指令就是机器语言的一个语句，一条指令通常包括操作码字段 + 地址码字段： 操作码：该指令应该执行什么性质的操作以及具有何种功能; 操作码是识别指令、了解指令功能及区...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/408doc/assets/style-3c304d4b.css" as="style"><link rel="stylesheet" href="/408doc/assets/style-3c304d4b.css">
    <link rel="modulepreload" href="/408doc/assets/app-5b900c76.js"><link rel="modulepreload" href="/408doc/assets/framework-0cdb5b8e.js"><link rel="modulepreload" href="/408doc/assets/第四章 指令系统.html-99c59951.js"><link rel="modulepreload" href="/408doc/assets/第四章 指令系统.html-c1a36d1c.js"><link rel="prefetch" href="/408doc/assets/index.html-d2a4e6e9.js" as="script"><link rel="prefetch" href="/408doc/assets/408comeon.html-6ebe59f7.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-2fe497c8.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-6c1be11e.js" as="script"><link rel="prefetch" href="/408doc/assets/assembler.html-c5b7603d.js" as="script"><link rel="prefetch" href="/408doc/assets/Cbase.html-ab6c11e3.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-06759294.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-de8f8285.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-3754a632.js" as="script"><link rel="prefetch" href="/408doc/assets/第一章 计算机网络体系结构.html-4c93907b.js" as="script"><link rel="prefetch" href="/408doc/assets/第三章 数据链路层.html-919ccd1a.js" as="script"><link rel="prefetch" href="/408doc/assets/第二章 物理层.html-c97b3f4e.js" as="script"><link rel="prefetch" href="/408doc/assets/第五章 传输层.html-eec4ff65.js" as="script"><link rel="prefetch" href="/408doc/assets/第六章 应用层.html-726f2d89.js" as="script"><link rel="prefetch" href="/408doc/assets/第四章 网络层.html-7d5b2104.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-6991abd4.js" as="script"><link rel="prefetch" href="/408doc/assets/第一章 计算机系统概述.html-9787b137.js" as="script"><link rel="prefetch" href="/408doc/assets/第七章 输入输出系统.html-e408054d.js" as="script"><link rel="prefetch" href="/408doc/assets/第三章 存储系统.html-b3bd2a5f.js" as="script"><link rel="prefetch" href="/408doc/assets/第二章 数据的表示和运算.html-f6040afb.js" as="script"><link rel="prefetch" href="/408doc/assets/第五章 中央处理器.html-02d54831.js" as="script"><link rel="prefetch" href="/408doc/assets/第六章 总线.html-2d43a5d1.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-1b88d9eb.js" as="script"><link rel="prefetch" href="/408doc/assets/第一章 绪论.html-d790a851.js" as="script"><link rel="prefetch" href="/408doc/assets/第七章 查找.html-045240fc.js" as="script"><link rel="prefetch" href="/408doc/assets/第三章 栈、队列和数组.html-cb32dc7e.js" as="script"><link rel="prefetch" href="/408doc/assets/第二章 线性表.html-1ab198f2.js" as="script"><link rel="prefetch" href="/408doc/assets/第五章 树与二叉树.html-7912f703.js" as="script"><link rel="prefetch" href="/408doc/assets/第八章 排序.html-cf794ec6.js" as="script"><link rel="prefetch" href="/408doc/assets/第六章 图.html-de3256fd.js" as="script"><link rel="prefetch" href="/408doc/assets/第四章 串.html-9a61f92c.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-700f5715.js" as="script"><link rel="prefetch" href="/408doc/assets/第一章 操作系统的基本概念.html-609759ea.js" as="script"><link rel="prefetch" href="/408doc/assets/第三章 内存管理.html-052e5b4f.js" as="script"><link rel="prefetch" href="/408doc/assets/第二章 进程管理.html-e90852d1.js" as="script"><link rel="prefetch" href="/408doc/assets/第五章 输入输出管理.html-aced0bdf.js" as="script"><link rel="prefetch" href="/408doc/assets/第四章 文件管理.html-b239627b.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary.html-f23f3973.js" as="script"><link rel="prefetch" href="/408doc/assets/1-physical-layer.html-089c9e70.js" as="script"><link rel="prefetch" href="/408doc/assets/2-data-link-layer.html-5cd4393a.js" as="script"><link rel="prefetch" href="/408doc/assets/3-network-layer.html-afb46e2d.js" as="script"><link rel="prefetch" href="/408doc/assets/4-transport-layer.html-b68dff0c.js" as="script"><link rel="prefetch" href="/408doc/assets/5-application-layer.html-7ec7180c.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-802237ec.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary.html-64e148e3.js" as="script"><link rel="prefetch" href="/408doc/assets/1-data-representation-and-operation.html-d4dc9a06.js" as="script"><link rel="prefetch" href="/408doc/assets/2-storage-system.html-cce076c0.js" as="script"><link rel="prefetch" href="/408doc/assets/3-instruction-system.html-a401042b.js" as="script"><link rel="prefetch" href="/408doc/assets/4-central-processing-unit.html-72dc5acc.js" as="script"><link rel="prefetch" href="/408doc/assets/5-bus.html-e1b68efa.js" as="script"><link rel="prefetch" href="/408doc/assets/6-input-output-system.html-8e65b5b0.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-5f693d8f.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary.html-b989714a.js" as="script"><link rel="prefetch" href="/408doc/assets/1-linear-list.html-bf60e9c2.js" as="script"><link rel="prefetch" href="/408doc/assets/2-stack.html-2b5d4dcd.js" as="script"><link rel="prefetch" href="/408doc/assets/5-string.html-4f11e25b.js" as="script"><link rel="prefetch" href="/408doc/assets/6-tree.html-563e159b.js" as="script"><link rel="prefetch" href="/408doc/assets/7-graph.html-d72196dc.js" as="script"><link rel="prefetch" href="/408doc/assets/8-search.html-b7487118.js" as="script"><link rel="prefetch" href="/408doc/assets/9-sort.html-e2780b3b.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-245528fa.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary.html-6f70cf45.js" as="script"><link rel="prefetch" href="/408doc/assets/1-process-management.html-cb66e14b.js" as="script"><link rel="prefetch" href="/408doc/assets/2-memory-management.html-40ece69e.js" as="script"><link rel="prefetch" href="/408doc/assets/3-file-management.html-e4fadd31.js" as="script"><link rel="prefetch" href="/408doc/assets/4-device-management.html-c004cdea.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-2c943bae.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary-ex.html-af600529.js" as="script"><link rel="prefetch" href="/408doc/assets/1-physical-layer-ex.html-a14aeb69.js" as="script"><link rel="prefetch" href="/408doc/assets/2-data-link-layer-ex.html-68848299.js" as="script"><link rel="prefetch" href="/408doc/assets/3-network-layer-ex.html-d0f425b3.js" as="script"><link rel="prefetch" href="/408doc/assets/4-transport-layer-ex.html-44fcde47.js" as="script"><link rel="prefetch" href="/408doc/assets/5-application-layer-ex.html-3e95cb76.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-eb2dd9c9.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary-ex.html-c7915484.js" as="script"><link rel="prefetch" href="/408doc/assets/1-data-representation-and-operation-ex.html-5adabc9e.js" as="script"><link rel="prefetch" href="/408doc/assets/2-storage-system-ex.html-6518bb77.js" as="script"><link rel="prefetch" href="/408doc/assets/3-instruction-system-ex.html-185f0273.js" as="script"><link rel="prefetch" href="/408doc/assets/4-central-processing-unit-ex.html-a1ad14f4.js" as="script"><link rel="prefetch" href="/408doc/assets/5-bus-ex.html-6dc23956.js" as="script"><link rel="prefetch" href="/408doc/assets/6-input-output-system-ex.html-bdf3f126.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-17029a33.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary-ex.html-cae17ed6.js" as="script"><link rel="prefetch" href="/408doc/assets/1-linear-list-ex.html-14824e9b.js" as="script"><link rel="prefetch" href="/408doc/assets/2-stack-ex.html-a6bb1e59.js" as="script"><link rel="prefetch" href="/408doc/assets/5-string-ex.html-4ca348ab.js" as="script"><link rel="prefetch" href="/408doc/assets/6-tree-ex.html-9f1ddee3.js" as="script"><link rel="prefetch" href="/408doc/assets/7-graph-ex.html-3782643c.js" as="script"><link rel="prefetch" href="/408doc/assets/8-search-ex.html-fbb6bfab.js" as="script"><link rel="prefetch" href="/408doc/assets/9-sort-ex.html-0547941a.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-816675b0.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary-ex.html-169f1e11.js" as="script"><link rel="prefetch" href="/408doc/assets/1-process-management-ex.html-80fa0ed1.js" as="script"><link rel="prefetch" href="/408doc/assets/2-memory-management-ex.html-3ba88312.js" as="script"><link rel="prefetch" href="/408doc/assets/3-file-management-ex.html-9b005e88.js" as="script"><link rel="prefetch" href="/408doc/assets/4-device-management-ex.html-e9604216.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-1cdd9d64.js" as="script"><link rel="prefetch" href="/408doc/assets/404.html-f6348886.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-fc37095a.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-945c1a7d.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-2aa0b05d.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-30ba0fd6.js" as="script"><link rel="prefetch" href="/408doc/assets/408comeon.html-3f4be526.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-750d153a.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-2b8f42ce.js" as="script"><link rel="prefetch" href="/408doc/assets/assembler.html-cc91330a.js" as="script"><link rel="prefetch" href="/408doc/assets/Cbase.html-4e08240d.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-c2ea2bd7.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-7e8e766a.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-aa75103c.js" as="script"><link rel="prefetch" href="/408doc/assets/第一章 计算机网络体系结构.html-3df4f4f0.js" as="script"><link rel="prefetch" href="/408doc/assets/第三章 数据链路层.html-14888210.js" as="script"><link rel="prefetch" href="/408doc/assets/第二章 物理层.html-5d300969.js" as="script"><link rel="prefetch" href="/408doc/assets/第五章 传输层.html-49840b07.js" as="script"><link rel="prefetch" href="/408doc/assets/第六章 应用层.html-e29ffada.js" as="script"><link rel="prefetch" href="/408doc/assets/第四章 网络层.html-39cf2812.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-0ec09b36.js" as="script"><link rel="prefetch" href="/408doc/assets/第一章 计算机系统概述.html-59071d02.js" as="script"><link rel="prefetch" href="/408doc/assets/第七章 输入输出系统.html-dd6213e7.js" as="script"><link rel="prefetch" href="/408doc/assets/第三章 存储系统.html-068df467.js" as="script"><link rel="prefetch" href="/408doc/assets/第二章 数据的表示和运算.html-6a6a036b.js" as="script"><link rel="prefetch" href="/408doc/assets/第五章 中央处理器.html-519de68a.js" as="script"><link rel="prefetch" href="/408doc/assets/第六章 总线.html-1ae65a92.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-31a2b6a7.js" as="script"><link rel="prefetch" href="/408doc/assets/第一章 绪论.html-0eb2758c.js" as="script"><link rel="prefetch" href="/408doc/assets/第七章 查找.html-2479c6d5.js" as="script"><link rel="prefetch" href="/408doc/assets/第三章 栈、队列和数组.html-920aa592.js" as="script"><link rel="prefetch" href="/408doc/assets/第二章 线性表.html-b37f08c1.js" as="script"><link rel="prefetch" href="/408doc/assets/第五章 树与二叉树.html-2b301d3b.js" as="script"><link rel="prefetch" href="/408doc/assets/第八章 排序.html-4a546af4.js" as="script"><link rel="prefetch" href="/408doc/assets/第六章 图.html-85928e48.js" as="script"><link rel="prefetch" href="/408doc/assets/第四章 串.html-894731bf.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-7c74131d.js" as="script"><link rel="prefetch" href="/408doc/assets/第一章 操作系统的基本概念.html-68157801.js" as="script"><link rel="prefetch" href="/408doc/assets/第三章 内存管理.html-588e1a30.js" as="script"><link rel="prefetch" href="/408doc/assets/第二章 进程管理.html-3c8f8367.js" as="script"><link rel="prefetch" href="/408doc/assets/第五章 输入输出管理.html-84ce04f1.js" as="script"><link rel="prefetch" href="/408doc/assets/第四章 文件管理.html-8e874daa.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary.html-5405b8b5.js" as="script"><link rel="prefetch" href="/408doc/assets/1-physical-layer.html-0fa046fa.js" as="script"><link rel="prefetch" href="/408doc/assets/2-data-link-layer.html-5e32d4f3.js" as="script"><link rel="prefetch" href="/408doc/assets/3-network-layer.html-16e1c681.js" as="script"><link rel="prefetch" href="/408doc/assets/4-transport-layer.html-d654636d.js" as="script"><link rel="prefetch" href="/408doc/assets/5-application-layer.html-b6913b35.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-c815c58d.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary.html-ff368639.js" as="script"><link rel="prefetch" href="/408doc/assets/1-data-representation-and-operation.html-4d9d1d2a.js" as="script"><link rel="prefetch" href="/408doc/assets/2-storage-system.html-c08dce2f.js" as="script"><link rel="prefetch" href="/408doc/assets/3-instruction-system.html-3e6c6c5d.js" as="script"><link rel="prefetch" href="/408doc/assets/4-central-processing-unit.html-5df2a4ba.js" as="script"><link rel="prefetch" href="/408doc/assets/5-bus.html-7afaedf0.js" as="script"><link rel="prefetch" href="/408doc/assets/6-input-output-system.html-0370933e.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-a596ffbf.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary.html-5b270773.js" as="script"><link rel="prefetch" href="/408doc/assets/1-linear-list.html-7e7714bb.js" as="script"><link rel="prefetch" href="/408doc/assets/2-stack.html-032066f1.js" as="script"><link rel="prefetch" href="/408doc/assets/5-string.html-f55d8c54.js" as="script"><link rel="prefetch" href="/408doc/assets/6-tree.html-a5c94adf.js" as="script"><link rel="prefetch" href="/408doc/assets/7-graph.html-0873bc9a.js" as="script"><link rel="prefetch" href="/408doc/assets/8-search.html-86e3635b.js" as="script"><link rel="prefetch" href="/408doc/assets/9-sort.html-d04dd96a.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-38be5f21.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary.html-73f847d6.js" as="script"><link rel="prefetch" href="/408doc/assets/1-process-management.html-e6110b82.js" as="script"><link rel="prefetch" href="/408doc/assets/2-memory-management.html-43911ea5.js" as="script"><link rel="prefetch" href="/408doc/assets/3-file-management.html-7c223ca0.js" as="script"><link rel="prefetch" href="/408doc/assets/4-device-management.html-5b67e4d3.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-db07ad7b.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary-ex.html-cb5b666b.js" as="script"><link rel="prefetch" href="/408doc/assets/1-physical-layer-ex.html-6f95bd58.js" as="script"><link rel="prefetch" href="/408doc/assets/2-data-link-layer-ex.html-15b6fc83.js" as="script"><link rel="prefetch" href="/408doc/assets/3-network-layer-ex.html-99baa5a8.js" as="script"><link rel="prefetch" href="/408doc/assets/4-transport-layer-ex.html-db4557fd.js" as="script"><link rel="prefetch" href="/408doc/assets/5-application-layer-ex.html-90d13f07.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-0e09b7c7.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary-ex.html-e0af4f2f.js" as="script"><link rel="prefetch" href="/408doc/assets/1-data-representation-and-operation-ex.html-55ad602c.js" as="script"><link rel="prefetch" href="/408doc/assets/2-storage-system-ex.html-025896de.js" as="script"><link rel="prefetch" href="/408doc/assets/3-instruction-system-ex.html-338f7920.js" as="script"><link rel="prefetch" href="/408doc/assets/4-central-processing-unit-ex.html-f6ee53b9.js" as="script"><link rel="prefetch" href="/408doc/assets/5-bus-ex.html-0e4b01e4.js" as="script"><link rel="prefetch" href="/408doc/assets/6-input-output-system-ex.html-5ba82ffc.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-788901e7.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary-ex.html-c277cc80.js" as="script"><link rel="prefetch" href="/408doc/assets/1-linear-list-ex.html-9b7e1a80.js" as="script"><link rel="prefetch" href="/408doc/assets/2-stack-ex.html-c448943d.js" as="script"><link rel="prefetch" href="/408doc/assets/5-string-ex.html-996b9027.js" as="script"><link rel="prefetch" href="/408doc/assets/6-tree-ex.html-2666bbc4.js" as="script"><link rel="prefetch" href="/408doc/assets/7-graph-ex.html-fc00e9f8.js" as="script"><link rel="prefetch" href="/408doc/assets/8-search-ex.html-8b677bbe.js" as="script"><link rel="prefetch" href="/408doc/assets/9-sort-ex.html-0934885e.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-45ee4db8.js" as="script"><link rel="prefetch" href="/408doc/assets/0-summary-ex.html-a37a1d0d.js" as="script"><link rel="prefetch" href="/408doc/assets/1-process-management-ex.html-e76c8a07.js" as="script"><link rel="prefetch" href="/408doc/assets/2-memory-management-ex.html-083dd2e5.js" as="script"><link rel="prefetch" href="/408doc/assets/3-file-management-ex.html-8bf26420.js" as="script"><link rel="prefetch" href="/408doc/assets/4-device-management-ex.html-f20bd72a.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-56a3c197.js" as="script"><link rel="prefetch" href="/408doc/assets/404.html-1a44dc41.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-b9f6aff9.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-4c532139.js" as="script"><link rel="prefetch" href="/408doc/assets/index.html-4756c1f7.js" as="script"><link rel="prefetch" href="/408doc/assets/auto-ba5ecab5.js" as="script"><link rel="prefetch" href="/408doc/assets/index-b03bef79.js" as="script"><link rel="prefetch" href="/408doc/assets/flowchart-35969cab.js" as="script"><link rel="prefetch" href="/408doc/assets/mermaid.core-58405462.js" as="script"><link rel="prefetch" href="/408doc/assets/highlight.esm-75b11b9d.js" as="script"><link rel="prefetch" href="/408doc/assets/markdown.esm-0191f9da.js" as="script"><link rel="prefetch" href="/408doc/assets/math.esm-70a288c8.js" as="script"><link rel="prefetch" href="/408doc/assets/notes.esm-a106bb2c.js" as="script"><link rel="prefetch" href="/408doc/assets/reveal.esm-ab04f0b1.js" as="script"><link rel="prefetch" href="/408doc/assets/search.esm-7e6792e2.js" as="script"><link rel="prefetch" href="/408doc/assets/zoom.esm-b83b91d0.js" as="script"><link rel="prefetch" href="/408doc/assets/VuePlayground-e1d66f05.js" as="script"><link rel="prefetch" href="/408doc/assets/photoswipe.esm-36cd6c3c.js" as="script"><link rel="prefetch" href="/408doc/assets/SearchResult-9596b955.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button type="button" class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a href="/408doc/" class="brand"><!----><!----><span class="site-name">研小布「考研资料站」</span></a><!--]--><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><!--[--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/408doc/" class="nav-link" aria-label="首页"><span class="font-icon icon iconfont icon-home" style=""></span>首页<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="笔记"><span class="title"><span class="font-icon icon iconfont icon-creative" style=""></span>笔记</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/408doc/408notes/DS/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA.html" class="nav-link" aria-label="408笔记【常规版】"><span class="font-icon icon iconfont icon-note" style=""></span>408笔记【常规版】<!----></a></li><li class="dropdown-item"><a href="/408doc/408notesPlus/Data-Structrue/0-summary.html" class="nav-link" aria-label="408笔记【详细版】"><span class="font-icon icon iconfont icon-note" style=""></span>408笔记【详细版】<!----></a></li><li class="dropdown-item"><a href="/408doc/ex/Data-Structrue/0-summary-ex.html" class="nav-link" aria-label="408重要例题及解析"><span class="font-icon icon iconfont icon-note" style=""></span>408重要例题及解析<!----></a></li><li class="dropdown-item"><a href="/408doc/408comeon/408comeon.html" class="nav-link" aria-label="408冲刺背诵手册"><span class="font-icon icon iconfont icon-note" style=""></span>408冲刺背诵手册<!----></a></li><li class="dropdown-item"><a href="/408doc/ASM/assembler.html" class="nav-link" aria-label="汇编语言笔记"><span class="font-icon icon iconfont icon-note" style=""></span>汇编语言笔记<!----></a></li><li class="dropdown-item"><a href="/408doc/cnotes/Cbase.html" class="nav-link" aria-label="C语言笔记"><span class="font-icon icon iconfont icon-note" style=""></span>C语言笔记<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/408doc/download/" class="nav-link" aria-label="下载资料"><span class="font-icon icon iconfont icon-discover" style=""></span>下载资料<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!--[--><!----><!----><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><button type="button" class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="placeholder">搜索</div><div class="key-hints"><kbd class="key">Ctrl</kbd><kbd class="key">K</kbd></div></button><!--]--><!--]--><!--[--><!----><!--]--><button type="button" class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/408doc/" class="nav-link sidebar-link sidebar-page" aria-label="研小布"><span class="font-icon icon iconfont icon-home" style=""></span>研小布<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><section class="sidebar-group"><p class="sidebar-heading clickable active"><span class="font-icon icon iconfont icon-note" style=""></span><a href="/408doc/408notes/" class="nav-link active title" aria-label="408笔记【常规版】"><!---->408笔记【常规版】<!----></a><!----></p><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><!----><span class="title">01-数据结构</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active" type="button"><!----><span class="title">02-计算机组成原理</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/408doc/408notes/CO/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.html" class="nav-link sidebar-link sidebar-page" aria-label="第一章 计算机系统概述"><!---->第一章 计算机系统概述<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/408doc/408notes/CO/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97.html" class="nav-link sidebar-link sidebar-page" aria-label="第二章 数据的表示和运算"><!---->第二章 数据的表示和运算<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/408doc/408notes/CO/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.html" class="nav-link sidebar-link sidebar-page" aria-label="第三章 存储系统"><!---->第三章 存储系统<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第四章 指令系统"><!---->第四章 指令系统<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#指令格式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="指令格式"><!---->指令格式<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#指令的基本格式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="指令的基本格式"><!---->指令的基本格式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#定长操作码指令格式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="定长操作码指令格式"><!---->定长操作码指令格式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#扩展操作码指令格式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="扩展操作码指令格式"><!---->扩展操作码指令格式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#指令的操作类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="指令的操作类型"><!---->指令的操作类型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#综合应用题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="综合应用题"><!---->综合应用题<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#指令的寻址方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="指令的寻址方式"><!---->指令的寻址方式<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#指令寻址和数据寻址" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="指令寻址和数据寻址"><!---->指令寻址和数据寻址<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#常见的数据寻址方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="常见的数据寻址方式"><!---->常见的数据寻址方式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#x86-汇编指令入门" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="X86 汇编指令入门"><!---->X86 汇编指令入门<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#cisc-和-risc-的基本概念" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="CISC 和 RISC 的基本概念"><!---->CISC 和 RISC 的基本概念<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#复杂指令系统计算机-cisc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="复杂指令系统计算机（CISC）"><!---->复杂指令系统计算机（CISC）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#精简指令系统计算机-risc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="精简指令系统计算机（RISC）"><!---->精简指令系统计算机（RISC）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#cisc-和-risc-的比较" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="CISC 和 RISC 的比较"><!---->CISC 和 RISC 的比较<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#常见问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="常见问题"><!---->常见问题<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/408doc/408notes/CO/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8.html" class="nav-link sidebar-link sidebar-page" aria-label="第五章 中央处理器"><!---->第五章 中央处理器<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/408doc/408notes/CO/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%80%BB%E7%BA%BF.html" class="nav-link sidebar-link sidebar-page" aria-label="第六章 总线"><!---->第六章 总线<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/408doc/408notes/CO/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F.html" class="nav-link sidebar-link sidebar-page" aria-label="第七章 输入输出系统"><!---->第七章 输入输出系统<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><!----><span class="title">03-操作系统</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><!----><span class="title">04-计算机网络</span><span class="arrow end"></span></button><!----></section></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第四章 指令系统</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://ky-doc.github.io/mydoc/" target="_blank" rel="noopener noreferrer">研小布</a></span><span property="author" content="研小布"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-04-23T10:21:12.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 27 分钟</span><meta property="timeRequired" content="PT27M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#指令格式" class="router-link-active router-link-exact-active toc-link level2">指令格式</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#指令的基本格式" class="router-link-active router-link-exact-active toc-link level3">指令的基本格式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#定长操作码指令格式" class="router-link-active router-link-exact-active toc-link level3">定长操作码指令格式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#扩展操作码指令格式" class="router-link-active router-link-exact-active toc-link level3">扩展操作码指令格式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#指令的操作类型" class="router-link-active router-link-exact-active toc-link level3">指令的操作类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#综合应用题" class="router-link-active router-link-exact-active toc-link level3">综合应用题</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#指令的寻址方式" class="router-link-active router-link-exact-active toc-link level2">指令的寻址方式</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#指令寻址和数据寻址" class="router-link-active router-link-exact-active toc-link level3">指令寻址和数据寻址</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#常见的数据寻址方式" class="router-link-active router-link-exact-active toc-link level3">常见的数据寻址方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#x86-汇编指令入门" class="router-link-active router-link-exact-active toc-link level3">X86 汇编指令入门</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#cisc-和-risc-的基本概念" class="router-link-active router-link-exact-active toc-link level2">CISC 和 RISC 的基本概念</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#复杂指令系统计算机-cisc" class="router-link-active router-link-exact-active toc-link level3">复杂指令系统计算机（CISC）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#精简指令系统计算机-risc" class="router-link-active router-link-exact-active toc-link level3">精简指令系统计算机（RISC）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#cisc-和-risc-的比较" class="router-link-active router-link-exact-active toc-link level3">CISC 和 RISC 的比较</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408doc/408notes/CO/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html#常见问题" class="router-link-active router-link-exact-active toc-link level2">常见问题</a></li><!----><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><h2 id="指令格式" tabindex="-1"><a class="header-anchor" href="#指令格式" aria-hidden="true">#</a> 指令格式</h2><p>指令（机器指令）是指示计算机执行某种操作的命令</p><p>一台计算机的<strong>所有指令的集合</strong>构成该机的<strong>指令系统</strong>，也称指令集</p><p>指令系统是计算机的主要属性，位于<strong>硬件和软件的交界面上</strong></p><h3 id="指令的基本格式" tabindex="-1"><a class="header-anchor" href="#指令的基本格式" aria-hidden="true">#</a> 指令的基本格式</h3><p>一条指令就是机器语言的一个语句，一条指令通常包括<strong>操作码字段</strong> + <strong>地址码字段</strong>：</p><ul><li><p>操作码：该指令应<strong>该执行什么性质的操作</strong>以及具有何种功能</p><p>操作码是<strong>识别指令、了解指令功能</strong>及<strong>区分操作数地址</strong>内容的组成和使用方法等的关键信息</p></li><li><p>地址码：给出<strong>被操作的信息（指令或数据）的地址</strong>，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址等</p></li></ul><p>关于指令的长度有：</p><ul><li>指令的长度是指一条指令中所包含的<strong>二进制代码的位数</strong></li><li>指令字长取决于<strong>操作码的长度、操作数地址码的长度、操作数地址的个数</strong></li><li>指令长度与机器字长<strong>没有固定的关系</strong>，它可以等于机器字长，也可以大于或小于机器字长</li><li>指令长度等于机器字长的指令称为单字长指令，指令长度等于半个机器字长的指令称为半字长指令，指令长度等于两个机器字长的指令称为双字长指令</li></ul><p>若所有<strong>指令的长度都是相等的</strong>，则称为<strong>定长指令字结构</strong>，定字长指令的执行速度快，控制简单</p><p>若各种<strong>指令的长度随指令功能而异</strong>，则称为<strong>变长指令字结构</strong></p><p>因为主存一般是按字节编址的，所以<strong>指令字长多为字节的整数倍</strong></p><h4 id="零地址指令" tabindex="-1"><a class="header-anchor" href="#零地址指令" aria-hidden="true">#</a> 零地址指令</h4><p><strong>只给出操作码 OP</strong>，没有显式地址，这种指令有两种可能：</p><ol><li><strong>不需要操作数的指令</strong>，如空操作指令、停机指令、关中断指令等</li><li><strong>零地址运算类指令</strong>仅用在<strong>堆栈计算机</strong>中，<strong>操作数隐含地从栈弹出</strong>，运算完再<strong>隐含地压入堆栈</strong></li></ol><h4 id="一地址指令" tabindex="-1"><a class="header-anchor" href="#一地址指令" aria-hidden="true">#</a> 一地址指令</h4><p>有操作码 OP + 一个操作数地址，同样有两种可能：</p><ol><li><p>只有<strong>目的操作数</strong>的单操作数指令：</p><p>按 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 地址读取操作数，进行 OP 操作后，结果存回原地址</p><p>指令含义：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>P</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">OP(A_1)→A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">OP</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，如操作码含义是加 1、减 1、求反、求补等</p></li><li><p><strong>隐含约定目的地址</strong>的双操作数指令：</p><p>按指令地址 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 可读取源操作数，<strong>另一个操作数由累加器 ACC 提供</strong>，运算<strong>结果存放在 ACC 中</strong></p><p>指令含义：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mi>C</mi><mi>C</mi><mo stretchy="false">)</mo><mi>O</mi><mi>P</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>→</mo><mi>A</mi><mi>C</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">(ACC)OP(A_1)→ACC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">CC</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">OP</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">CC</span></span></span></span>，若指令字长为 32 位，操作码占 8 位，则 1 个地址码字段占 24 位，寻址 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup></mrow><annotation encoding="application/x-tex">2^{24}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">24</span></span></span></span></span></span></span></span></span></span></span></span></p></li></ol><h4 id="二地址指令" tabindex="-1"><a class="header-anchor" href="#二地址指令" aria-hidden="true">#</a> 二地址指令</h4><p>有操作码 OP + 两个操作数地址</p><p>指令含义：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mi>O</mi><mi>P</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">(A_1)OP(A_2)→A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">OP</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，给出<strong>目的操作数</strong>和<strong>源操作数</strong>的地址，其中<strong>目的操作数地址</strong>用于<strong>保存运算结果</strong></p><p>若指令字长为 32 位，操作码占 8 位，两个地址码字段各占 12 位，寻址 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span></p><h4 id="三地址指令" tabindex="-1"><a class="header-anchor" href="#三地址指令" aria-hidden="true">#</a> 三地址指令</h4><p>有操作码 OP + 三个操作数地址</p><p>指令含义：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mi>O</mi><mi>P</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>A</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">(A_1)OP(A_2)→A_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">OP</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<strong>第三个操作数地址</strong>用于<strong>保存运算结果</strong></p><p>若指令字长为 32 位，操作码占 8 位，3 个地址码字段各占 8 位，寻址 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">2^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></p><p>若地址字段均为主存地址，则完成一条三地址需要 4 次访问存储器，取指 1、取数 2、放结果 1</p><h4 id="四地址指令" tabindex="-1"><a class="header-anchor" href="#四地址指令" aria-hidden="true">#</a> 四地址指令</h4><p>指令含义：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mi>O</mi><mi>P</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>A</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>4</mn></msub><mo>=</mo><mtext>下一条将要执行指令的地址</mtext></mrow><annotation encoding="application/x-tex">(A_1)OP(A_2)→A_3,A_4=下一条将要执行指令的地址</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">OP</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">下一条将要执行指令的地址</span></span></span></span></p><p>若指令字长为 32 位，操作码占 8 位，4 个地址码字段各占 6 位，寻址 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">2^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></p><h3 id="定长操作码指令格式" tabindex="-1"><a class="header-anchor" href="#定长操作码指令格式" aria-hidden="true">#</a> 定长操作码指令格式</h3><p>定长操作码指令在指令字的最高位部分分配**<u>固定</u>的若干位（定长）表示操作码**</p><p>一般 n 位操作码字段的指令系统最大<strong>能够表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 条指令</strong></p><p>定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利</p><p>当计算机字长为 32 位或更长时，这是常规用法</p><h3 id="扩展操作码指令格式" tabindex="-1"><a class="header-anchor" href="#扩展操作码指令格式" aria-hidden="true">#</a> 扩展操作码指令格式</h3><p>为了在指令字长有限的前提下仍<strong>保持比较丰富的指令种类</strong>，可采取可变长度操作码，即<strong>操作码字段的位数不固定</strong>，且分散地放在指令字的不同位置上，这将增加指令译码和分析的难度，使控制器的设计复杂化</p><p>最常见的变长操作码方法是<strong>扩展操作码</strong>，它使操作码的<strong>长度随地址码的减少而增加</strong>，从而在满足需要的前提下，<strong>有效地缩短指令字长</strong></p><figure><img src="/408doc/408noteImg/images/image-20211017202900865.png" alt="image-20211017202900865" tabindex="0" loading="lazy"><figcaption>image-20211017202900865</figcaption></figure><p>指令字长为 16 位，其中 4 位为操作码 OP，另有 3 个 4 位长的地址，操作码定长则只有 16 条指令</p><p>如果使用扩展操作码：</p><ol><li>三地址指令为 15 条，1111 留作扩展操作码之用</li><li>二地址指令为 15 条，1111 1111 留作扩展操作码之用</li><li>一地址指令为 15 条，11111111 1111 留作扩展操作码之用</li><li>零地址指令为 16 条</li><li>这就<u>从定长指令定长操作的 16 条指令变成定长指令不定长操作的 61 条指令</u></li></ol><p>还有其他多种扩展方法，如 15 条三地址指令、12 条二地址指令、63 条一地址指令和 16 条零地址指令，共 106 条指令</p><p>在设计扩展操作码指令格式时，必须注意以下两点:</p><ol><li><strong>不允许短码是长码的前缀</strong>，即短操作码不能与长操作码的前面部分的代码相同</li><li>各指令的<strong>操作码一定不能重复</strong></li></ol><p>也可以对使用<strong>频率较高的指令分配较短的操作码</strong>，对使用<strong>频率较低的指令分配较长的操作码</strong>，减少指令译码和分析的时间</p><h3 id="指令的操作类型" tabindex="-1"><a class="header-anchor" href="#指令的操作类型" aria-hidden="true">#</a> 指令的操作类型</h3><ol><li><p>数据传送：通常有<strong>寄存器之间的传送</strong>、从<strong>内存单元到 CPU 寄存器</strong>、从 <strong>CPU 寄存器写数据到内存单元</strong>等</p></li><li><p>算术和逻辑运算：主要有加、减、比较、乘、除、加 1、减 1、与、或、取反、异或等</p></li><li><p>移位操作：移位指令主要有<strong>算法移位、逻辑移位、循环移位</strong>等</p></li><li><p>转移操作（程序控制类指令）：</p><p>转移指令主要有<strong>无条件转移、条件转移、调用、返回、陷阱</strong>等</p><ol><li>无条件转移指令：在任何情况下都执行转移操作</li><li>而条件转移指令：在特定条件满足时才执行转移，转移条件一般是某个标志位的值，或两个或两个以上的标志位组合</li><li>调用指令和转移指令的区别：执行调用指令时必须保存下一条指令的地址（返回地址），当子程序执行结束时，根据返回地址返回到主程序继续执行；而转移指令则不返回执行</li></ol></li><li><p>输入输出操作：用于完成 CPU 与<strong>外部设备交换数据</strong>或<strong>传送控制命令及状态信息</strong></p></li></ol><p>选择题：中断隐指令是由硬件实现的，并<strong>不是指令系统中存在的指令</strong>，更不可能属于程序控制类指令</p><p>选择题：特权指令是指<strong>仅用于操作系统或其他系统软件的指令</strong>，为确保系统与数据安全起见，这类指令<strong>不提供给用户使用</strong></p><h3 id="综合应用题" tabindex="-1"><a class="header-anchor" href="#综合应用题" aria-hidden="true">#</a> 综合应用题</h3><p>题目：一处理器中共有 32 个寄存器，使用 16 位立即数，其指令系统结构中共有 142 条指令。<strong>在某个给定的程序中</strong>，20% 的指令带有一个输入寄存器和一个输出寄存器；30% 的指令带有两个输入寄存器和一个输出寄存器；25% 的指令带有一个输入寄存器、一个输出寄存器、一个立即数寄存器；其余 25% 的指令带有一个立即数输入寄存器和一个输出寄存器</p><ol><li>对于以上 4 种指令类型中的任意一种指令类型来说，共需要多少位？指令系统结构要求所有指令长度必须是 8 的整数倍</li><li>与使用定长指令集编码相比，当采用变长指令集编码时，该程序能够少占用多少存储器空间？</li></ol><p>解答：</p><ol><li>因为无法计算不定长操作码，所以这里计算定长操作码，142 条指令需要 7 位（答案写 8 位），32 个寄存器需要 5 位，16 位立即数需要 16 位 <ol><li>一个输入寄存器和一个输出寄存器：7 + 5 + 5 = 17 对齐后为 24</li><li>两个输入寄存器和一个输出寄存器：7 + 5 + 5 + 5 = 22 对齐后为 24</li><li>一个输入寄存器、一个输出寄存器、一个立即数寄存器：7 + 5 + 5 + 16 = 33 对齐后 40</li><li>一个立即数输入寄存器和一个输出寄存器：7 + 16 + 5 = 28 对齐后 32</li></ol></li><li>由于最长是 40 位，所以定长要使用 40 位；变长时 20% × 24 + 30% × 24 + 25% × 40 + 25% × 32 = 30 少用了 25% 的空间</li></ol><h2 id="指令的寻址方式" tabindex="-1"><a class="header-anchor" href="#指令的寻址方式" aria-hidden="true">#</a> 指令的寻址方式</h2><h3 id="指令寻址和数据寻址" tabindex="-1"><a class="header-anchor" href="#指令寻址和数据寻址" aria-hidden="true">#</a> 指令寻址和数据寻址</h3><p>寻址方式是指<strong>寻找指令或操作数有效地址的方式</strong>，即确定本条指令的数据地址及下一条待执行指令的地址的方法</p><p>指令中的地址码字段并不代表操作数的真实地址，这种地址称为形式地址（A），可以是<strong>寄存器编号</strong>或者<strong>内存地址</strong></p><p>形式地址结合寻址方式，可以计算出<strong>操作数在存储器中的真实地址</strong>，这种地址称为<strong>有效地址</strong>（EA）</p><p>寻址方式分为<strong>指令寻址</strong>和<strong>数据寻址</strong>两大类：寻找下一条将要执行的指令地址称为指令寻址；寻找操作数的地址称为数据寻址</p><h4 id="指令寻址" tabindex="-1"><a class="header-anchor" href="#指令寻址" aria-hidden="true">#</a> 指令寻址</h4><p>指令寻址方式有两种：一种是<strong>顺序寻址方式</strong>，另一种是<strong>跳跃寻址方式</strong></p><ol><li><p>顺序寻址：通过程序计数器（PC）加 1 个指令字长，<strong>自动形成下一条指令的地址</strong></p></li><li><p>跳跃寻址通过转移类指令实现：</p><p>所谓跳跃，是指下条指令的地址码不由程序计数器给出，而<strong>由本条指令计算出下条指令地址</strong></p><p>注意：状态寄存器和操作数的控制是否跳跃，而跳跃到的地址分为绝对地址和相对地址，跳跃的结果是当前指令修改 PC 值，所以下一条指令仍然通过程序计数器给出</p></li></ol><h4 id="数据寻址" tabindex="-1"><a class="header-anchor" href="#数据寻址" aria-hidden="true">#</a> 数据寻址</h4><p>数据寻址是指<strong>如何在指令中表示一个操作数的地址</strong>，如何用这种表示得到操作数或<strong>怎样计算出操作数的地址</strong></p><p>数据寻址的方式较多，通常在指令字中<strong>设一个字段来指明属于哪种寻址方式</strong>，由此可得指令的格式如下所示：</p><figure><img src="/408doc/408noteImg/images/image-20211018161851931.png" alt="image-20211018161851931" tabindex="0" loading="lazy"><figcaption>image-20211018161851931</figcaption></figure><p>选择题：采用不同寻址方式的目的是<u>缩短指令字长，扩大寻址空间，提高编程的灵活性</u>，但也<u>提高了指令译码的复杂度</u></p><h3 id="常见的数据寻址方式" tabindex="-1"><a class="header-anchor" href="#常见的数据寻址方式" aria-hidden="true">#</a> 常见的数据寻址方式</h3><h4 id="隐含寻址" tabindex="-1"><a class="header-anchor" href="#隐含寻址" aria-hidden="true">#</a> 隐含寻址</h4><p>这种类型的指令不明显地给出操作数的地址，而在指令中隐含操作数的地址</p><figure><img src="/408doc/408noteImg/images/image-20211018162301445.png" alt="image-20211018162301445" tabindex="0" loading="lazy"><figcaption>image-20211018162301445</figcaption></figure><p>例如，规定累加器（ACC）作为第二操作数地址，，累加器（ACC）对单地址指令格式来说是隐含寻址</p><p>隐含寻址的优点是有利于<strong>缩短指令字长</strong>；缺点是<strong>需增加存储操作数或隐含地址的硬件</strong></p><h4 id="立即-数-寻址" tabindex="-1"><a class="header-anchor" href="#立即-数-寻址" aria-hidden="true">#</a> 立即（数）寻址</h4><p>这种类型的指令的地址字段指出的是<strong>操作数本身</strong>，又称立即数，数据采用<strong>补码形式存放</strong></p><figure><img src="/408doc/408noteImg/images/image-20211018163109172.png" alt="image-20211018163109172" tabindex="0" loading="lazy"><figcaption>image-20211018163109172</figcaption></figure><p>立即寻址的优点是指令在<strong>执行阶段不访问主存</strong>，指令执行时间最短；缺点是 <strong>A 的位数限制了立即数的范围</strong></p><p>注意：在定长指令字时，立即数取址执行速度最快；但在变长指令字时，寄存器寻址执行速度最快，因为读代码也要时间</p><h4 id="直接寻址" tabindex="-1"><a class="header-anchor" href="#直接寻址" aria-hidden="true">#</a> 直接寻址</h4><p>指令字中的形式地址 A 是操作数的真实地址 EA，即 <strong>EA = A</strong></p><figure><img src="/408doc/408noteImg/images/image-20211018163554498.png" alt="image-20211018163554498" tabindex="0" loading="lazy"><figcaption>image-20211018163554498</figcaption></figure><p>直接寻址的优点是简单，指令在执行阶段仅访问一次主存，<strong>不需要专门计算操作数的地址</strong>；缺点是 <strong>A 的位数决定了该指令操作数的寻址范围</strong>，操作数的地址不易修改</p><h4 id="间接寻址" tabindex="-1"><a class="header-anchor" href="#间接寻址" aria-hidden="true">#</a> 间接寻址</h4><p>间接寻址是指，指令的地址字段给出的形式地址是<strong>操作数有效地址所在的存储单元的地址</strong>，即 <strong>EA =(A)</strong></p><p>间接寻址可以是一次间接寻址，还可以是多次间接寻址</p><figure><img src="/408doc/408noteImg/images/image-20211018163908663.png" alt="image-20211018163908663" tabindex="0" loading="lazy"><figcaption>image-20211018163908663</figcaption></figure><p>主存字第一位为 1 时，表示取出的仍不是操作数的地址，即多次间址；主存字第一位为 0 时，表示取得的是操作数的地址</p><p>优点：可<strong>扩大寻址范围</strong>（有效地址 EA 的位数大于形式地址 A 的位数），便于<strong>编制程序</strong>（方便地完成子程序返回）</p><p>缺点：指令在执行阶段要<strong>多次访存</strong>，由于访问速度过慢，这种寻址方式并不常用</p><p>注意：一般问到<strong>扩大寻址范围</strong>时，通常指的是<strong>寄存器间接寻址</strong></p><h4 id="寄存器寻址" tabindex="-1"><a class="header-anchor" href="#寄存器寻址" aria-hidden="true">#</a> 寄存器寻址</h4><p>寄存器寻址是指在指令字中直接<strong>给出操作数所在的寄存器编号</strong>，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>A</mi><mo>=</mo><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">EA=R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其操作数在由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 所指的寄存器内</p><figure><img src="/408doc/408noteImg/images/image-20211018164727093.png" alt="image-20211018164727093" tabindex="0" loading="lazy"><figcaption>image-20211018164727093</figcaption></figure><p>优点：指令在执行阶段不访问主存，只访问寄存器，<strong>指令字短且执行速度快</strong>，支持向量 / 矩阵运算</p><p>缺点：寄存器价格昂贵，计算机中的<strong>寄存器个数有限</strong></p><h4 id="寄存器间接寻址" tabindex="-1"><a class="header-anchor" href="#寄存器间接寻址" aria-hidden="true">#</a> 寄存器间接寻址</h4><p>寄存器间接寻址是指在寄存器 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中给出的是<strong>操作数所在主存单元的地址</strong>，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>R</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">EA= (R_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><figure><img src="/408doc/408noteImg/images/image-20211018165205933.png" alt="image-20211018165205933" tabindex="0" loading="lazy"><figcaption>image-20211018165205933</figcaption></figure><p>寄存器间接寻址的特点：比一般间接寻址<strong>速度更快</strong>，但指令的执行阶段需要访问主存</p><h4 id="相对寻址" tabindex="-1"><a class="header-anchor" href="#相对寻址" aria-hidden="true">#</a> 相对寻址</h4><p>相对寻址是把程序计数器 PC 的内容加上形式地址 A 而形成操作数的有效地址，即 <strong>EA = (PC) + A</strong>，其中 <strong>A 是相对于当前指令地址的位移量</strong>，可正可负，补码表示</p><figure><img src="/408doc/408noteImg/images/image-20211018165506048.png" alt="image-20211018165506048" tabindex="0" loading="lazy"><figcaption>image-20211018165506048</figcaption></figure><p>操作数的地址<strong>随 PC 值的变化而变化</strong>，且与指令地址之间总是相差一个固定值，因此<strong>便于程序浮动</strong>，广泛应用于<strong>转移指令</strong></p><p>注意：<strong>读完指令后 PC 会增加</strong>，转移时<strong>根据增加后的 PC 来转移</strong>，如 <code>JMP A</code> 指令地址为 X 长度 <code>2B</code>，则会跳到 X + 2 + A 处</p><p>选择题：在多道程序设计中，各个程序段被加载的内存是浮动的，当程序的存放区域被改变，要求其执行不受影响，使用相对地址可以实现</p><h4 id="基址寻址" tabindex="-1"><a class="header-anchor" href="#基址寻址" aria-hidden="true">#</a> 基址寻址</h4><p>基址寻址是指将 CPU 中基址寄存器（BR）的内容加上形式地址 A 而形成操作数的有效地址，即 <strong>EA=(BR)+ A</strong></p><p>其中基址寄存器既<strong>可采用专用寄存器</strong>，又<strong>可采用通用寄存器</strong></p><figure><img src="/408doc/408noteImg/images/image-20211018182504834.png" alt="image-20211018182504834" tabindex="0" loading="lazy"><figcaption>image-20211018182504834</figcaption></figure><p>基址寄存器是面向操作系统的，<strong>内容由操作系统或管理程序确定</strong>，用于解决程序逻辑空间与存储器物理空间的无关性</p><p>在程序执行过程中，<strong>基址寄存器的内容不变</strong>（作为基地址），<strong>形式地址可变</strong>（作为偏移量）</p><p>采用通用寄存器作为基址寄存器时，可<strong>由用户决定哪个寄存器作为基址寄存器</strong>，但其<strong>内容仍由操作系统确定</strong></p><p>优点：可<strong>扩大寻址范围</strong>；用户不必考虑自己的程序存于主存的哪个空间区域，因此<strong>有利于多道程序设计</strong>，并可用于<strong>编制浮动程序</strong>，但偏移量（形式地址 A）的位数较短</p><p>思考：基址就是一个程序的基地址，程序内的每个数据都是根据基地址来寻址的，当程序装入不同内存变了改一下基址就行</p><h4 id="变址寻址" tabindex="-1"><a class="header-anchor" href="#变址寻址" aria-hidden="true">#</a> 变址寻址</h4><p>变址寻址是指有效地址 EA 等于<strong>形式地址 A 与变址寄存器 IX 的内容之和</strong>，即 <strong>EA = (IX) + A</strong>，其中 IX 为变址寄存器（专用），也可用通用寄存器作为变址寄存器</p><figure><img src="/408doc/408noteImg/images/image-20211018183938571.png" alt="image-20211018183938571" tabindex="0" loading="lazy"><figcaption>image-20211018183938571</figcaption></figure><p>变址寄存器是<strong>面向用户</strong>的，变址寄存器的内容可由用户改变，<strong>形式地址 A 不变</strong>，偏移量的位数足以表示整个存储空间</p><p>优点：可<strong>扩大寻址范围</strong>；可令 A 为数组的首地址，变址寄存器 IX 为数组的索引；特别适合编制循环程序</p><p>基址寻址<strong>面向系统</strong>，主要用于<strong>为多道程序或数据分配存储空间</strong>，内容通常由操作系统或管理程序确定，<strong>其值不可变</strong>，指令字中的 A 是可变的</p><p>变址寻址<strong>立足于用户</strong>，主要用于处理<strong>数组问题</strong>，变址寄存器的内容由用户设定，<strong>其值可变</strong>，而指令字中的 A 是不可变的</p><h4 id="堆栈寻址" tabindex="-1"><a class="header-anchor" href="#堆栈寻址" aria-hidden="true">#</a> 堆栈寻址</h4><p>堆栈是存储器中一块特定的、<strong>按后进先出原则管理的存储区</strong>，读/写单元的地址用一个特定的寄存器给出称为堆栈指针</p><p>堆栈可分为硬堆栈与软堆栈两种：</p><ol><li><strong>寄存器堆栈</strong>又称硬堆栈，寄存器堆栈的成本较高，不适合做大容量的堆栈</li><li><strong>从主存中划出一段区域</strong>来做堆栈是<strong>最合算且最常用</strong>的方法，这种堆栈称为软堆栈</li></ol><p>堆栈结构的计算机系统中，大部分指令表现为<strong>无操作数指令</strong>，因为其操作数都通过堆栈寄存器<strong>隐含使用了堆栈</strong></p><p>如 <code>ADD</code> 加法指令就是从堆栈中弹出两个操作数，运算完后再把结果压入堆栈</p><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h4><figure><img src="/408doc/408noteImg/images/image-20211018185202626.png" alt="image-20211018185202626" tabindex="0" loading="lazy"><figcaption>image-20211018185202626</figcaption></figure><h3 id="x86-汇编指令入门" tabindex="-1"><a class="header-anchor" href="#x86-汇编指令入门" aria-hidden="true">#</a> X86 汇编指令入门</h3><h4 id="相关寄存器" tabindex="-1"><a class="header-anchor" href="#相关寄存器" aria-hidden="true">#</a> 相关寄存器</h4><p>X86 处理器中有 <strong>8 个 32 位的通用寄存器</strong>，为了向后兼容 <code>EAX、EBX、ECX、EDX</code> 的<strong>高低两位字节可以独立使用</strong>，E 为 Extended 表示 32 位的寄存器，寄存器的<strong>名称与大小写无关</strong>，既可以用 <code>EAX</code>，又可以用 <code>eax</code></p><figure><img src="/408doc/408noteImg/images/image-20211018190206522.png" alt="image-20211018190206522" tabindex="0" loading="lazy"><figcaption>image-20211018190206522</figcaption></figure><p>除 <code>EBP</code> 和 <code>ESP</code> 外（用于堆栈不可乱用），其他几个寄存器的用途是比较任意的</p><h4 id="寻址模式和内存分配" tabindex="-1"><a class="header-anchor" href="#寻址模式和内存分配" aria-hidden="true">#</a> 寻址模式和内存分配</h4><h5 id="寻址模式" tabindex="-1"><a class="header-anchor" href="#寻址模式" aria-hidden="true">#</a> 寻址模式</h5><p>X86 提供了一种灵活的内存寻址方式，如 mov 用于在内存和寄存器之间移动数据，第一个是目的地址，第二个是源地址</p><p>注意：最多只能利用<strong>两个</strong> 32 位寄存器和一个 32 位的有符号常数<strong>相加</strong>计算出一个内存地址</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>mov eax, [ebx]  ;将 ebx 值指示的内存地址中的 4 子节传送到 eax
mov [var], ebx  ;将 ebx 值传送到 var 的值指示的内存地址中
mov eax, [esi - 4]  ;将 esi - 4 值指示的内存地址中的 4 字节传送到 eax
mov [esi + eax], cl  ;将 cl 值传送到 esi + eax 值指示的内存地址中
mov edx, [esi + 4 * ebx]  ;将 esi + 4 * ebx 值指示的内存中的 4 字节传送到 edx

mov eax, [ebx - ecx]  ;错误，只能用加法
mov [eax + esi + edi], ebx  ;错误，最多只能有两个寄存器参与运算
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="数据类型长度规定" tabindex="-1"><a class="header-anchor" href="#数据类型长度规定" aria-hidden="true">#</a> 数据类型长度规定</h5><p>汇编语言中声明内存大小时，一般显式地使用 <code>DB（Data Byte)、DW（Word，2Bytes）、DD（Double Word，4Bytes）</code>分配内存</p><p>为了<strong>区分常数 2 的占位</strong>，X86 提供了三个指示规则标记，分别为 <code>BYTE PTR、WORD PTR、DWORD PTR</code></p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>a:db 0  ;分配单字节内存
b:dw 0  ;分配双字节内存
c:dd 0  ;分配四字节内存

mov byte ptr [ebx], 2  ;将 2 以单字节形式传送到 ebx 值指示的内存地址中
mov word ptr [eb×], 2  ;将 2 以双字节形式传送到 ebx 值指示的内存地址中
mov dword ptr [ebx], 2  ;将 2 以四字节形式传送到 ebx 值指示的内存地址中
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令" aria-hidden="true">#</a> 常用命令</h4><p>汇编指令通常可以分为数据传送指令、逻辑计算指令和控制流指令，以下用于操作数的标记分别表示寄存器、内存和常数</p><ol><li><p>&lt;reg&gt;：表示任意寄存器，若其后带有数字，则指定其位数</p><p>&lt;<code>reg32</code>&gt; 表示 32 位寄存器；&lt;<code>reg16</code>&gt; 表示 16 位寄存器；&lt;<code>reg8</code>&gt; 表示 8 位寄存器</p></li><li><p>&lt;<code>mem</code>&gt;：表示内存地址</p></li><li><p>&lt;con&gt;：表示 8 位、16 位或 32 位常数</p><p>&lt;<code>con8</code>&gt; 表示 8 位常数；&lt;<code>con16</code>&gt; 表示 16 位常数；&lt;<code>con32</code>&gt; 表示 32 位常数</p></li></ol><p>对<strong>同一指令的不同用途有多种编码方式</strong>，比如 mov 指令就有 28 种机内编码，用于不同操作数类型或用于特定寄存器</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>mov ax, &lt;con16&gt;  ;机器码为 B8H
mov al, &lt;con8&gt;  ;机器码为 BOH
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>应用题：可使用<strong>溢出自陷指令</strong>让 CPU 检查溢出标志 OF，如果溢出 OF = 1 就会调用<strong>溢出异常处理程序</strong></p><h5 id="数据传送指令" tabindex="-1"><a class="header-anchor" href="#数据传送指令" aria-hidden="true">#</a> 数据传送指令</h5><ol><li><p>mov 指令：将第二个操作数复制到第一个操作数，但不能用于直接从内存复制到内存</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>mov &lt;reg&gt;, &lt;reg&gt;
mov &lt;reg&gt;, &lt;mem&gt;
mov &lt;mem&gt;, &lt;reg&gt;
mov &lt;reg&gt;, &lt;con&gt;
mov &lt;mem&gt;, &lt;con&gt;

mov eax, ebx
mov byte ptr [var], 5  ;将 5 保存到 var 值指示的内存地址的一字节中
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>push 指令：push 指令将操作数压入内存的栈，ESP 是栈顶，压栈前先将 ESP 值减 4，然后将操作数压入 ESP 指示的地址</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>push &lt;reg32&gt;
push &lt;mem&gt;
push &lt;con32&gt;

push eax
push [var]  ;将 var 值指示的内存地址的 4 字节值压栈
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>pop 指令：pop 指令执行的是出栈工作，出栈前先将 ESP 指示的地址中的内容出栈，然后将 ESP 值加 4</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>pop &lt;reg32&gt;
pop &lt;mem&gt;

pop edi
pop [ebx]  ;弹出栈顶元素送到 ebx 值指示的内存地址的 4 字节中
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h5 id="算术和逻辑运算指令" tabindex="-1"><a class="header-anchor" href="#算术和逻辑运算指令" aria-hidden="true">#</a> 算术和逻辑运算指令</h5><ol><li><p>add/sub 指令：add 指令将两个操作数相加，相加的结果保存到第一个操作数中；sub 指令用于两个操作数相减，相减的结果保存到第一个操作数中</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>add &lt;reg&gt;, &lt;reg&gt; / sub &lt;reg&gt;, &lt;reg&gt;
add &lt;reg&gt;, &lt;mem&gt; / sub &lt;reg&gt;, &lt;mem&gt;
add &lt;mem&gt;, &lt;reg&gt; / sub &lt;mem&gt;, &lt;reg&gt;
add &lt;reg&gt;, &lt;con&gt; / sub &lt;reg&gt;, &lt;con&gt;
add &lt;mem&gt;, &lt;con&gt; / sub &lt;mem&gt;, &lt;con&gt;

sub eax, 10
add byte ptr [var], 10
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>inc/dec 指令：inc、dec 指令分别表示将操作数自加 1、自减 1</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>inc &lt;reg&gt; / dec &lt;reg&gt;
inc &lt;mem&gt; / dec &lt;mem&gt;

dec eax
inc dword ptr [var]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>imul</code> 指令：带符号整数乘法指令，它有两种格式：</p><ol><li>两个操作数：将两个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器</li><li>三个操作数：将第二个和第三个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器</li></ol><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>imul &lt;reg32&gt;, &lt;reg32&gt;
imul &lt;reg32&gt;, &lt;mem&gt;
imul &lt;reg32&gt;, &lt;reg32&gt;, &lt;con&gt;
imul &lt;reg32&gt;, &lt;mem&gt;, &lt;con&gt;

imul eax, [var]  ;eax &lt;- eax * [var]
imul esi, edi, 25  ;esi &lt;- edi * 25
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个 32 位数值相乘，积是 64 位，若其高 33 位不是全为零（正）或全为一（负），就表示溢出，则 OF = 1</p></li><li><p>idiv 指令：带符号整数除法指令，只有一个操作数除数，被除数为 <code>edx:eax</code> 中的内容 64 位，商送到 <code>eax</code>，余数则送到 <code>edx</code></p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>idiv &lt;reg32&gt;
idiv &lt;mem&gt;

idiv ebx
idiv dword ptr [var]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>and/or/xor 指令：分别是逻辑与、逻辑或、逻辑异或指令，用于位操作，操作结里放在第个操作数中</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>and &lt;reg&gt;, &lt;reg&gt; / or &lt;reg&gt;, &lt;reg&gt; / xor &lt;reg&gt;, &lt;reg&gt;
and &lt;reg&gt;, &lt;mem&gt; / or &lt;reg&gt;, &lt;mem&gt; / xor &lt;reg&gt;, &lt;mem&gt;
and &lt;mem&gt;, &lt;reg&gt; / or &lt;mem&gt;, &lt;reg&gt; / xor &lt;mem&gt;, &lt;reg&gt;
and &lt;reg&gt;, &lt;con&gt; / or &lt;reg&gt;, &lt;con&gt; / xor &lt;reg&gt;, &lt;con&gt;
and &lt;mem&gt;, &lt;con&gt; / or &lt;mem&gt;, &lt;con&gt; / xor &lt;mem&gt;, &lt;con&gt;

and eax, 0fH  ;eax &amp;= 0x0f
xor edx, edx  ;置 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>not 指令：位翻转指令，将操作数中的每一位翻转，即 0→1、1→0</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>not &lt;reg&gt;
not &lt;mem&gt;

not byte ptr [var]  ;将 var 值指示的内存地址的一字节的所有位翻转
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>neg 指令：取负指令</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>neg &lt;reg&gt;
neg &lt;men&gt;

neg eax  ;eax &lt;- -eax
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>shl/shr</code> 指令：<code>shl</code> 为逻辑左移，<code>shr</code> 为逻辑右移，第一个操作数表示被操作数，第二个操作数指示移位的位数</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>shl &lt;reg&gt;, &lt;con8&gt; / shr &lt;reg&gt;, &lt;con8&gt;
shl &lt;mem&gt;, &lt;con8&gt; / shr &lt;mem&gt;, &lt;con8&gt;
shl &lt;reg&gt;, &lt;cl&gt; / shr &lt;reg&gt;, &lt;cl&gt;
shl &lt;mem&gt;, &lt;c1&gt; / shr &lt;mem&gt;, &lt;cl&gt;

shl eax, 1
shr ebx, cl
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h5 id="控制流指令" tabindex="-1"><a class="header-anchor" href="#控制流指令" aria-hidden="true">#</a> 控制流指令</h5><p>X86 处理器维持着一个指令指针 IP 它<strong>指向下一条指令的首地址</strong>，当一条指令取出后，此指针自动指向下一条指令</p><p>IP 寄存器不能直接操作，但可以用控制流指令更新，通常用标签指示程序中的指令地址，可在任何指令前加入标签</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>mov esi, [ebp + 8]
begin: xor ecx, ecx  ;标记，用于控制流指令的跳转
mov eax, [esi]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><p><code>jmp</code> 指令：控制 IP 转移到 label 所指示的地址</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>jmp &lt;label&gt;
jmp begin  ;跳转到 begin 标记的指令执行
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>jcondition</code> 指令：条件转移指令，它<strong>依据处理机状态字中的一系列条件状态转移</strong>（状态寄存器）</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>je &lt;label&gt; (jump when equal)
jne &lt;label&gt; (jump when not equal)
jz &lt;label&gt; (jump when last result was zero)
jg &lt;label&gt; (jump when greater than)
jge &lt;label&gt; (jump when greater than or equal to)
jl &lt;label&gt; (jump when less than)
jle &lt;label&gt; (jump when less than or equal to)

cmp eax, ebx
jle done ;如果 eax 的值小于等于 ebx 值，跳转到 done
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>cmp</code> 指令：用于比较两个操作数的值，并根据比较结果设置处理机状态字中的条件码，通常与 <code>jcondition</code> 搭配</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>cmp &lt;reg&gt;, &lt;reg&gt;
cmp &lt;reg&gt;, &lt;mem&gt;
cmp &lt;mem&gt;, &lt;reg&gt;
cmp &lt;reg&gt;, &lt;con&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>call/ret 指令：用于实现子程序（过程、函数等）的调用及返回</p><p>call 指令首先将当前执行指令地址的下一个指令地址入栈，然后无条件转移到由标签指示的指令</p><p>ret 指令实现子程序的返回机制，ret 指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>fun:
mov eax, 0x6021  ;设置返回值
ret  ;返回，跳转到栈定存放的地址

call fun  ;将下面指令的地址入栈，跳转到 fun
mov ebx, eax
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h2 id="cisc-和-risc-的基本概念" tabindex="-1"><a class="header-anchor" href="#cisc-和-risc-的基本概念" aria-hidden="true">#</a> CISC 和 RISC 的基本概念</h2><p>指令系统朝两个截然不同的方向的发展：</p><ol><li>增强原有指令的功能，<strong>设置更为复杂的新指令实现软件功能的硬化</strong>，称为复杂指令系统计算机 CISC，有 X86 架构</li><li><strong>减少指令种类和简化指令功能</strong>，提高指令的执行速度，称为精简指令系统计算机 RISC，有 ARM、MIPS 架构</li></ol><h3 id="复杂指令系统计算机-cisc" tabindex="-1"><a class="header-anchor" href="#复杂指令系统计算机-cisc" aria-hidden="true">#</a> 复杂指令系统计算机（CISC）</h3><p>随着超大规模集成电路（VLSI）技术的发展，硬件成本不断下降，软件成本不断上升，促使人们在指令系统中<strong>增加更多、更复杂的指令</strong>，以适应不同的应用领域（即指令功能尽可能强）</p><p>CISC 的主要特点如下：</p><ol><li><strong>指令系统复杂庞大</strong>，指令数目一般为 200 条以上</li><li><strong>指令的长度不固定，指令格式多，寻址方式多</strong></li><li><strong>可以访存的指令不受限制</strong></li><li>各种<strong>指令使用频度相差很大</strong></li><li>各种<strong>指令执行时间相差很大</strong>，大多数指令需多个时钟周期才能完成</li><li><strong>控制器大多数采用微程序控制</strong>，有些指令非常复杂，以至于无法采用硬连线控制</li><li><strong>难以用优化编译生成高效的目标代码程序</strong></li></ol><p>命令频率相差悬殊 20% 的简单的指令约占整个程序的 80%；而 80% 的指令约占整个程序的 20%，于是 RISC 随之诞生</p><h3 id="精简指令系统计算机-risc" tabindex="-1"><a class="header-anchor" href="#精简指令系统计算机-risc" aria-hidden="true">#</a> 精简指令系统计算机（RISC）</h3><p>中心思想是<u>要求指令系统简化，尽量使用寄存器-寄存器操作指令，指令格式力求一致</u></p><p>RISC 的主要特点如下：</p><ol><li>选取使用<strong>频率最高的一些简单指令</strong>，<u>复杂指令的功能由简单指令的组合来实现</u></li><li><strong>指令长度固定，指令格式种类少，寻址方式种类少</strong></li><li><strong>只有 Load / Store（取数/存数）指令访存</strong>，其余指令的操作都在寄存器之间进行</li><li>CPU 中通用<strong>寄存器的数量相当多</strong></li><li>RISC <strong>一定采用指令流水线技术</strong>，大部分指令在<strong>一个时钟周期内完成</strong></li><li>以<strong>硬布线控制为主</strong>，不用或少用微程序控制</li><li>特别<strong>重视编译优化工作</strong>，以减少程序执行时间</li></ol><p>从指令系统兼容性看，<strong>CISC 大多能实现软件兼容</strong>，即高档机包含了低档机的全部指令，并可加以扩充；而大多数 RISC 机不能与老机器兼容，但 <strong>RISC 具有更强的实用性</strong>，是未来处理器的发展方向</p><p><u>现代 CISC 结构的 CPU 已经融合了很多 RISC 的成分</u>，性能差距已经越来越小，CISC 可以提供更多的功能是程序设计需要的</p><h3 id="cisc-和-risc-的比较" tabindex="-1"><a class="header-anchor" href="#cisc-和-risc-的比较" aria-hidden="true">#</a> CISC 和 RISC 的比较</h3><p>和 CISC 相比，RISC 的优点主要体现在以下几点：</p><ol><li><strong>RISC 更能充分利用芯片的面积</strong>，CISC 的控制存储器占 CPU 芯片面积达 50% 以上，而 RISC 的硬布线逻辑只占 CPU 芯片面积的 10% 左右</li><li>RISC <strong>更能提高运算速度</strong>，指令数、寻址方式和指令格式种类少 + 多个通用寄存器 + 流水线技术</li><li>RISC <strong>便于设计，可降低成本，提高可靠性</strong>，RISC 指令系统简单，因此机器设计周期短；其逻辑简单，因此可靠性高</li><li>RISC <strong>有利于编译程序代码优化</strong>，编译程序容易选择更有效的指令和寻址方式，适当地调整指令顺序，令代码执行更高效化</li></ol><figure><img src="/408doc/408noteImg/images/image-20211019164811802.png" alt="image-20211019164811802" tabindex="0" loading="lazy"><figcaption>image-20211019164811802</figcaption></figure><h2 id="常见问题" tabindex="-1"><a class="header-anchor" href="#常见问题" aria-hidden="true">#</a> 常见问题</h2><ol><li><p>简述各常见指令寻址方式的特点和适用情况</p><p>立即寻址操作数获取便捷，通常用于<strong>给寄存器赋初值</strong></p><p>直接寻址相对于立即寻址，<strong>缩短了指令长度</strong></p><p>间接寻址<strong>扩大了寻址范围</strong>，便于编制程序，易于完成子程序返回</p><p>寄存器间接寻址<strong>扩大了寻址范围</strong>，寄存器寻址的指令字较短，指令执行速度较快</p><p>基址寻址扩大了操作数寻址范围，适用于多道程序设计，常用于<strong>为程序或数据分配存储空间</strong></p><p>变址寻址主要用于<strong>处理数组问题</strong>，适合编制循环程序</p><p>相对寻址用于<strong>控制程序的执行顺序、转移</strong>等</p></li><li><p>装入/存储（Load / Store）型指令有什么特点？</p><p>装入/存储型指令是用在规整型指令系统中的一种通用寄存器型指令风格，在 RISC 指令系统中较为常见</p><p>为了规整指令格式，使指令具有相同的长度，规定<strong>只有 Load / Store 指令才能访问内存</strong></p><p>因为寄存器编号较短，而主存地址位数较长，通过某种方式可使运算指令和访存指令的长度一致</p><p>这种装入/存储型风格的指令系统的最大特点是，<strong>指令格式规整，指令长度一致，一般为 32 位</strong></p><p>与一般通用寄存器型指令风格相比，其<strong>程序长度会更长</strong>，因为会包含许多装入和存储指令</p></li></ol></div><!----><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: doc_408@163.com">408doc</span><!--]--><!--]--></div></div></footer><nav class="page-nav"><a href="/408doc/408notes/CO/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.html" class="nav-link prev" aria-label="第三章 存储系统"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->第三章 存储系统</div></a><a href="/408doc/408notes/CO/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8.html" class="nav-link next" aria-label="第五章 中央处理器"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">第五章 中央处理器<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">微信公众号：研小布</div><div class="copyright">Copyright © 2023 研小布</div></footer></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/408doc/assets/app-5b900c76.js" defer></script>
  </body>
</html>
