<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.61" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://ky-doc.github.io/mydoc/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><meta property="og:site_name" content="研小布「考研资料站」"><meta property="og:title" content="第三章 文件管理"><meta property="og:description" content="内存管理概念 内存管理的基本原理和要求 不可能将全部程序与数据放入主存，因此操作系统必须对内存进行划分和动态分配，这就是内存管理的概念 有效的内存管理可以方便用户使用存储器、提高内存利用率、通过虚拟技术从逻辑上扩充存储器 内存管理的功能有： 内存空间的分配与回收：由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率; 地址转..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-04-23T10:21:12.000Z"><meta property="article:author" content="研小布"><meta property="article:modified_time" content="2023-04-23T10:21:12.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"第三章 文件管理","image":[""],"dateModified":"2023-04-23T10:21:12.000Z","author":[{"@type":"Person","name":"研小布","url":"https://ky-doc.github.io/mydoc/"}]}</script><title>第三章 文件管理 | 研小布「考研资料站」</title><meta name="description" content="内存管理概念 内存管理的基本原理和要求 不可能将全部程序与数据放入主存，因此操作系统必须对内存进行划分和动态分配，这就是内存管理的概念 有效的内存管理可以方便用户使用存储器、提高内存利用率、通过虚拟技术从逻辑上扩充存储器 内存管理的功能有： 内存空间的分配与回收：由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率; 地址转...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-73ae938c.css" as="style"><link rel="stylesheet" href="/assets/style-73ae938c.css">
    <link rel="modulepreload" href="/assets/app-e88d6ffa.js"><link rel="modulepreload" href="/assets/framework-cd5fce69.js"><link rel="modulepreload" href="/assets/第三章 内存管理.html-2559b44c.js"><link rel="modulepreload" href="/assets/第三章 内存管理.html-1417d93e.js"><link rel="prefetch" href="/assets/index.html-2a497601.js" as="script"><link rel="prefetch" href="/assets/slides.html-3c192ee5.js" as="script"><link rel="prefetch" href="/assets/408comeon.html-29c6a49b.js" as="script"><link rel="prefetch" href="/assets/index.html-66455de9.js" as="script"><link rel="prefetch" href="/assets/index.html-ec33a818.js" as="script"><link rel="prefetch" href="/assets/assembler.html-e5b6e533.js" as="script"><link rel="prefetch" href="/assets/Cbase.html-a008496e.js" as="script"><link rel="prefetch" href="/assets/index.html-01239ed6.js" as="script"><link rel="prefetch" href="/assets/disable.html-2001848a.js" as="script"><link rel="prefetch" href="/assets/encrypt.html-c5266dcb.js" as="script"><link rel="prefetch" href="/assets/markdown.html-1e103423.js" as="script"><link rel="prefetch" href="/assets/page.html-806c354a.js" as="script"><link rel="prefetch" href="/assets/index.html-5c12e8ea.js" as="script"><link rel="prefetch" href="/assets/index.html-373022b2.js" as="script"><link rel="prefetch" href="/assets/index.html-70bfc6c6.js" as="script"><link rel="prefetch" href="/assets/第一章 计算机网络体系结构.html-1ec992cf.js" as="script"><link rel="prefetch" href="/assets/第三章 数据链路层.html-a5b01a3d.js" as="script"><link rel="prefetch" href="/assets/第二章 物理层.html-9f54f1f6.js" as="script"><link rel="prefetch" href="/assets/第五章 传输层.html-e2cc2c6b.js" as="script"><link rel="prefetch" href="/assets/第六章 应用层.html-3d54f38d.js" as="script"><link rel="prefetch" href="/assets/第四章 网络层.html-9a995d99.js" as="script"><link rel="prefetch" href="/assets/index.html-9106332e.js" as="script"><link rel="prefetch" href="/assets/第一章 计算机系统概述.html-2066c8aa.js" as="script"><link rel="prefetch" href="/assets/第七章 输入输出系统.html-1dd81ce8.js" as="script"><link rel="prefetch" href="/assets/第三章 存储系统.html-000040e3.js" as="script"><link rel="prefetch" href="/assets/第二章 数据的表示和运算.html-ddeff130.js" as="script"><link rel="prefetch" href="/assets/第五章 中央处理器.html-4b3e101d.js" as="script"><link rel="prefetch" href="/assets/第六章 总线.html-51081737.js" as="script"><link rel="prefetch" href="/assets/第四章 指令系统.html-cdf0c8b4.js" as="script"><link rel="prefetch" href="/assets/index.html-0eeb7d97.js" as="script"><link rel="prefetch" href="/assets/第一章 绪论.html-249c6779.js" as="script"><link rel="prefetch" href="/assets/第七章 查找.html-89571117.js" as="script"><link rel="prefetch" href="/assets/第三章 栈、队列和数组.html-154595f3.js" as="script"><link rel="prefetch" href="/assets/第二章 线性表.html-ad1f6f86.js" as="script"><link rel="prefetch" href="/assets/第五章 树与二叉树.html-ac639654.js" as="script"><link rel="prefetch" href="/assets/第八章 排序.html-fbce2382.js" as="script"><link rel="prefetch" href="/assets/第六章 图.html-30e4103a.js" as="script"><link rel="prefetch" href="/assets/第四章 串.html-b8cefd1a.js" as="script"><link rel="prefetch" href="/assets/index.html-a522e503.js" as="script"><link rel="prefetch" href="/assets/第一章 操作系统的基本概念.html-268ed91a.js" as="script"><link rel="prefetch" href="/assets/第二章 进程管理.html-a55219c6.js" as="script"><link rel="prefetch" href="/assets/第五章 输入输出管理.html-23b0e929.js" as="script"><link rel="prefetch" href="/assets/第四章 文件管理.html-e0042e5d.js" as="script"><link rel="prefetch" href="/assets/0-summary.html-8a496d5f.js" as="script"><link rel="prefetch" href="/assets/1-physical-layer.html-aa147741.js" as="script"><link rel="prefetch" href="/assets/2-data-link-layer.html-1322da93.js" as="script"><link rel="prefetch" href="/assets/3-network-layer.html-0f271d01.js" as="script"><link rel="prefetch" href="/assets/4-transport-layer.html-bf77eafd.js" as="script"><link rel="prefetch" href="/assets/5-application-layer.html-8d2cb541.js" as="script"><link rel="prefetch" href="/assets/index.html-38d54701.js" as="script"><link rel="prefetch" href="/assets/0-summary.html-55660e5a.js" as="script"><link rel="prefetch" href="/assets/1-data-representation-and-operation.html-719421a3.js" as="script"><link rel="prefetch" href="/assets/2-storage-system.html-3a17ba78.js" as="script"><link rel="prefetch" href="/assets/3-instruction-system.html-81e208cf.js" as="script"><link rel="prefetch" href="/assets/4-central-processing-unit.html-20ad90ce.js" as="script"><link rel="prefetch" href="/assets/5-bus.html-712b519d.js" as="script"><link rel="prefetch" href="/assets/6-input-output-system.html-9a68602f.js" as="script"><link rel="prefetch" href="/assets/index.html-b03eeba0.js" as="script"><link rel="prefetch" href="/assets/0-summary.html-b44ed7ff.js" as="script"><link rel="prefetch" href="/assets/1-linear-list.html-1462a363.js" as="script"><link rel="prefetch" href="/assets/2-stack.html-b4349720.js" as="script"><link rel="prefetch" href="/assets/5-string.html-42b794a9.js" as="script"><link rel="prefetch" href="/assets/6-tree.html-1fd29c9d.js" as="script"><link rel="prefetch" href="/assets/7-graph.html-ab34f299.js" as="script"><link rel="prefetch" href="/assets/8-search.html-84dfe998.js" as="script"><link rel="prefetch" href="/assets/9-sort.html-243a3fc3.js" as="script"><link rel="prefetch" href="/assets/index.html-4cb44941.js" as="script"><link rel="prefetch" href="/assets/0-summary.html-2aa06055.js" as="script"><link rel="prefetch" href="/assets/1-process-management.html-9b5419cd.js" as="script"><link rel="prefetch" href="/assets/2-memory-management.html-9ce71382.js" as="script"><link rel="prefetch" href="/assets/3-file-management.html-d5c7fd3c.js" as="script"><link rel="prefetch" href="/assets/4-device-management.html-ca11aa97.js" as="script"><link rel="prefetch" href="/assets/index.html-5e6c5016.js" as="script"><link rel="prefetch" href="/assets/0-summary-ex.html-3611c677.js" as="script"><link rel="prefetch" href="/assets/1-physical-layer-ex.html-cf52f4a4.js" as="script"><link rel="prefetch" href="/assets/2-data-link-layer-ex.html-253e53c7.js" as="script"><link rel="prefetch" href="/assets/3-network-layer-ex.html-cf6d650f.js" as="script"><link rel="prefetch" href="/assets/4-transport-layer-ex.html-8b4f66c9.js" as="script"><link rel="prefetch" href="/assets/5-application-layer-ex.html-a1bd6be2.js" as="script"><link rel="prefetch" href="/assets/index.html-5d82ab29.js" as="script"><link rel="prefetch" href="/assets/0-summary-ex.html-cbcda489.js" as="script"><link rel="prefetch" href="/assets/1-data-representation-and-operation-ex.html-098d8cbe.js" as="script"><link rel="prefetch" href="/assets/2-storage-system-ex.html-9eba2e2a.js" as="script"><link rel="prefetch" href="/assets/3-instruction-system-ex.html-7fb661d1.js" as="script"><link rel="prefetch" href="/assets/4-central-processing-unit-ex.html-8d722244.js" as="script"><link rel="prefetch" href="/assets/5-bus-ex.html-86dde322.js" as="script"><link rel="prefetch" href="/assets/6-input-output-system-ex.html-0114b6c1.js" as="script"><link rel="prefetch" href="/assets/index.html-ea6f84dd.js" as="script"><link rel="prefetch" href="/assets/0-summary-ex.html-ae995232.js" as="script"><link rel="prefetch" href="/assets/1-linear-list-ex.html-3043f657.js" as="script"><link rel="prefetch" href="/assets/2-stack-ex.html-cb2777bf.js" as="script"><link rel="prefetch" href="/assets/5-string-ex.html-d2e2505b.js" as="script"><link rel="prefetch" href="/assets/6-tree-ex.html-78888f1d.js" as="script"><link rel="prefetch" href="/assets/7-graph-ex.html-3ab4d4a7.js" as="script"><link rel="prefetch" href="/assets/8-search-ex.html-d015ecd4.js" as="script"><link rel="prefetch" href="/assets/9-sort-ex.html-7aea8392.js" as="script"><link rel="prefetch" href="/assets/index.html-20eb250d.js" as="script"><link rel="prefetch" href="/assets/0-summary-ex.html-6608397a.js" as="script"><link rel="prefetch" href="/assets/1-process-management-ex.html-b225c532.js" as="script"><link rel="prefetch" href="/assets/2-memory-management-ex.html-4e06341c.js" as="script"><link rel="prefetch" href="/assets/3-file-management-ex.html-7a4dc6d4.js" as="script"><link rel="prefetch" href="/assets/4-device-management-ex.html-f4057983.js" as="script"><link rel="prefetch" href="/assets/index.html-86a3503d.js" as="script"><link rel="prefetch" href="/assets/index.html-a23ed577.js" as="script"><link rel="prefetch" href="/assets/baz.html-b706040c.js" as="script"><link rel="prefetch" href="/assets/index.html-c01e150a.js" as="script"><link rel="prefetch" href="/assets/ray.html-ba7b30b1.js" as="script"><link rel="prefetch" href="/assets/404.html-8dbc8205.js" as="script"><link rel="prefetch" href="/assets/index.html-adeb2378.js" as="script"><link rel="prefetch" href="/assets/index.html-73409431.js" as="script"><link rel="prefetch" href="/assets/index.html-9184d1ca.js" as="script"><link rel="prefetch" href="/assets/index.html-0437d579.js" as="script"><link rel="prefetch" href="/assets/slides.html-213f7cec.js" as="script"><link rel="prefetch" href="/assets/408comeon.html-85aab784.js" as="script"><link rel="prefetch" href="/assets/index.html-afa757ad.js" as="script"><link rel="prefetch" href="/assets/index.html-d30c4963.js" as="script"><link rel="prefetch" href="/assets/assembler.html-e9b4dfb8.js" as="script"><link rel="prefetch" href="/assets/Cbase.html-8819188d.js" as="script"><link rel="prefetch" href="/assets/index.html-c9d098c5.js" as="script"><link rel="prefetch" href="/assets/disable.html-83fdde21.js" as="script"><link rel="prefetch" href="/assets/encrypt.html-bc403366.js" as="script"><link rel="prefetch" href="/assets/markdown.html-4cf4a4e4.js" as="script"><link rel="prefetch" href="/assets/page.html-022f0328.js" as="script"><link rel="prefetch" href="/assets/index.html-119aff9a.js" as="script"><link rel="prefetch" href="/assets/index.html-b8a40010.js" as="script"><link rel="prefetch" href="/assets/index.html-acf0ba79.js" as="script"><link rel="prefetch" href="/assets/第一章 计算机网络体系结构.html-bd92f3d7.js" as="script"><link rel="prefetch" href="/assets/第三章 数据链路层.html-3c1f53ac.js" as="script"><link rel="prefetch" href="/assets/第二章 物理层.html-b814c77f.js" as="script"><link rel="prefetch" href="/assets/第五章 传输层.html-458e986e.js" as="script"><link rel="prefetch" href="/assets/第六章 应用层.html-a044120e.js" as="script"><link rel="prefetch" href="/assets/第四章 网络层.html-538c6c5e.js" as="script"><link rel="prefetch" href="/assets/index.html-5d34803b.js" as="script"><link rel="prefetch" href="/assets/第一章 计算机系统概述.html-50cf0bee.js" as="script"><link rel="prefetch" href="/assets/第七章 输入输出系统.html-76ae9fec.js" as="script"><link rel="prefetch" href="/assets/第三章 存储系统.html-4c95b291.js" as="script"><link rel="prefetch" href="/assets/第二章 数据的表示和运算.html-76681ca4.js" as="script"><link rel="prefetch" href="/assets/第五章 中央处理器.html-73b2d863.js" as="script"><link rel="prefetch" href="/assets/第六章 总线.html-3a6fc568.js" as="script"><link rel="prefetch" href="/assets/第四章 指令系统.html-d05667f9.js" as="script"><link rel="prefetch" href="/assets/index.html-23921477.js" as="script"><link rel="prefetch" href="/assets/第一章 绪论.html-169bd028.js" as="script"><link rel="prefetch" href="/assets/第七章 查找.html-995275d5.js" as="script"><link rel="prefetch" href="/assets/第三章 栈、队列和数组.html-a7651972.js" as="script"><link rel="prefetch" href="/assets/第二章 线性表.html-9156518f.js" as="script"><link rel="prefetch" href="/assets/第五章 树与二叉树.html-752764f1.js" as="script"><link rel="prefetch" href="/assets/第八章 排序.html-d2632abd.js" as="script"><link rel="prefetch" href="/assets/第六章 图.html-8ace3acd.js" as="script"><link rel="prefetch" href="/assets/第四章 串.html-72c98b62.js" as="script"><link rel="prefetch" href="/assets/index.html-2155fe3e.js" as="script"><link rel="prefetch" href="/assets/第一章 操作系统的基本概念.html-74366cac.js" as="script"><link rel="prefetch" href="/assets/第二章 进程管理.html-69336d6d.js" as="script"><link rel="prefetch" href="/assets/第五章 输入输出管理.html-29dc2bd2.js" as="script"><link rel="prefetch" href="/assets/第四章 文件管理.html-b2d09399.js" as="script"><link rel="prefetch" href="/assets/0-summary.html-0b6788ab.js" as="script"><link rel="prefetch" href="/assets/1-physical-layer.html-3959cfba.js" as="script"><link rel="prefetch" href="/assets/2-data-link-layer.html-4cbd4594.js" as="script"><link rel="prefetch" href="/assets/3-network-layer.html-16c1ea9c.js" as="script"><link rel="prefetch" href="/assets/4-transport-layer.html-bd3ee370.js" as="script"><link rel="prefetch" href="/assets/5-application-layer.html-2bd25656.js" as="script"><link rel="prefetch" href="/assets/index.html-ffb197b4.js" as="script"><link rel="prefetch" href="/assets/0-summary.html-c3e3d6c5.js" as="script"><link rel="prefetch" href="/assets/1-data-representation-and-operation.html-c1bd6f5f.js" as="script"><link rel="prefetch" href="/assets/2-storage-system.html-2ff9d64c.js" as="script"><link rel="prefetch" href="/assets/3-instruction-system.html-53969d04.js" as="script"><link rel="prefetch" href="/assets/4-central-processing-unit.html-f6be771c.js" as="script"><link rel="prefetch" href="/assets/5-bus.html-b8415d02.js" as="script"><link rel="prefetch" href="/assets/6-input-output-system.html-86e22c79.js" as="script"><link rel="prefetch" href="/assets/index.html-611b0fc5.js" as="script"><link rel="prefetch" href="/assets/0-summary.html-00b0733a.js" as="script"><link rel="prefetch" href="/assets/1-linear-list.html-849c8f56.js" as="script"><link rel="prefetch" href="/assets/2-stack.html-5ef2eea5.js" as="script"><link rel="prefetch" href="/assets/5-string.html-c5c33568.js" as="script"><link rel="prefetch" href="/assets/6-tree.html-07258765.js" as="script"><link rel="prefetch" href="/assets/7-graph.html-f1cb119e.js" as="script"><link rel="prefetch" href="/assets/8-search.html-b854334a.js" as="script"><link rel="prefetch" href="/assets/9-sort.html-b1ded877.js" as="script"><link rel="prefetch" href="/assets/index.html-53d3ec21.js" as="script"><link rel="prefetch" href="/assets/0-summary.html-b72eb491.js" as="script"><link rel="prefetch" href="/assets/1-process-management.html-f72ef110.js" as="script"><link rel="prefetch" href="/assets/2-memory-management.html-8c0fecaa.js" as="script"><link rel="prefetch" href="/assets/3-file-management.html-a6f8dd6a.js" as="script"><link rel="prefetch" href="/assets/4-device-management.html-ec676422.js" as="script"><link rel="prefetch" href="/assets/index.html-ca01e69d.js" as="script"><link rel="prefetch" href="/assets/0-summary-ex.html-a7ba269f.js" as="script"><link rel="prefetch" href="/assets/1-physical-layer-ex.html-7af5590f.js" as="script"><link rel="prefetch" href="/assets/2-data-link-layer-ex.html-f47c38f4.js" as="script"><link rel="prefetch" href="/assets/3-network-layer-ex.html-3dddca1d.js" as="script"><link rel="prefetch" href="/assets/4-transport-layer-ex.html-5be6ebad.js" as="script"><link rel="prefetch" href="/assets/5-application-layer-ex.html-0685adc3.js" as="script"><link rel="prefetch" href="/assets/index.html-57a4362e.js" as="script"><link rel="prefetch" href="/assets/0-summary-ex.html-b154452f.js" as="script"><link rel="prefetch" href="/assets/1-data-representation-and-operation-ex.html-ce6b138d.js" as="script"><link rel="prefetch" href="/assets/2-storage-system-ex.html-63af14ba.js" as="script"><link rel="prefetch" href="/assets/3-instruction-system-ex.html-306d635f.js" as="script"><link rel="prefetch" href="/assets/4-central-processing-unit-ex.html-5c0452ad.js" as="script"><link rel="prefetch" href="/assets/5-bus-ex.html-d2a7a547.js" as="script"><link rel="prefetch" href="/assets/6-input-output-system-ex.html-ac3bfac3.js" as="script"><link rel="prefetch" href="/assets/index.html-da6dac88.js" as="script"><link rel="prefetch" href="/assets/0-summary-ex.html-a715a0f1.js" as="script"><link rel="prefetch" href="/assets/1-linear-list-ex.html-79217c20.js" as="script"><link rel="prefetch" href="/assets/2-stack-ex.html-af766de1.js" as="script"><link rel="prefetch" href="/assets/5-string-ex.html-8c9cd2e2.js" as="script"><link rel="prefetch" href="/assets/6-tree-ex.html-834ec9ad.js" as="script"><link rel="prefetch" href="/assets/7-graph-ex.html-1a69faa8.js" as="script"><link rel="prefetch" href="/assets/8-search-ex.html-1a5fbce8.js" as="script"><link rel="prefetch" href="/assets/9-sort-ex.html-8bb5e48c.js" as="script"><link rel="prefetch" href="/assets/index.html-37800dc3.js" as="script"><link rel="prefetch" href="/assets/0-summary-ex.html-9796982a.js" as="script"><link rel="prefetch" href="/assets/1-process-management-ex.html-bc63bc24.js" as="script"><link rel="prefetch" href="/assets/2-memory-management-ex.html-33221b67.js" as="script"><link rel="prefetch" href="/assets/3-file-management-ex.html-129a1cf7.js" as="script"><link rel="prefetch" href="/assets/4-device-management-ex.html-6df3f0a4.js" as="script"><link rel="prefetch" href="/assets/index.html-abddae00.js" as="script"><link rel="prefetch" href="/assets/index.html-a1a791a1.js" as="script"><link rel="prefetch" href="/assets/baz.html-4cd5bb60.js" as="script"><link rel="prefetch" href="/assets/index.html-0d323dd4.js" as="script"><link rel="prefetch" href="/assets/ray.html-3b649059.js" as="script"><link rel="prefetch" href="/assets/404.html-29ca8d46.js" as="script"><link rel="prefetch" href="/assets/index.html-1a5a78a9.js" as="script"><link rel="prefetch" href="/assets/index.html-4fd81deb.js" as="script"><link rel="prefetch" href="/assets/index.html-9df0b98c.js" as="script"><link rel="prefetch" href="/assets/auto-ba5ecab5.js" as="script"><link rel="prefetch" href="/assets/index-b03bef79.js" as="script"><link rel="prefetch" href="/assets/flowchart-35969cab.js" as="script"><link rel="prefetch" href="/assets/mermaid.core-f8b02062.js" as="script"><link rel="prefetch" href="/assets/highlight.esm-75b11b9d.js" as="script"><link rel="prefetch" href="/assets/markdown.esm-0191f9da.js" as="script"><link rel="prefetch" href="/assets/math.esm-70a288c8.js" as="script"><link rel="prefetch" href="/assets/notes.esm-a106bb2c.js" as="script"><link rel="prefetch" href="/assets/reveal.esm-ab04f0b1.js" as="script"><link rel="prefetch" href="/assets/search.esm-7e6792e2.js" as="script"><link rel="prefetch" href="/assets/zoom.esm-b83b91d0.js" as="script"><link rel="prefetch" href="/assets/VuePlayground-ace35138.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-36cd6c3c.js" as="script"><link rel="prefetch" href="/assets/SearchResult-59c70f9b.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button type="button" class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a href="/" class="brand"><img class="logo" src="/logo.png" alt="研小布「考研资料站」"><!----><span class="site-name hide-in-pad">研小布「考研资料站」</span></a><!--]--><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><!--[--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="首页"><span class="font-icon icon iconfont icon-home" style=""></span>首页<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!--[--><!----><!----><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><button type="button" class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="placeholder">搜索</div><div class="key-hints"><kbd class="key">Ctrl</kbd><kbd class="key">K</kbd></div></button><!--]--><!--]--><!--[--><!----><!--]--><button type="button" class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/" class="nav-link sidebar-link sidebar-page" aria-label="研小布"><span class="font-icon icon iconfont icon-home" style=""></span>研小布<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><section class="sidebar-group"><p class="sidebar-heading clickable active"><span class="font-icon icon iconfont icon-note" style=""></span><a href="/408notes/" class="nav-link active title" aria-label="408笔记【常规版】"><!---->408笔记【常规版】<!----></a><!----></p><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><!----><span class="title">01-数据结构</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><!----><span class="title">02-计算机组成原理</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active" type="button"><!----><span class="title">03-操作系统</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/408notes/OS/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html" class="nav-link sidebar-link sidebar-page" aria-label="第一章 操作系统的基本概念"><!---->第一章 操作系统的基本概念<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/408notes/OS/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html" class="nav-link sidebar-link sidebar-page" aria-label="第二章 进程管理"><!---->第二章 进程管理<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第三章 文件管理"><!---->第三章 文件管理<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#内存管理概念" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="内存管理概念"><!---->内存管理概念<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#内存管理的基本原理和要求" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="内存管理的基本原理和要求"><!---->内存管理的基本原理和要求<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#覆盖与交换" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="*覆盖与交换"><!---->*覆盖与交换<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#连续分配管理方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="连续分配管理方式"><!---->连续分配管理方式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#非连续分配管理方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="非连续分配管理方式"><!---->非连续分配管理方式<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#虚拟内存管理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="虚拟内存管理"><!---->虚拟内存管理<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#虚拟内存的基本概念" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="虚拟内存的基本概念"><!---->虚拟内存的基本概念<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#请求分页管理方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="请求分页管理方式"><!---->请求分页管理方式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#页面置换算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="页面置换算法"><!---->页面置换算法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#页面分配策略" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="页面分配策略"><!---->页面分配策略<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#抖动" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="抖动"><!---->抖动<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#工作集" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="工作集"><!---->工作集<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a href="/408notes/OS/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.html" class="nav-link sidebar-link sidebar-page" aria-label="第四章 文件管理"><!---->第四章 文件管理<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/408notes/OS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86.html" class="nav-link sidebar-link sidebar-page" aria-label="第五章 输入输出管理"><!---->第五章 输入输出管理<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><!----><span class="title">04-计算机网络</span><span class="arrow end"></span></button><!----></section></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第三章 文件管理</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://ky-doc.github.io/mydoc/" target="_blank" rel="noopener noreferrer">研小布</a></span><span property="author" content="研小布"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-04-23T10:21:12.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 39 分钟</span><meta property="timeRequired" content="PT39M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#内存管理概念" class="router-link-active router-link-exact-active toc-link level2">内存管理概念</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#内存管理的基本原理和要求" class="router-link-active router-link-exact-active toc-link level3">内存管理的基本原理和要求</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#覆盖与交换" class="router-link-active router-link-exact-active toc-link level3">*覆盖与交换</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#连续分配管理方式" class="router-link-active router-link-exact-active toc-link level3">连续分配管理方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#非连续分配管理方式" class="router-link-active router-link-exact-active toc-link level3">非连续分配管理方式</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#虚拟内存管理" class="router-link-active router-link-exact-active toc-link level2">虚拟内存管理</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#虚拟内存的基本概念" class="router-link-active router-link-exact-active toc-link level3">虚拟内存的基本概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#请求分页管理方式" class="router-link-active router-link-exact-active toc-link level3">请求分页管理方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#页面置换算法" class="router-link-active router-link-exact-active toc-link level3">页面置换算法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#页面分配策略" class="router-link-active router-link-exact-active toc-link level3">页面分配策略</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#抖动" class="router-link-active router-link-exact-active toc-link level3">抖动</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/408notes/OS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html#工作集" class="router-link-active router-link-exact-active toc-link level3">工作集</a></li><!----><!--]--></ul></li><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><h2 id="内存管理概念" tabindex="-1"><a class="header-anchor" href="#内存管理概念" aria-hidden="true">#</a> 内存管理概念</h2><h3 id="内存管理的基本原理和要求" tabindex="-1"><a class="header-anchor" href="#内存管理的基本原理和要求" aria-hidden="true">#</a> 内存管理的基本原理和要求</h3><p>不可能将全部程序与数据放入主存，因此<strong>操作系统必须对内存进行划分和动态分配</strong>，这就是内存管理的概念</p><p>有效的内存管理可以<u>方便用户使用存储器、提高内存利用率、通过虚拟技术从逻辑上扩充存储器</u></p><p>内存管理的功能有：</p><ul><li>内存空间的分配与回收：由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率</li><li>地址转换：程序中的逻辑地址与内存中的物理地址不一致，需要存储管理<strong>把逻辑地址转换成相应的物理地址</strong></li><li>内存空间的扩充：利用<strong>虚拟存储技术或自动覆盖技术，从逻辑上扩充内存</strong></li><li>存储保护：保证<strong>各道作业在各自的存储空间内运行</strong>，互不干扰</li></ul><h4 id="程序装入和链接" tabindex="-1"><a class="header-anchor" href="#程序装入和链接" aria-hidden="true">#</a> 程序装入和链接</h4><p>将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：</p><ul><li>编译：由编译程序<strong>将用户源代码编译成若干目标模块</strong></li><li>链接：由链接程序将编译后形成的<strong>一组目标模块及所需的库函数链接成一个完整的装入模块</strong>（如 <code>.exe</code> 文件）</li><li>装入：由装入程序<strong>将装入模块装入内存运行</strong></li></ul><figure><img src="/408noteImg/images/image-20211111224908120.png" alt="image-20211111224908120" tabindex="0" loading="lazy"><figcaption>image-20211111224908120</figcaption></figure><p>程序的链接有以下三种方式：</p><ul><li>静态链接：<strong>将各目标模块及它们所需的库函数链接成一个完整的可执行程序</strong></li><li>装入时动态链接：<strong>装入内存时，采用边装入边链接的方式</strong></li><li>运行时动态链接：在程序执行中<strong>需要目标模块时才进行链接</strong>；其优点是<strong>便于修改和更新和实现对目标模块的共享</strong></li></ul><p>内存的装入模块在装入内存时，同样有以下三种方式：</p><ol><li><p>绝对装入：</p><p>编译程序将<strong>产生绝对地址的目标代码</strong>，绝对装入程序<strong>按照装入模块中的地址装入内存</strong>，仅适用于<strong>单道程序环境</strong></p><p>通常程序员给出符号地址，让<strong>编译或汇编程序转换成绝对地址</strong>，也可由<strong>程序员直接给出绝对地址</strong></p></li><li><p>可重定位装入，静态重定向：<strong>只在装入时进行重定向</strong></p><p>在多道程序环境下，多个目标模块的<strong>起始地址通常都从 0 开始</strong>，程序中的<strong>其他地址相对于始址</strong></p><p><strong>根据内存的当前情况，装入内存的适当位置</strong>，装入时对指令和数据的修改过程（逻辑地址→物理地址）称为<strong>重定位</strong></p><figure><img src="/408noteImg/images/image-20211112132205564.png" alt="image-20211112132205564" tabindex="0" loading="lazy"><figcaption>image-20211112132205564</figcaption></figure><p>特点：</p><ul><li>作业装入内存时，必须给它分配要求的全部内存空间，若<strong>没有足够的内存，则不能装入该作业</strong></li><li>作业一旦进入内存，整个运行期间<strong>不能在内存中移动和再申请内存空间</strong></li></ul></li><li><p>动态运行时装入，动态重定位：<strong>在执行时才进行重定向</strong>，现代操作系统使用</p><p><u>程序在内存中若发生移动，则需要采用动态的装入方式</u>，这种方法<strong>需要一个重定位寄存器的支持</strong></p><figure><img src="/408noteImg/images/image-20211112133706111.png" alt="image-20211112133706111" tabindex="0" loading="lazy"><figcaption>image-20211112133706111</figcaption></figure><p>特点，这是需要在<strong>运行时进行地址转换</strong>才能做到的：</p><ul><li>可以<strong>将程序分配到不连续的存储区中</strong></li><li>在程序运行之前可以<strong>只装入它的部分代码</strong>即可投入运行，然后<strong>在程序运行期间，根据需要动态申请分配内存</strong></li><li><strong>便于程序段的共享</strong>，可以向用户<strong>提供一个比存储空间大得多的地址空间</strong></li></ul></li></ol><h4 id="逻辑地址空间与物理地址空间" tabindex="-1"><a class="header-anchor" href="#逻辑地址空间与物理地址空间" aria-hidden="true">#</a> 逻辑地址空间与物理地址空间</h4><p>编译后每个目标模块都<strong>从 0 号单元开始编址</strong>，这称为该目标模块的<strong>相对地址</strong>或<strong>逻辑地址</strong></p><p>链接程序将各个模块<strong>链接成一个完整的可执行程序后</strong>，就<strong>构成统一的从 0 号单元开始编址的逻辑地址空间</strong></p><p>用户程序和程序员<strong>只需知道逻辑地址</strong>；不同<strong>进程可以有相同的逻辑地址</strong>，因为会<strong>映射到主存的不同位置</strong></p><p><strong>物理地址是主存储器的地址</strong>，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取</p><h4 id="内存保护" tabindex="-1"><a class="header-anchor" href="#内存保护" aria-hidden="true">#</a> 内存保护</h4><p>内存保护是指：</p><ul><li><strong>保护操作系统不受用户进程的影响</strong></li><li><strong>保护用户进程不受其他用户进程的影响</strong></li></ul><p>内存保护可采取两种方法：</p><ol><li><p>在 CPU 中设置一对上、下限寄存器，<strong>每当 CPU 要访问一个地址时，分别和两个寄存器的值相比，判断有无越界</strong></p></li><li><p>采用重定位寄存器（或基址寄存器）和界地址寄存器（又称限长寄存器）来实现这种保护：</p><p>重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址的最大值，<strong>每个逻辑地址值必须小于界地址寄存器</strong></p><p>内存管理机构<strong>将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址</strong></p><figure><img src="/408noteImg/images/image-20211111225125773.png" alt="image-20211111225125773" tabindex="0" loading="lazy"><figcaption>image-20211111225125773</figcaption></figure></li></ol><h3 id="覆盖与交换" tabindex="-1"><a class="header-anchor" href="#覆盖与交换" aria-hidden="true">#</a> *覆盖与交换</h3><h4 id="覆盖" tabindex="-1"><a class="header-anchor" href="#覆盖" aria-hidden="true">#</a> 覆盖</h4><p>早期的计算机系统中，存储空间放不下一道用户进程的现象也经常发生，可以用覆盖技术来解决</p><p>覆盖的基本思想如下：</p><ul><li>把用户空间分成一个<u>固定区和若干覆盖区</u></li><li>将<u>经常活跃的部分放在固定区</u>，其余部分按调用关系分段</li><li>将<u>即将要访问的段放入对应的覆盖区替换其原有的内容，其他段放在外存中</u></li></ul><p>特点：</p><ul><li><u>不需要将一个进程的全部信息装入主存后才能运行</u>，但<u>同时运行程序的代码量大于主存时仍不能运行</u></li><li>内存中能够更新的地方只有覆盖区的段，<u>不在覆盖区中的段会常驻内存</u></li><li><u>需要程序员指明固定区和覆盖区</u>，增加了用户编程负担</li></ul><h4 id="交换" tabindex="-1"><a class="header-anchor" href="#交换" aria-hidden="true">#</a> 交换</h4><p>交换（对换）的基本思想是（中级调度采用的就是交换技术）：</p><ul><li>换出：把处于<u>等待状态的程序从内存移到辅存</u>，把内存空间腾出来</li><li>换入：把<u>准备好竞争 CPU 运行的程序从辅存移到内存</u></li></ul><p>有关交换，需要注意以下几个问题：</p><ul><li><p>交换需要备份存储，通常是快速磁盘</p></li><li><p>为了有效使用 CPU，需要使每个进程的执行时间比交换时间长</p></li><li><p>若换出进程，则必须确保该进程<u>完全处于空闲状态</u></p></li><li><p>交换空间通常作为磁盘的一整块，且独立于文件系统</p><p>磁盘有对换区和文件区，<u>文件区采用离散方式，对换区采用连续方式效率高</u></p></li><li><p><u>交换通常在有许多进程运行且内存空间吃紧时开始启动，而在系统负荷降低时就暂停</u></p></li><li><p>普通的交换使用不多，但交换策略的某些变体在许多系统中仍发挥作用，如 UNIX 系统</p></li></ul><p>选择题：若一个进程正在 I/O 操作，则不能交换出主存，但 OS 开辟 I/O 缓冲区后进程交换不受限制</p><p>选择题：可重入程序通过共享或动态链接来使用同一块存储空间，以减少对程序段的调出/调入，减少了对换数量</p><hr><p><u>交换技术主要在不同进程之间进行，而覆盖则用于同一个程序或进程中</u></p><p>对于主存无法存放用户程序的矛盾，<strong>现代操作系统是通过虚拟内存技术来解决</strong>的</p><p>覆盖技术则已成为历史，而交换技术在现代操作系统中仍具有较强的生命力</p><h3 id="连续分配管理方式" tabindex="-1"><a class="header-anchor" href="#连续分配管理方式" aria-hidden="true">#</a> 连续分配管理方式</h3><p>连续分配方式是指<strong>为一个用户程序分配一个连续的内存空间</strong></p><p>连续分配方式主要包括单一连续分配、固定分区分配、动态分区分配：</p><h4 id="单一连续分配" tabindex="-1"><a class="header-anchor" href="#单一连续分配" aria-hidden="true">#</a> 单一连续分配</h4><p>内存分为<strong>系统区和用户区，系统区在低地址部分</strong>，这种方式<strong>无须进行内存保护</strong>（单任务不需要保护）</p><p>优点：简单、<strong>无外部碎片</strong>，可以采用覆盖技术，<strong>不需要额外的技术支持</strong></p><p>缺点：只能用于<strong>单用户、单任务</strong>的操作系统中，<strong>有内部碎片，存储器的利用率极低</strong></p><h4 id="固定分区分配" tabindex="-1"><a class="header-anchor" href="#固定分区分配" aria-hidden="true">#</a> 固定分区分配</h4><p>最简单的一种多道程序存储管理方式，<strong>将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业</strong></p><p>使用：每当有空闲分区时，便可再从外存的后备作业队列中选择适当大小的作业装入该分区</p><p>固定分区分配在划分分区时有两种不同的方法：</p><ul><li>分区大小相等：<strong>用于利用一台计算机去控制<u>多个相同对象的场合</u></strong>，缺乏灵活性</li><li>分区大小不等：划分为<u>多个较小的分区、适量的中等分区和少量大分区</u></li></ul><figure><img src="/408noteImg/images/image-20211111232041170.png" alt="image-20211111232041170" tabindex="0" loading="lazy"><figcaption>image-20211111232041170</figcaption></figure><p>为便于内存分配，通常将分区<strong>按大小排队</strong>，并为之建立一张分区说明表，其中各表项包括<strong>每个分区的始址、大小及状态</strong></p><p>有程序要装入时，检索该表<strong>找到合适的分区给予分配并将其状态置为已分配，未找到合适分区时，则拒绝分配</strong></p><figure><img src="/408noteImg/images/image-20211111232108565.png" alt="image-20211111232108565" tabindex="0" loading="lazy"><figcaption>image-20211111232108565</figcaption></figure><p>这种分区方式存在几个问题：</p><ol><li><strong>程序可能太大而放不进任何一个分区中</strong>，这时用户不得不使用覆盖技术来使用内存空间</li><li>主存利用率低，<strong>程序小于固定分区时也占整个固定分区</strong>，这种现象称为<strong>内部碎片</strong></li><li><strong>不能实现多进程共享一个主存区</strong>，存储空间利用率低</li></ol><h4 id="动态分区分配" tabindex="-1"><a class="header-anchor" href="#动态分区分配" aria-hidden="true">#</a> 动态分区分配</h4><p>又称<strong>可变分区分配</strong>，<strong>在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要</strong></p><p>如下图，首先装入三个进程，在某个时刻 CPU 出现空闲，换出进程 2 换入进程 4，中间产生了内存块；CPU 又空闲...</p><figure><img src="/408noteImg/images/image-20211111232144689.png" alt="image-20211111232144689" tabindex="0" loading="lazy"><figcaption>image-20211111232144689</figcaption></figure><p>动态分区会<strong>导致内存中出现许多小的内存块</strong>，随着时间的推移，内存中会产生越来越多的碎片，<strong>内存的利用率随之下降</strong></p><p>这些小的内存块称为<strong>外部碎片</strong>，可以通过紧凑 Compaction 技术来解决，即<strong>把动态分区移动到一起</strong>，但这<strong>需要动态重定位寄存器的支持</strong>，且相对费时</p><p>分配策略：内存中<strong>有多个足够大的空闲块</strong>，操作系统必须<strong>确定分配哪个内存块给进程使用</strong>，有以下几种算法：</p><ol><li><p>首次适应 First Fit 算法：空闲分区<strong>以地址递增的次序链接</strong>，分配内存时顺序查找，分配<strong>大小能满足要求的第一个空闲分区</strong></p><p>会使内存的<strong>低地址部分出现很多小的空闲分区</strong>，查找时都要经过这些分区，因此<strong>增加了查找的开销</strong></p><p>首次适应算法不仅是最简单的，而且通常也是<strong>最好和最快</strong>的</p></li><li><p>最佳适应 Best Fit 算法：空闲分区<strong>按容量递增的方式形成分区链</strong>，分配<strong>第一个能满足要求的空闲分区</strong></p><p>每次最佳的分配会留下很小的难以利用的内存块，会<strong>产生最多的外部碎片，性能很差</strong></p></li><li><p>最坏适应 Worst Fit，最大适应 Largest Fit 算法：空闲分区<strong>以容量递减的次序链接</strong>，分配<strong>第一个能满足要求的空闲分区</strong></p><p>总把最大的连续内存划分开，会<strong>很快导致没有可用的大内存块，性能非常差</strong></p></li><li><p>邻近适应 Next Fit，循环首次适应算法：与首次适应算法相比，分配内存时<strong>从上次查找结束的位置开始继续查找</strong></p><p>虽然查找链表的次数快了，但<strong>不能形成较大的空闲分区</strong>，当有程序需要较大的内存时不能满足，通常<strong>比首次适应法差</strong></p></li></ol><p>注意：<strong>空闲分区可以使用数组或链表来管理</strong>；实验表明<strong>首次适应 &gt; 最佳适应法 &gt; 最大适应法</strong></p><p>注意：在回收操作中，当<strong>回收的块与原来的空闲块相邻时，需要将这些块合并</strong>；算法开销也是需要考虑的一个因素</p><figure><img src="/408noteImg/images/image-20211111232240726.png" alt="image-20211111232240726" tabindex="0" loading="lazy"><figcaption>image-20211111232240726</figcaption></figure><h3 id="非连续分配管理方式" tabindex="-1"><a class="header-anchor" href="#非连续分配管理方式" aria-hidden="true">#</a> 非连续分配管理方式</h3><p>非连续分配<strong>允许一个程序分散地装入不相邻的内存分区</strong>，但这也<strong>需要额外的空间去存储分散区域的索引</strong>，使得<strong>非连续分配方式的存储密度低于连续存储方式的存储密度</strong></p><p>非连续分配管理方式<strong>根据分区的大小是否固定</strong>，分为<u>分页存储管理方式和分段存储管理方式</u>；在分页存储管理方式中，又<strong>根据运行作业时是否要把作业的所有页面都装入内存才能运行</strong>，分为<u>基本分页存储管理方式和请求分页存储管理方式</u></p><h4 id="基本分页存储管理方式" tabindex="-1"><a class="header-anchor" href="#基本分页存储管理方式" aria-hidden="true">#</a> 基本分页存储管理方式</h4><p>为了内存的使用能尽量避免碎片的产生，引入了分页的思想：</p><ul><li>把<strong>主存空间划分为大小相等且固定的块</strong>，块相对较小，作为<strong>主存的基本单位</strong></li><li>每个<strong>进程也以块为单位进行划分</strong>，进程在执行时，<strong>以块为单位逐个申请主存中的块空间</strong></li></ul><p>进程只会在为最后一个不完整的块申请一个主存块空间时，才产生主存碎片，所以尽管会产生内部碎片，但这种碎片相对于进程来说也是很小的，<strong>每个进程平均只产生半个块大小的内部碎片（也称页内碎片）</strong></p><h5 id="分页存储的几个基本概念" tabindex="-1"><a class="header-anchor" href="#分页存储的几个基本概念" aria-hidden="true">#</a> 分页存储的几个基本概念</h5><ol><li><p>页面和页面大小：</p><p><strong>进程中的块称为页</strong> Page 或页面，<strong>内存中的块称为页框</strong> Page Frame 或页帧，<strong>外存直接称为块</strong> Block</p><p>进程在执行时要<strong>为每个页面分配主存中的可用页框</strong>，这就产生了页和页框的一一对应</p><p><strong>页面大小应是 2 的整数幂</strong>，同时页面大小应该适中：</p><ul><li><p>页面太小会使进程的页面数过多，这样<strong>页表就会过长</strong>，占用大量内存</p><p>也会增加硬件地址转换的开销，降低页面换入/换出的效率（<strong>即频繁换页</strong>）</p></li><li><p>页面过大又会使<strong>页内碎片增多</strong>，降低内存的利用率</p></li></ul><p>选择题：操作系统的内存分页大小一旦确定，所有的页面就是等长的，无论在哪台电脑装（应该）</p></li><li><p>地址结构：</p><figure><img src="/408noteImg/images/image-20211111232418494.png" alt="image-20211111232418494" tabindex="0" loading="lazy"><figcaption>image-20211111232418494</figcaption></figure><p>地址结构包含两部分：前一部分为<strong>页号 P</strong>，后一部分为<strong>页内偏移量 W</strong></p><p>注意：<strong>地址结构决定了虚拟内存的寻址空间有多大</strong></p></li><li><p>页表：</p><p>系统<strong>为每个进程建立一张页表</strong>来实现<strong>从页号到物理块号的地址映射</strong>，<strong>页表总是存放在内存中</strong></p><p><strong>页表是由页表项组成</strong>的，页表项由<strong>页号和物理内存中的块号</strong>组成；<strong>物理内存块号和页内偏移量共同组成物理地址</strong></p></li></ol><figure><img src="/408noteImg/images/image-20211111232457932.png" alt="image-20211111232457932" tabindex="0" loading="lazy"><figcaption>image-20211111232457932</figcaption></figure><h5 id="基本地址变换机构" tabindex="-1"><a class="header-anchor" href="#基本地址变换机构" aria-hidden="true">#</a> 基本地址变换机构</h5><p>地址变换机构的任务是<strong>将逻辑地址转换为内存中的物理地址</strong>，地址变换是借助于页表实现的</p><figure><img src="/408noteImg/images/image-20211111232545922.png" alt="image-20211111232545922" tabindex="0" loading="lazy"><figcaption>image-20211111232545922</figcaption></figure><p>通常设置一个<strong>页表寄存器 PTR</strong>，存放<strong>页表在内存的起始地址</strong> F 和<strong>页表长度</strong> M</p><p>进程<strong>未执行时</strong>，页表的始址和长度存<strong>放在进程控制块 PCB 中</strong>；进程<strong>执行时</strong>，才<strong>将页表始址和长度存入页表寄存器</strong></p><p>设页面大小为 L，逻辑地址 A 到物理地址 E 的变换过程如下：</p><ol><li><p>计算<strong>页号 P=A / L</strong> 和<strong>页内偏移量 W = A % L</strong></p></li><li><p>比较页号 Р 和页表长度 M，<strong>若 P ≥ M，则产生越界中断，否则继续执行</strong></p></li><li><p><strong>页表项地址 = 页表始址 F＋页号 P × 页表项长度</strong>，根据表项地址<strong>取出物理块号 b</strong></p><p>注意：页表长度的值是指<strong>一共有多少页</strong>，页表项长度是指<strong>页地址占多大的存储空间</strong></p></li><li><p>计算<strong>物理地址 E = b × L + W</strong>，用得到的物理地址去访问内存</p></li></ol><p>以上<strong>整个地址变换过程均是由硬件自动完成</strong></p><p>页式管理<strong>只需给出一个整数就能确定对应的物理地址</strong>（页面大小固定），因此<strong>页式管理中地址空间是一维的</strong></p><p>以 32 位逻辑地址空间、字节编址单位、一页 <code>4KB</code> 为例，确定页表项的大小：</p><ol><li><code>4KB</code> 共需要 12 位表示，剩下的 20 位用于表示页号的范围</li><li>因为以字节作为编址单位，页表项的大小 ≥ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mn>20</mn><mi mathvariant="normal">/</mi><mn>8</mn><mo stretchy="false">⌉</mo><mo>=</mo><mn>3</mn><mi>B</mi></mrow><annotation encoding="application/x-tex">\lceil20/8\rceil =3B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord">20/8</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，页表项<strong>至少</strong>是 <code>3B</code></li><li>为了<strong>存储方便和放额外信息</strong>，可以页表项可以<strong>取大点</strong>如 <code>4B</code>，这样一页正好装下 <code>1K</code> 个页表项</li></ol><p>下面讨论分页管理方式存在的两个主要问题：</p><ol><li>每次访存操作都需要进行地址转换，<strong>地址转换过程必须足够快，否则访存速度会降低</strong></li><li>每个进程引入页表，用于存储映射机制，<strong>页表不能太大，否则内存利用率会降低</strong></li></ol><h5 id="具有快表的地址变换机构" tabindex="-1"><a class="header-anchor" href="#具有快表的地址变换机构" aria-hidden="true">#</a> 具有快表的地址变换机构</h5><p>若页表全部放在内存中，则存取一个数据或一条指令<strong>至少要访问两次内存</strong>，这种方法比通常执行指令的速度慢了一半</p><p>在地址变换机构中<strong>增设快表 TLB</strong>，存放若干页表项以<strong>加速地址变换的过程</strong>，而<strong>主存中的页表常称为慢表</strong></p><figure><img src="/408noteImg/images/image-20211111232643969.png" alt="image-20211111232643969" tabindex="0" loading="lazy"><figcaption>image-20211111232643969</figcaption></figure><p>在具有快表的分页机制中，地址的变换过程如下：</p><ol><li>CPU 给出逻辑地址后，由硬件进行地址转换，<strong>将此页号与快表中的所有页号同时进行比较</strong></li><li>若找到匹配的页号，则直接<strong>从快表中取出该页对应的页框号，形成物理地址</strong>（一次访存）</li><li>若未找到匹配的页号，则在内存中<strong>读出页表项，将其存入快表</strong>，若快表已满按照某算法进行替换</li></ol><p>注意：有些处理机设计为<u>快表和慢表同时查找</u>，若<u>在快表中查找成功则终止慢表的查找</u>，<strong>题目没写一般不是这种</strong></p><p>注意：快表访问成功<u>仍需访问一次内存</u>；快慢表非同时查找时，不管快表访问成不成功<u>访问快表的时间都要消耗</u></p><p>由于基于局部性原理，快表的命中率可达 90% 以上，这样分页带来的速度损失就可降低至 10% 以下</p><h5 id="两级页表" tabindex="-1"><a class="header-anchor" href="#两级页表" aria-hidden="true">#</a> 两级页表</h5><p>引入分页管理后，进程在<strong>执行时不需将所有页调入内存页框</strong>，<strong>只需将保存有映射关系的页表调入内存</strong>，但仍需考虑页表大小</p><p>一个 <code>40MB</code> 的进程它需要 10 页框来保存页表，但是它实际执行时可能只需要几十个页框就可运行：</p><ul><li>若要求 10 个页面大小的页表必须全部进入内存，相对于几十个页框来说，<strong>降低了内存利用率</strong></li><li>在大多数情况下，<strong>映射所需要的页表项都在页表的同一个页面中</strong>，没必要 10 个页表都在内存</li><li>需要<strong>连续</strong>的 10 个页框空间来存放页表，系统内可能找不到这么大的连续空间</li></ul><p>注意：<strong>一般进程需要全部地址映射</strong>，单页表就需要 <code>4MB</code>，因为一般程序会用到高位和低位地址，如栈在高位，代码在低位</p><p>为了减少页表占用空间，进一步延申页表映射思想，得到了二级页表，<strong>对页表也进行地址映射，建立上一级页表，来存储页表的映射关系</strong>，以下是二级页表的逻辑地址空间的格式（为查询方便，<strong>顶级页表只能有 1 个页面</strong>）</p><figure><img src="/408noteImg/images/image-20211111232816798.png" alt="image-20211111232816798" tabindex="0" loading="lazy"><figcaption>image-20211111232816798</figcaption></figure><p>例如：页面大小为 <code>4KB</code>，页内偏移地址为 12位，页号部分为 20 位，顶级页表可以放 <code>4KB / 4B = 1024</code> 个表项，占 10 位，因此逻辑地址空间就剩下了 10 位，二级页表的大小正好在一页之内，这样就得到了 10 10 12 的格式</p><figure><img src="/408noteImg/images/image-20211111232851361.png" alt="image-20211111232851361" tabindex="0" loading="lazy"><figcaption>image-20211111232851361</figcaption></figure><p>建立多级页表的目的在于建立索引，以便<strong>不用浪费主存空间去存储无用的页表项</strong>，也<strong>不用盲目地顺序式查找页表项</strong></p><p>思考：若采用二级页表，当程序挂起时，最高一级页表必须在内存；运行时仅需要用到的二级页表在内存</p><h4 id="基本分段存储管理方式" tabindex="-1"><a class="header-anchor" href="#基本分段存储管理方式" aria-hidden="true">#</a> 基本分段存储管理方式</h4><p>分段管理方式<strong>为考虑了用户和程序员而提出</strong>，以满足<strong>方便编程、信息保护和共享、动态增长、动态链接</strong>等多方面的需要</p><p>额外：分段后汇编语句：Load [D] | &lt;A&gt; 把 D 段的 A 加载，这样编程更方便，可读性更高</p><p>额外：分页用户不可见，而分段用户可见；段内必须连续导致段太长时找不到连续空间</p><h5 id="分段" tabindex="-1"><a class="header-anchor" href="#分段" aria-hidden="true">#</a> 分段</h5><p>段式管理方式<strong>按照用户进程中的自然段划分逻辑空间</strong>，每段<strong>从 0 开始编址</strong>，并分配一段<strong>连续的地址空间</strong>，其逻辑地址由<strong>段号</strong> S 与<strong>段内偏移量</strong> W 两部分组成，<strong>最多拥有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>S</mi></msup></mrow><annotation encoding="application/x-tex">2^S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span></span></span></span></span></span></span> 个段号，每段最长 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>W</mi></msup></mrow><annotation encoding="application/x-tex">2^W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span></span></span></span></span></span></span></span></span></span></span></strong></p><figure><img src="/408noteImg/images/image-20211111232955044.png" alt="image-20211111232955044" tabindex="0" loading="lazy"><figcaption>image-20211111232955044</figcaption></figure><p>在段式系统中，<strong>段号和段内偏移量必须由用户显式提供</strong>，在<u>高级程序设计语言中，这个工作由编译程序完成</u></p><h5 id="段表" tabindex="-1"><a class="header-anchor" href="#段表" aria-hidden="true">#</a> 段表</h5><p>每个进程都有一张段表，<strong>用于实现从逻辑段到物理内存区的映射</strong>，其中<strong>每个段表项对应进程的一段</strong></p><p>段表项由<strong>段号、段基址、段长</strong>组成，每个段表项<strong>长度相同</strong>，<strong>段长位数和逻辑地址中的段长一样，基址位数和内存大小一样</strong></p><figure><img src="/408noteImg/images/image-20211111233027685.png" alt="image-20211111233027685" tabindex="0" loading="lazy"><figcaption>image-20211111233027685</figcaption></figure><p>这是进程的段与物理内存的映射关系：</p><figure><img src="/408noteImg/images/image-20211111233103169.png" alt="image-20211111233103169" tabindex="0" loading="lazy"><figcaption>image-20211111233103169</figcaption></figure><h5 id="地址变换机构" tabindex="-1"><a class="header-anchor" href="#地址变换机构" aria-hidden="true">#</a> 地址变换机构</h5><figure><img src="/408noteImg/images/image-20211111233139262.png" alt="image-20211111233139262" tabindex="0" loading="lazy"><figcaption>image-20211111233139262</figcaption></figure><p>为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了<strong>段表寄存器</strong>，用于存放<strong>段表始址</strong> F 和<strong>段表长度</strong> M</p><p>从逻辑地址 A 到物理地址 E 之间的地址变换过程如下：</p><ol><li>从逻辑地址 A 中取出前几位为段号 S，后几位为段内偏移量 W</li><li>比较段号 S 和段表长度 M，<strong>若 S ≥ M，则产生越界中断，否则继续执行</strong></li><li><strong>段表项地址 = 段表始址 F＋段号 S × 段表项长度</strong></li><li>从段表项取出段长 C，<strong>若段内偏移量 ≥ C，则产生越界中断，否则继续执行</strong></li><li>从段表项取出该段的始址 b，计算<strong>物理地址 E = b + W</strong>，用得到的物理地址去访问内存</li></ol><h5 id="段的共享与保护" tabindex="-1"><a class="header-anchor" href="#段的共享与保护" aria-hidden="true">#</a> 段的共享与保护</h5><p>段的共享是通过<strong>两个作业的段表中相应表项指向被共享的段的同一个物理副本</strong>来实现的</p><p>当一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据，因此：</p><p><strong>不能修改的代码</strong>称为纯代码或可重入代码，这样的代码和<strong>不能修改的数据可以共享</strong>，而<strong>可修改的代码和数据不能共享</strong></p><p>分段管理的保护方法主要有两种：</p><ol><li><strong>存取控制保护</strong>：访问内存时查看段表项的保护码检查是否有该操作的权限</li><li><strong>地址越界保护</strong>：校验段号和段内地址偏移，保证不会访问过界</li></ol><p><strong>访问内存时要给出段号和段内偏移，因此分段管理的地址空间是二维的</strong></p><h4 id="段页式管理方式" tabindex="-1"><a class="header-anchor" href="#段页式管理方式" aria-hidden="true">#</a> 段页式管理方式</h4><p>段页式存储管理方式是<strong>页式存储和分段存储的结</strong>合，即<strong>有效地提高内存利用率</strong>，又<strong>反映程序的逻辑结构并有利于段的共享</strong></p><p>在段页式系统中，作业的地址空间首<strong>先被分成若干逻辑段</strong>，每段都有自己的段号，<strong>再将每段分成若干大小固定的页</strong></p><p>对<strong>内存空间的管理仍然和分页存储管理一样</strong>，将其分成若干和页面大小相同的存储块，对内存的分配以存储块为单位</p><figure><img src="/408noteImg/images/image-20211111233312557.png" alt="image-20211111233312557" tabindex="0" loading="lazy"><figcaption>image-20211111233312557</figcaption></figure><p>在段页式系统中，作业的逻辑地址分为三部分：<strong>段号、页号、页内偏移量</strong></p><figure><img src="/408noteImg/images/image-20211111233335202.png" alt="image-20211111233335202" tabindex="0" loading="lazy"><figcaption>image-20211111233335202</figcaption></figure><p>系统为<strong>每个进程建立一张段表，每个分段有一张页表</strong>：段表表项中至少包括<strong>段号、页表长度和页表始址</strong>；页表表项中至少包括<strong>页号和块号</strong>。系统中有一个<strong>段表寄存器</strong>，指出作业的<strong>段表始址和段表长度</strong></p><p>进行地址变换步骤：</p><ol><li>通过段表查到页表始址</li><li>通过页表找到页帧号</li><li>形成物理地址</li></ol><p>进行<strong>一次访问实际需要三次访问主存</strong>，可以使用快表来加快查找速度，其<strong>关键字由段号、页号组成</strong>，<strong>值是页帧号和保护码</strong></p><figure><img src="/408noteImg/images/image-20211111233427333.png" alt="image-20211111233427333" tabindex="0" loading="lazy"><figcaption>image-20211111233427333</figcaption></figure><p><strong>访问内存时要给出段号和页号，因此段页式管理的地址空间是二维的</strong></p><h2 id="虚拟内存管理" tabindex="-1"><a class="header-anchor" href="#虚拟内存管理" aria-hidden="true">#</a> 虚拟内存管理</h2><h3 id="虚拟内存的基本概念" tabindex="-1"><a class="header-anchor" href="#虚拟内存的基本概念" aria-hidden="true">#</a> 虚拟内存的基本概念</h3><h4 id="传统存储管理方式的特征" tabindex="-1"><a class="header-anchor" href="#传统存储管理方式的特征" aria-hidden="true">#</a> 传统存储管理方式的特征</h4><p>指上一节的存储管理方式，它们具有以下两个共同的特征：</p><ol><li>一次性：<strong>作业必须一次性全部装入内存后，才能开始运行</strong>这导致： <ul><li>当<u>作业很大而不能全部被装入内存</u>时，将使该作业无法运行</li><li>当<u>大量作业要求运行时，内存不足以容纳所有作业</u>，只能使少数作业先运行，导致多道程序度的下降</li></ul></li><li>驻留性：作业被装入内存后，<strong>不会换出任何内存，直至作业运行结束</strong>，即使进程会因等待 I/O 而被阻塞</li></ol><p>程序运行中<strong>暂时不用的程序或数据占据大量的内存空间</strong>，而一些需要运行的作业又无法装入运行，浪费了内存资源</p><h4 id="局部性原理" tabindex="-1"><a class="header-anchor" href="#局部性原理" aria-hidden="true">#</a> 局部性原理</h4><p><u>快表、页高速缓存、虚拟内存技术</u>从广义上讲，都属于高速缓存技术，其<u>所依赖的原理是局部性原理</u></p><p>局部性原理适用于程序结构和数据结构，它表现在以下两个方面：</p><ol><li><p>时间局部性：</p><ul><li>某条指令一旦执行，不久后<strong>该指令可能再次执行</strong></li><li>某数据被访问过，不久后该<strong>数据可能再次被访问</strong></li></ul><p>将近来使用的指令和数据保存到高速缓冲存储器中，并使用高速缓存的层次结构实现</p></li><li><p>空间局部性：一旦程序访问了某个存储单元，在不久后，其<strong>附近的存储单元也将被访问</strong></p><p>使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现</p></li></ol><p>虚拟内存技术就是<strong>使用内存对外存进行高速缓存</strong>，使得有外存的容量和内存的速度，<strong>利用局部性原理实现</strong></p><h4 id="虚拟存储器的定义和特征" tabindex="-1"><a class="header-anchor" href="#虚拟存储器的定义和特征" aria-hidden="true">#</a> 虚拟存储器的定义和特征</h4><p>根据局部性原理得：</p><ol><li>程序的<strong>一部分装入内存，就可启动程序执行</strong></li><li>程序执行过程中，所访问的信息<strong>不在内存时，将其调入内存继续执行</strong></li><li>OS 将<strong>暂时不使用的内容换出到外存上，腾出空间放要调入内存的信息</strong></li></ol><p>这样，系统似乎给用户提供了一个比实际内存大得多的存储器，称为<strong>虚拟存储器</strong>（实际上不存在）</p><p>这是由系统提供了对用户透明的<u>部分装入、请求调入、置换功能</u>实现的</p><ul><li><strong>虚拟内存的实际容量 ≤ 内存容量和外存容量之和</strong></li><li><strong>虚拟内存的最大容量 ≤ 计算机的地址位数能容乃的最大容量</strong></li></ul><p>虚拟存储器有以下三个主要特征：</p><ol><li>多次性：无须在作业运行时一次性地全部装入内存，而<strong>允许被分成多次调入内存运行</strong></li><li>对换性：无须在作业运行时一直常驻内存，而<strong>允许在作业的运行过程中，进行换进和换出</strong></li><li>虚拟性：从逻辑上扩充内存的容量，使<strong>用户所看到的内存容量远大于实际的内存容量</strong></li></ol><h4 id="虚拟内存技术的实现" tabindex="-1"><a class="header-anchor" href="#虚拟内存技术的实现" aria-hidden="true">#</a> 虚拟内存技术的实现</h4><p><strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上</strong>，否则将作业分多次调入内存时，难以分配连续内存</p><p>虚拟内存的实现有<strong>以下三种方式</strong>：</p><ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ul><p>不管哪种方式，都需要有一定的硬件支持，一般需要：</p><ul><li>一定容量的<strong>内存和外存</strong></li><li><strong>页表机制或段表机制</strong>，作为主要的数据结构</li><li><strong>中断机构</strong>，当用户程序要访问的部分尚未调入内存时，则产生中断</li><li><strong>地址变换机构</strong>，逻辑地址到物理地址的变换</li></ul><h3 id="请求分页管理方式" tabindex="-1"><a class="header-anchor" href="#请求分页管理方式" aria-hidden="true">#</a> 请求分页管理方式</h3><p>在基本分页系统基础之上，增加了<strong>请求调页功能和页面置换功能</strong>，从而支持虚拟存储器功能</p><p>在请求分页管理方式中：</p><ol><li>只需将<u>当前需要的一部分页面装入内存</u>，便可以启动作业运行</li><li>在作业执行过程中，<u>要访问的页面不在内存中时，通过调页功能将其调入</u></li><li>还可通过置换功能<u>将暂时不用的页面换出到外存上，以便腾出内存空间</u></li></ol><p>为了实现请求分页需要：<strong>一定容量的内存及外存、页表机制、缺页中断机构、地址变换机构</strong></p><h4 id="页表机制" tabindex="-1"><a class="header-anchor" href="#页表机制" aria-hidden="true">#</a> 页表机制</h4><p>因为没有一次加载进内存，请求分页系统必须解决的两个基本问题：<strong>如何发现和处理要访问的页面不在内存中的情况</strong></p><p>因此在请求页表项中增加了 4 个字段：</p><figure><img src="/408noteImg/images/image-20211113205422298.png" alt="image-20211113205422298" tabindex="0" loading="lazy"><figcaption>image-20211113205422298</figcaption></figure><ul><li>状态位 P：指示<strong>该页是否已调入内存</strong>，供程序访问时参考</li><li>访问字段 A：记录本页在一段时间内被访问的次数或多长时间未被访问，<strong>供置换算法换出页面时参考</strong></li><li>修改位 M：标识该页在<strong>调入内存后是否被修改过</strong></li><li>外存地址：用于指出该页<strong>在外存上的地址</strong>，供调入该页时参考，通常和物理块号共用</li></ul><p>思考：当程序被挂起时，把页面都调到外存，并修改页表的物理块号，令其为外存地址；这样可以只留最高级页表在内存</p><h4 id="缺页中断机构" tabindex="-1"><a class="header-anchor" href="#缺页中断机构" aria-hidden="true">#</a> 缺页中断机构</h4><p>在请求分页系统中，每当所要访问的页面不在内存中时：</p><ol><li><strong>产生一个缺页中断</strong>，请求操作系统将所缺的页调入内存</li><li><strong>将缺页的进程阻塞</strong>，调页完成后唤醒</li><li>若没有空闲块，则要<strong>淘汰某页</strong>，若其<strong>修改位为 1，则要将其写回外存</strong>，此时有空闲块</li><li><strong>分配一个空闲块</strong>，将要调入的页装入该块，并<strong>修改页表中的相应页表项</strong></li></ol><p>缺页中断与一般的中断相比，有以下不同的区别:</p><ul><li>在<strong>指令执行期间产生和处理中断信号</strong>，属于<strong>内部中断</strong></li><li>一条指令在执行期间，可能<strong>产生多次缺页中断</strong></li><li>执行完中断后会<strong>回到引发中断的指令重新执行</strong></li></ul><h4 id="地址变换机构-1" tabindex="-1"><a class="header-anchor" href="#地址变换机构-1" aria-hidden="true">#</a> 地址变换机构</h4><p>请求分页系统中的地址变换机构，是<strong>在分页系统地址变换机构的基础上</strong>，为实现虚拟内存又<strong>增加了某些功能</strong>而形成的</p><figure><img src="/408noteImg/images/image-20211113205529519.png" alt="image-20211113205529519" tabindex="0" loading="lazy"><figcaption>image-20211113205529519</figcaption></figure><p>一般来说<strong>只需修改快表中的数据</strong>，只有要将<strong>快表项删除时才需要写回内存中的慢表</strong></p><ol><li>快表当查询成功时，要<strong>修改访问位，写指令要额外修改修改位</strong>，最后<strong>计算出物理地址</strong>，而失败时去慢表查找</li><li>慢表找到表项后检查状态位，若<strong>在内存将表项复制到快表</strong>转步骤 1，若<strong>在外存产生缺页中断</strong></li><li>页面调入内存后，需要<strong>修改慢表</strong>，同时也需要<strong>将表项复制到快表中</strong>，转步骤 1</li></ol><h3 id="页面置换算法" tabindex="-1"><a class="header-anchor" href="#页面置换算法" aria-hidden="true">#</a> 页面置换算法</h3><p>页面对换时，若内存已无空闲空间，就需要<strong>使用页面置换算法从内存中调出一页程序或数据</strong>到外存</p><p>好的页面置换算法应有较低的页面更换频率，应将<strong>以后或较长时间内不会再访问的页面先调出</strong></p><h4 id="最佳-opt-置换算法" tabindex="-1"><a class="header-anchor" href="#最佳-opt-置换算法" aria-hidden="true">#</a> 最佳 OPT 置换算法</h4><p>最佳置换算法：被淘汰页面是<strong>永不使用或最长时间内不再被访问</strong>的页面，<strong>缺页率最低</strong>，因无法预知未来<strong>该算法无法实现</strong></p><p>最佳置换算法<strong>用来评价其他算法</strong>；下面是例子有 3 个物理块，和页面引用串，<strong>每次置换出最晚访问的页面</strong>：</p><figure><img src="/408noteImg/images/image-20211113224027924.png" alt="image-20211113224027924" tabindex="0" loading="lazy"><figcaption>image-20211113224027924</figcaption></figure><h4 id="先进先出-fifo-页面置换算法" tabindex="-1"><a class="header-anchor" href="#先进先出-fifo-页面置换算法" aria-hidden="true">#</a> 先进先出 FIFO 页面置换算法</h4><p>优先<strong>淘汰最早进入内存的页面</strong>；该算法<strong>与进程实际运行时的规律不适应</strong>，进入内存的时间和以后是否访问没有关系</p><p>下面是例子，数据和上面的一样，但这里进行了 12 次页面置换：</p><figure><img src="/408noteImg/images/image-20211113224308406.png" alt="image-20211113224308406" tabindex="0" loading="lazy"><figcaption>image-20211113224308406</figcaption></figure><p>Belady 异常：产生所分配的<strong>物理块数增大而页故障数不减反增</strong>的异常现象，<strong>只有 FIFO 算法可能出现 Belady 异常</strong></p><p>下面是 Belady 的例子，物理块增大了，但缺页次数不减反增：</p><figure><img src="/408noteImg/images/image-20211113224342794.png" alt="image-20211113224342794" tabindex="0" loading="lazy"><figcaption>image-20211113224342794</figcaption></figure><h4 id="最近最久未使用-lru-置换算法" tabindex="-1"><a class="header-anchor" href="#最近最久未使用-lru-置换算法" aria-hidden="true">#</a> 最近最久未使用 LRU 置换算法</h4><p>淘汰<strong>最近最长时间未访问过的页面</strong>，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问</p><p>该算法为每个页面<strong>设置一个访问字段</strong>，记录页面自上次被访问以来所经历的时间，淘汰时<strong>选择现有页面中值最大的予以淘汰</strong></p><figure><img src="/408noteImg/images/image-20211113224416563.png" alt="image-20211113224416563" tabindex="0" loading="lazy"><figcaption>image-20211113224416563</figcaption></figure><p>LRU 算法是向前看的，最佳置换算法是向后看的；LRU 算法的性能较好，但<strong>需要寄存器和栈的硬件支持</strong></p><p>LRU 是堆栈类的算法，<strong>堆栈类算法不可能出现 Belady 异常</strong></p><h4 id="时钟-clock-置换算法" tabindex="-1"><a class="header-anchor" href="#时钟-clock-置换算法" aria-hidden="true">#</a> 时钟 CLOCK 置换算法</h4><p>CLOCK 算法给每帧关联一个附加位，称为<strong>使用位</strong>：</p><ol><li>当某页<strong>首次装入主存或再被访问</strong>时，将该帧的<strong>使用位设置为 1</strong></li><li>有一个指针指向用于替换的候选帧集合（看作循环缓冲区），<strong>一页被替换时，指针指向下一帧</strong></li><li>需要替换一页时，<strong>从指针位置开始循环查找</strong>，找出<strong>使用位为 0 的来替换</strong>，把<strong>跳过的帧的使用位 1 的帧置为 0</strong></li></ol><p>因为算法要<strong>循环扫描缓冲区</strong>，像时钟的指针一样转动，所以称为 CLOCK 算法，又称<strong>最近未用 NRU 算法</strong></p><p>CLOCK 算法的性能比较接近 LRU 算法，而通过增加使用的位数目，可以使得 CLOCK 算法更加高效</p><p>下面使用一个例子来详细说明 CLOCK 算法：</p><figure><img src="/408noteImg/images/image-20211114165819204.png" alt="image-20211114165819204" tabindex="0" loading="lazy"><figcaption>image-20211114165819204</figcaption></figure><p>进程依次访问 1, 3, 4, 2, 5 号页面，系统会将这些页面连成一个循环队列，刚开始扫描指针指向第一个被访问的页面，如图 a</p><p>进程请求访问 6 号页面，选择一个页面置换出去，在第一轮扫描中，指针扫过的页面的使用位置为 0，如图 b</p><p>第二轮扫描中换出首个使用位为 0 的页面，换入 6 号页面并设置访问位为 1，将扫描指针后移，下次从 3 号页开始，如图 c</p><p>注意：1 号页面原先占有的是 x 号物理块，则 6 号页面换入内存后也放在 x 号物理块中</p><h4 id="改进型-clock-置换算法" tabindex="-1"><a class="header-anchor" href="#改进型-clock-置换算法" aria-hidden="true">#</a> 改进型 CLOCK 置换算法</h4><p>改进型 CLOCK 置换算法：在使用位的基础上<strong>再增加一个修改位</strong></p><p>每帧都处于以下 4 种情况之一：</p><ol><li>未访问未修改：u = 0, m = 0</li><li>被访问未修改：u = 1, m = 0</li><li>未访问被修改：u = 0, m = 1</li><li>被访问被修改：u = 1, m = 1</li></ol><p>算法执行如下操作步骤：</p><ol><li>从指针的当前位置开始，扫描帧缓冲区<strong>选择 u = 0, m = 0 来替换，不做任何修改</strong></li><li>若第 1 步失败，则重新扫描，<strong>选择 u = 0, m = 1 来替换</strong>，每个<strong>跳过的帧的使用位设置成 0</strong></li><li>若第 2 步失败，返回第 1 步</li></ol><p>改进型 CLOCK 算法<strong>首选没访问的页，次选没修改的页</strong>，没修改的页被替换时<strong>不用写回</strong>，这样做会节省时间</p><p>优化页面置换算法的原则：<strong>尽可能保留曾经使用过的页面</strong>，而<strong>淘汰未使用的页面</strong>，认为可以在总体上减少换页次数</p><h3 id="页面分配策略" tabindex="-1"><a class="header-anchor" href="#页面分配策略" aria-hidden="true">#</a> 页面分配策略</h3><h4 id="驻留集大小" tabindex="-1"><a class="header-anchor" href="#驻留集大小" aria-hidden="true">#</a> 驻留集大小</h4><p>进程的<strong>驻留集</strong>：给一个进程<strong>分配的物理页框的集合</strong>；操作系统必须<strong>决定给特定的进程分配几个页框</strong></p><p>需要考虑以下几点：</p><ol><li>驻留集越小，驻留在主存中的进程数就越多，可以<strong>提高处理机的时间利用效率</strong></li><li>驻留集过少，则尽管有局部性原理，<strong>页错误率仍然会相对较高</strong></li><li>驻留集过多，则由于局部性原理，分配更多的主存空间<strong>对该进程的错误率没有明显的影响</strong></li></ol><p>页面的分配置换策略有：</p><ul><li>固定分配：操作系统为进程分配好物理块后，<strong>驻留集大小不变</strong></li><li>可变分配：操作系统为进程分配好物理块后，<strong>驻留集大小可变</strong></li><li>局部置换：只能选进程<strong>自己的物理块进行置换</strong></li><li>全局置换：可以<strong>从操作系统拿物理块</strong>，也可以<strong>抢其他进程的物理块</strong></li></ul><p>现代操作系统通常采用三种策略，<u>开始时都为进程分配一定的物理块</u>：</p><ol><li><p>固定分配 + 局部置换：<strong>驻留集固定</strong>，缺页时<strong>只能从自己的物理块进行置换</strong></p><p><strong>难以确定驻留集大小</strong>：太少会频繁出现缺页中断，太多又会使 CPU 和其他资源利用率下降</p></li><li><p>可变分配 + 全局置换：<strong>驻留集可变</strong>，缺页时 OS 会<strong>从空闲块中分配一个物理块给该进程</strong>，最简单的策略</p><p>可以动态的增加物理块，但也<strong>会盲目地给进程增加物理块</strong>，从而<strong>导致系统多道程序的并发能力下降</strong></p></li><li><p>可变分配 + 局部置换：<strong>驻留集可变</strong>，缺页时只能从自己的物理块进行置换，但 OS <strong>根据缺页率动态调整驻留集</strong></p><p>优点：在<strong>保证进程不会过多地调页</strong>的同时，也<strong>保持了系统的多道程序并发能力</strong></p><p>缺点：需要<strong>更复杂的实现</strong>，也需要<strong>更大的开销</strong>，但对比频繁地换入/换出所浪费的计算机资源，这种牺牲是值得的</p></li></ol><p>注意：没有固定分配 + 全局置换，因为全局置换就会增加物理块与固定分配矛盾</p><h4 id="调入页面的时机" tabindex="-1"><a class="header-anchor" href="#调入页面的时机" aria-hidden="true">#</a> 调入页面的时机</h4><p>为确定系统将进程运行时所缺的页面调入内存的时机，有以下调页策略：</p><ol><li><p>预调页策略：<u>一次调入多页比多次调入多页时间要短</u>，可以根据局部性原理，<strong>一次调入多个相邻页</strong></p><p>这样可能会更高效，但若调入页面中大多数都未被访问又是低效的</p><p>因此需要采用以预测为基础的预调页策略，但目前预调页的成功率仅约 50%</p><p>因此<strong>主要用于进程的首次调入</strong>，由程序员指出应先调入哪些页，如调入 main 函数</p></li><li><p>请求调页策略：访问的页面不在内存时，<strong>请求 OS 将所需页面调入内存</strong></p><p>调入的页<strong>一定会被访问</strong>，且策略<strong>更易于实现</strong>，故目前的虚拟存储器中<strong>大多采用此策略</strong></p><p>缺点：每次只调入一页，<u>调入/调出页面数多时会花费过多的 I/O 开销</u></p></li></ol><p>预调入就是<strong>运行前的调入</strong>，请求调页就是<strong>运行期间调入</strong>；通常两种调页策略会<strong>同时使用</strong></p><h4 id="从何处调入页面" tabindex="-1"><a class="header-anchor" href="#从何处调入页面" aria-hidden="true">#</a> 从何处调入页面</h4><p>外存分为<strong>离散分配方式的文件区</strong>和<strong>连续分配方式的对换区</strong>，因此<strong>对换区的磁盘 I/O 速度比文件区的更快</strong></p><p>从何处调入页面存在三种情况：</p><ol><li><p>系统拥有足够的对换区空间：运行前，将进程有关的文件<strong>复制到对换区</strong>；运行时，<strong>从对换区调入所需页面</strong></p></li><li><p>系统缺少足够的对换区空间：</p><p>刚开始进程`有关的文件<strong>都从文件区读入</strong>，换出时：</p><ul><li>不会被修改的文件<strong>直接覆盖</strong></li><li>可能被修改的文件<strong>换到对换区</strong>，需要时再从对换区调入（读比写快）</li></ul></li><li><p>UNIX 方式：</p><p>与进程有关的文件都放在文件区，因此<strong>未运行过的页面都应从文件区调入</strong></p><p><strong>换出是都换出到对换区</strong>，曾经运行过但又被换出的页面，下次调入时应从对换区调入</p><p>进程请求的共享页面若被其他进程调入内存，则无须再从对换区调入</p></li></ol><h3 id="抖动" tabindex="-1"><a class="header-anchor" href="#抖动" aria-hidden="true">#</a> 抖动</h3><p>抖动，颠簸：<strong>频繁进行页面调度</strong>，如刚换出又要换入，刚换入又要换出，这是由 CPU 的<strong>调度算法不合理</strong>引起的</p><p>进程在颠簸：一个进程<strong>在换页上用的时间多于执行时间</strong></p><p>频繁发生缺页中断的主要原因：某个进程频繁<strong>访问的页面数目高于可用的物理页帧数目</strong></p><p>虚拟内存技术可在内存中<strong>保留更多的进程以提高系统效率</strong></p><p>在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程</p><p>如果管理不当，那么处理机的<strong>大部分时间都将用于交换块</strong>，会大大降低系统效率</p><h3 id="工作集" tabindex="-1"><a class="header-anchor" href="#工作集" aria-hidden="true">#</a> 工作集</h3><p>基于局部性原理，可以<strong>用最近访问过的页面来确定工作集</strong>，最近访问的页面以后很可能会再访问</p><p>工作集：<strong>在某段时间间隔内，进程要访问的页面集合</strong>，工作集 W 可由时间 t 和工作集窗口大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span></span></span></span> 来确定</p><p>工作集<u>反映了进程在接下来的一段时间内很有可能会频繁访问的页面集合</u></p><p>例如，某进程对页面的访问次序如下：</p><p 1,2,3,4="">假设工作集窗口大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span></span></span></span> 为5，则在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时刻，进程的工作集为{2,3,5}，在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时刻，进程的工作集为</p><figure><img src="/408noteImg/images/image-20211113224837075.png" alt="image-20211113224837075" tabindex="0" loading="lazy"><figcaption>image-20211113224837075</figcaption></figure><p>实际应用中，工作集窗口会设置得很大，即对于<u>局部性好的程序，工作集大小一般会比工作集窗口 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span></span></span></span> 小很多</u></p><p>若<strong>驻留集大小小于工作集大小</strong>，则该进程就很有<strong>可能频繁缺页</strong>，为防止这种抖动现象，<strong>驻留集大小要大于工作集大小</strong></p><p>工作集模型的原理是：</p><ul><li>让操作系统<strong>跟踪每个进程的工作集</strong>，并为进程<strong>分配大于其工作集的物理块</strong></li><li>工作集内的页面需要<strong>调入驻留集中</strong>，工作集外的页面可<strong>从驻留集中换出</strong></li><li>若还有<strong>空闲物理块</strong>，则可以再<strong>调一个进程到内存</strong>以增加多道程序数</li><li>若所有<strong>工作集之和超过可用物理块数</strong>，则<strong>暂停一个进程</strong>，将其页面调出并将其物理块分配给其他进程，以防止抖动</li></ul></div><!----><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: doc_408@163.com">408doc</span><!--]--><!--]--></div></div></footer><nav class="page-nav"><a href="/408notes/OS/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html" class="nav-link prev" aria-label="第二章 进程管理"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->第二章 进程管理</div></a><a href="/408notes/OS/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.html" class="nav-link next" aria-label="第四章 文件管理"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">第四章 文件管理<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">默认页脚</div><div class="copyright">Copyright © 2023 研小布</div></footer></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-e88d6ffa.js" defer></script>
  </body>
</html>
